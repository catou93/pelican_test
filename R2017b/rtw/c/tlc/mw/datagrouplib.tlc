%%
%% Copyright 2015-2017 The MathWorks, Inc.
%%
%% Abstract:
%%   This system TLC library file contains functions that are related to 
%%   Simulink.CoderGroups
%%

%if EXISTS("_DATAGROUPLIB_") == 0
%assign _DATAGROUPLIB_ = 1

%% Function: LibCoderDataGroupStructIsEmpty ============================================
%% Abstract:
%%   Does the root system have a CoderDataGroup of the given name?
%%
%function LibCoderDataGroupStructIsEmpty(group) void
  %assign baseSysIdx = GetBaseSystemIdx()
  %assign fieldName = "HasCoderDataGroup" + group.Name + "Arg"
  %if SLibIsSynthesizedRTM(group)
    %return !IsModelRefScalableBuild() ? ::CompiledModel.EmptyRealTimeObject : TLC_TRUE
  %elseif group.AsStructure == "None"
    %return TLC_TRUE
  %endif
  %assert (ISFIELD(::CompiledModel.System[baseSysIdx], fieldName))
  %return (::CompiledModel.System[baseSysIdx].%<fieldName> == 0)
%endfunction

%% Function: FcnGetCoderGroupForVarGroup ==============================================
%function FcnGetCoderGroupForVarGroup(varGroup) void
  %assert varGroup.Category == "HierarchicalCoderData"
  %return ::CompiledModel.CoderDataGroup[varGroup.CoderDataGroupIndex]
%endfunction

%% Function: SLibHaveRootDataGroupVarGroup ============================================
%% Abstract:
%%   Does the root system have a non-empty CoderDataGroup var group of the given name?
%%
%function SLibHaveRootDataGroupVarGroup(group) void
  %assign rootSystemIndex = GetBaseSystemIdx()
  %foreach varGroupIndex = ::CompiledModel.VarGroups.NumVarGroups
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]

    %if varGroup.NumVarGroupElements <= 0
      %continue
    %endif
    %if (varGroup.SysIdx == rootSystemIndex) && ...
      (LibGetVarGroupCategory(varGroupIndex) == "HierarchicalCoderData")
      %assign coderGroupIndex = varGroup.CoderDataGroupIndex
      %assign coderGroup = ::CompiledModel.CoderDataGroup[coderGroupIndex]
      %if coderGroup.Name == group.Name
        %return TLC_TRUE
      %endif
    %endif
  %endforeach

  %return TLC_FALSE

%endfunction

%% Function: LibCoderDataGroupStructsAreEmpty ============================================
%% Abstract:
%%   Does the root system have any CoderDataGroups?
%%
%function LibCoderDataGroupStructsAreEmpty() void
  %foreach idx = ::CompiledModel.NumCoderDataGroups
    %if !LibCoderDataGroupStructIsEmpty(::CompiledModel.CoderDataGroup[idx])
      %return TLC_FALSE
    %endif
  %endforeach
  %return TLC_TRUE
%endfunction

%% Function: SLibCoderDataGroupIndex =======================================================
%% Abstract:
%%   Return the group index for the specified name
%%
%function SLibCoderDataGroupIndex(groupName) void
  %foreach idx = ::CompiledModel.NumCoderDataGroups
    %assign group = ::CompiledModel.CoderDataGroup[idx]
    %if group.Name == groupName
      %return group.GroupIndex
    %endif
  %endforeach
  %return -1
%endfunction

%% Function: RTMModelPtrsToCoderDataGroupIsReqFcn ===========================
%% Abstract:
%%   Does the address of the statically declared CoderDataGroup structures need to be 
%%   saved in rtModel. This is conditionally saved for simplified reusable call
%%   interface and always saved for classic call interface.
%function RTMModelPtrsToCoderDataGroupIsReqFcn(groupIndex) void
  %if LibCoderDataGroupStructIsEmpty(::CompiledModel.CoderDataGroup[groupIndex]) || SLibGetUseRTMcgType()
    %return TLC_FALSE
  %endif
  %if SLibMultiInstance() && ...
    !GenerateClassInterface && ...
    !SLibUseBackwardCompatibleReusableInterface()
    %return TLC_TRUE
  %endif
  %return RTMModelPtrsToInstanceDataIsReqFcn()
  
%endfunction %%  RTMModelPtrsToRootDWorkIsReqFcn

%function FcnGetChildDataGroup(group, sid) void
  %foreach idx = SIZE(::CompiledModel.CoderDataGroups.CoderDataGroup, 1)
    %assign coderDataGroup = ::CompiledModel.CoderDataGroups.CoderDataGroup[idx]
    %if (coderDataGroup.Name == group.Name) && ...
      coderDataGroup.Depth == 1 && ...
      ISFIELD(coderDataGroup, "CompiledModelBlockIndex") && ...
      (coderDataGroup.CompiledModelBlockIndex == sid)
      %return coderDataGroup
    %endif
  %endforeach
  %<LibReportFatalError("Should not get here")>
%endfunction

%% Function: SLibIsSelfVarGroup =====================================================
%function SLibIsSelfVarGroup(aVarGroup) void
  %return ISFIELD(aVarGroup, "IsSelfCoderDataGroupVarGroup") && ...
    aVarGroup.IsSelfCoderDataGroupVarGroup
%endfunction

%% Function: SLibIsSelfCoderGroup
%% Abstract:
%%   Given a system index and a coder group index, returns true iff the coder
%%   group for that system is the self coder group for the model.
%%   This implies that the system must be a base system for this function
%%   to return true.
%function SLibIsSelfCoderGroup(sysIdx, coderGroupIdx) void
  %return GetBaseSystemIdx() == sysIdx && ...
    SLibGetDoesSelfHasCoderDataGroup() && ...
    SLibGetSelfCoderDataGroupIndex() == coderGroupIdx
%endfunction

%% Function: SLibGetVarGroupIdxForCoderGroup
%% Abstract:
%%   Given a system index and a coder group index, returns the vargroup id
%%   that corresponds to the given system's coder group.
%function SLibGetVarGroupIdxForCoderGroup(sysIdx, coderDataGroupIdx) void
  %assign group = ::CompiledModel.CoderDataGroup[coderDataGroupIdx]
  %assign groupName = group.Name
  %assign groupToken = "CoderDataGroup" + groupName

  %return FcnSysVarGroupIndex(System[sysIdx], groupToken, 0)
%endfunction

%% Function: SLibGetRTMPointerVariableNameInsideSelfStructure()
%% Abstract:
%%   User-defined and legacy RTM can co-exist, in which case, we may have a pointer
%%   to legacy RTM inside the Self structure. This function returns the name of that
%%   pointer variable, if applicable. Otherwise, it returns an empty string.
%function SLibGetRTMPointerVariableNameInsideSelfStructure() void
  %if SLibIsSelfUserDefinedAndStructured()
    %% todo (sr): register and check for clashes in the Self structure    
    %return (::CompiledModel.Name + "_" + "rtm" + "_" + "ref")
  %endif
  
  %return ""
%endfunction

%% Function: SLibCanInlineRTMIntoSelf()
%% Abstract:
%%   Returns true iff coder group self exists and we can inline
%%   legacy RTM content directly inside this self's typedef.
%%   This can only happen if self's memory section is non const.
%function SLibCanInlineRTMIntoSelf() void  
  %return SLibGetDoesSelfHasCoderDataGroup() && SLibIsSelfStructured() && ...
    !SLibHasSelfWithConstantMemorySection() && !GenerateClassInterface
%endfunction

%% Function: FcnGetVargroupInitializer ============================================
%% Abstract:
%%     Return the initializer for the vargroup 
%function FcnGetVargroupInitializer(varGroupIndex, path, dynamicInit, symbolic) void
  %createrecord initializer {}
  %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]        
 
  %% Begin vargroup
  %foreach elemIdx = varGroup.NumVarGroupElements
    %assign element = varGroup.VarGroupElements[elemIdx]
    %assign idnum  = IDNUM(element)
    %assign recType = idnum[0]
    %assign recIdx  = idnum[1]
    %switch recType
      %case "LDW"
      %case "W"
      %case "U"
      %case "Y"
      %case "B"
      %case "ZE"
        %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
        %assign cgTypeIdx = LibGetRecordCGTypeIdx(dataRec)
        %% Exclude things like function-call-event signals
        %if SLibEmitRecordInCoderDataGroupStruct(cgTypeIdx)
          %assign value = FcnGetDynamicDataInitFromCGType(cgTypeIdx)
          %addtorecord initializer Elements { Element value }
        %endif
        %break

      %case "P"
        %assign prm = ::CompiledModel.ModelParameters.Parameter[recIdx]
        %if SLibIsParamUnstructured(prm)
          %assert 0
          %continue
        %endif
        %if (SLibGetWidthOfValueFromParamRec(prm) > 0) && !SLibOmitParameter(prm)
          %if symbolic && (prm.TestpointIndex >= 0)
            %addtorecord initializer Elements { Element "TP%<prm.TestpointIndex>" }
            %assign group = FcnGetCoderGroupForVarGroup(::CompiledModel.VarGroups.VarGroup[varGroupIndex])
            %if group.AsStructure == "InParent"
              %assign separator = "->"
            %else
              %assign separator = "."
            %endif
            %assign dynamicPath = path + separator + LibGetRecordIdentifier(prm)
            %addtorecord dynamicInit TP%<prm.TestpointIndex> dynamicPath
          %else
            %openfile value
            %<SLibGetFormattedPrmValue(prm, "")>
            %closefile value
            %addtorecord initializer Elements { Element value }
          %endif
        %endif
        %break

      %case "PD"
        %addtorecord initializer Elements { Element element }
        %break
        
      %case "VG"
        %addtorecord initializer Elements { Element FcnGetVargroupInitializer(recIdx, path, dynamicInit, symbolic) }
        %break
        
      %case "RTM"
        %assign cgTypeIdx = varGroup.CGTypeIdx
        %assign cgType = ::CompiledModel.CGTypes.CGType[cgTypeIdx]
        %assign elemCGTypeRec = cgType.Members.Member[recIdx]
        %assign elemCGTypeIdx = elemCGTypeRec.CGTypeIdx
        %assign value = FcnGetDynamicDataInitFromCGType(elemCGTypeIdx)
        %addtorecord initializer Elements { Element value }
        %break
        
      %case "PCDG"
        %assign group = FcnGetCoderGroupForVarGroup(varGroup)
        %assign childDataGroup = FcnGetChildDataGroup(group, recIdx)
        %assert childDataGroup.AsStructure == "InParent"
        %addtorecord initializer Elements { Element childDataGroup.Initializer }
        %break
        
      %case "RCDG"
          %if symbolic
            %addtorecord initializer Elements { Element element }
          %else
            %assign group = ::CompiledModel.CoderDataGroup[recIdx]
            %openfile value
            &(%<SLibCoderDataGroupInstance(group)>)
            %closefile value
            %addtorecord initializer Elements { Element value }
          %endif
        %break

      %case "RVG"
        %openfile value
        %<SLibGetNullDefinitionFromTfl()>
        %closefile value
        %addtorecord initializer Elements { Element value }
        %break

      %default
        %<LibReportFatalError("Unhandled vargroup initialization")>
        %break
    %endswitch
  %endforeach 
  %return initializer
%endfunction

%% Function: FcnGetDataGroupInitializer ============================================
%% Abstract:
%%     Return the initializer for the data group
%function FcnGetDataGroupInitializer(group, path, dynamicInit) void
  %if SLibDataGroupStaticInit(group)
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]      
    %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)
    %if varGroupIndex != -1
       %return FcnGetVargroupInitializer(varGroupIndex, path, dynamicInit, ...
          group.IsInstanceSpecific && SLibDataGroupStaticInit(group) && IsModelReferenceTarget())
    %else
      %return ""
    %endif
  %else
    %return ""
  %endif
%endfunction

%function SLibHasSelfWithConstantMemorySection() void
  %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
  %if selfCoderGroupIndex == -1
    %return TLC_FALSE
  %else
    %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
    %return SLibDataGroupMemorySectionConst(selfCoderGroup)
  %endif
%endfunction

%function SLibHasSelfWithStaticInit() void
  %assign selfCoderGroupIndex = SLibGetSelfCoderDataGroupIndex()
  %if selfCoderGroupIndex == -1
    %return TLC_FALSE
  %else
    %assign selfCoderGroup = ::CompiledModel.CoderDataGroup[selfCoderGroupIndex]
    %return SLibDataGroupStaticInit(selfCoderGroup)
  %endif
%endfunction

%% Function: SLibRootCoderGroupVarGroupIdx =====================================
%% Abstract:
%%   Returns the root level VarGroup index for a given CoderGroup.
%%
%function SLibRootCoderGroupVarGroupIdx(group) void
  %assign rootSystemIndex = GetBaseSystemIdx()
  %foreach varGroupIndex = ::CompiledModel.VarGroups.NumVarGroups
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]
    %if (varGroup.SysIdx == rootSystemIndex) && ...
      (LibGetVarGroupCategory(varGroupIndex) == "HierarchicalCoderData")
      %assign coderGroupIndex = varGroup.CoderDataGroupIndex
      %assign coderGroup = ::CompiledModel.CoderDataGroup[coderGroupIndex]
      %if coderGroup.Name == group.Name
        %return varGroupIndex
      %endif
    %endif
  %endforeach
  %return -1
%endfunction

%% Function: SLibGetRootVarGroupIdxForCoderGroup =======================================
%% Abstract:
%%   Returns the root vargroup index for a given Simulink.CoderGroup.
%%
%function SLibGetRootVarGroupIdxForCoderGroup(aGroup) void
  %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]      
  %assign varGroupIdx = ...
    FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + aGroup.Name, 0)
  %assert SLibRootCoderGroupVarGroupIdx(aGroup) == varGroupIdx
  %return varGroupIdx
%endfunction


%% Function: SLibVarGroupForCoderGroup ===========================================
%% Abstract:
%%   Returns a vargroup for a given Simulink.CoderGroup.
%%
%function SLibVarGroupForCoderGroup(aGroup) void
  %assign varGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
  %if 0 > varGroupIdx
    %return []
  %endif
  %return ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
%endfunction

%% Function: SLibCoderGroupPackageAsStruct ======================================
%% Abstract:
%%   Returns true if a given coder group is implemented as structure.
%%
%function SLibCoderGroupPackageAsStruct(aGroup) void
  %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
  %if -1 < rootVarGroupIdx
    %return SLibVarGroupIsStruct(rootVarGroupIdx)
  %endif
  %return TLC_TRUE
%endfunction

%function SLibCoderDataGroupNumElements(aGroup) void
  %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
  %if -1 < rootVarGroupIdx
    %if !SLibVarGroupIsStruct(rootVarGroupIdx)
      %return SLibVarGroupNumElements(rootVarGroupIdx)
    %elseif SLibVarGroupNumElements(rootVarGroupIdx) > 0 ...
      && !LibCoderDataGroupStructIsEmpty(aGroup)
      %return 1
    %endif
  %endif
  %return 0  
%endfunction

%function SLibCrossSystemIdxElement(aGroup, idx) void
  %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
  %assign retVal = -1
  %if -1 < rootVarGroupIdx
    %assign rootVarGroup = ::CompiledModel.VarGroups.VarGroup[rootVarGroupIdx]
    %assign member = rootVarGroup.VarGroupElements[idx]
    %assign idnum = IDNUM(member)
    %switch idnum[0]
      %case "VG"
        %assign childVG = ::CompiledModel.VarGroups.VarGroup[idnum[1]]
        %assign retVal = childVG.SysIdx
        %break
    %endswitch
  %endif
  %return retVal
%endfunction

%function SLibCrossCoderDataGroupElement(aGroup, idx) void
  %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
  %assign retVal = []
  %if -1 < rootVarGroupIdx
    %assign rootVarGroup = ::CompiledModel.VarGroups.VarGroup[rootVarGroupIdx]
    %assign member = rootVarGroup.VarGroupElements[idx]
    %assign idnum = IDNUM(member)
    %switch idnum[0]
      %case "VG"
        %assign childVG = ::CompiledModel.VarGroups.VarGroup[idnum[1]]
        %assign childCDGIdx = ISFIELD(childVG, "CoderDataGroupIndex") ? childVG.CoderDataGroupIndex : -1
        %assign retVal = childCDGIdx > -1 ? ::CompiledModel.CoderDataGroup[childCDGIdx] : []
        %break
      %case "PCDG"
        %assign retVal = FcnGetChildDataGroup(aGroup, idnum[1])
        %break
      %case "RCDG"
        %assign retVal = ::CompiledModel.CoderDataGroup[idnum[1]]
        %break
    %endswitch
  %endif
  %return retVal
%endfunction

%function SLibCoderDataGroupElementInstance(aGroup, idx) void
  %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
  %if -1 < rootVarGroupIdx
    %if !SLibVarGroupIsStruct(rootVarGroupIdx)
      %assign instance  = SLibVarGroupElementName(rootVarGroupIdx, idx)
      %assign cgTypeIdx = SLibVarGroupElementType(rootVarGroupIdx, idx)
      %return instance + LibCGTypeSymbolicVectorWidth(cgTypeIdx)
    %endif
  %endif
  %if IsModelRefScalableBuild() && !GenerateClassInterface
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %return FcnSysVarGroupNonreusedName(baseSystem, "CoderDataGroup" + aGroup.Name)
  %else
    %return SLibCoderDataGroupInstance(aGroup)
  %endif
%endfunction

%function SLibCoderDataGroupElementBaseType(aGroup, idx) void
  %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
  %if -1 < rootVarGroupIdx
    %if !SLibVarGroupIsStruct(rootVarGroupIdx)
      %assign cgTypeIdx = SLibVarGroupElementType(rootVarGroupIdx, idx)
      %return SLibGetTypeNameFromCGType(cgTypeIdx)
    %endif
  %endif
  %return SLibCoderDataGroupType(aGroup)
%endfunction

%function SLibCoderDataGroupElementInit(aGroup, instanceInit, idx) void
  %assign rootVarGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(aGroup)
  %if -1 < rootVarGroupIdx
    %if !SLibVarGroupIsStruct(rootVarGroupIdx)
      %return instanceInit[idx]
    %endif
  %endif
  %openfile init 
  {
    %<instanceInit>
  }\
  %closefile init
  %return init
%endfunction

%% Function: SLibCoderDataGroupType ================================================
%% Abstract:
%%     Return the name of the type of the data group
%function SLibCoderDataGroupType(group) void
  %if group.IsSelf && SLibCanInlineRTMIntoSelf()
    %return tSimStructType
  %elseif IsModelReferenceTarget()
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign groupToken = "CoderDataGroup" + group.Name
    %return FcnSysVarGroupType(baseSystem, groupToken)
  %else
    %assign token = "::tCoderDataGroup" + group.Name + "Type"
    %return %<token>
  %endif
%endfunction
  
%% Function: FcnApplyMemSecToDataDefnForGroup ===================================
%% Abstract
%%   Helper function
%function FcnApplyMemSecToDataDefnForGroup(definition, group, identifier, system, isModelData, isDecl, isFirstElement, isLastElement) void
  %if IsModelReferenceSimTarget() && group.AsStructure == "None"
    %return ""
  %endif
  %assign msName = group.MemorySection
  %assign applyMemSec = FcnApplyMemSec()
  %openfile buffer
  %if !isModelData
    %<SLibIfSystemPreprocessorCondition(system)>\

  %endif
  %if applyMemSec && !ISEMPTY(msName)
    %assign msDefn = SLibGetInternalMemorySectionDefForName(msName)
    %<SLibCreateDefinitionStatement(definition, msDefn, identifier, TLC_TRUE, isDecl, isFirstElement, isLastElement)>
  %elseif isDecl
    extern %<definition>
  %else
    %<definition>
  %endif
  %if !isModelData
    %<SLibEndIfSystemPreprocessorCondition(system)>\
  %endif
  %closefile buffer
  %return buffer
%endfunction

%% Function: SLibApplyMemSecToDataDefnForGroup ===================================
%% Abstract
%%   This function creates a data definition.  Rather than inserting a
%%   definition directly, data should now go through this central mechanism
%%   to add memory section things like pragmas, modifiers, etc.  This
%%   function is similar to SLibApplyMemSecToDataDefnForSystem()
%function SLibApplyMemSecToDataDefnForGroup(definition, group, identifier, system, isModelData) void
  %return FcnApplyMemSecToDataDefnForGroup(definition, group, identifier, system, isModelData, TLC_FALSE, TLC_TRUE, TLC_TRUE)
%endfunction

%% Function: SLibApplyMemSecToDataDeclForGroup ===================================
%% Abstract
%%   This function creates a data declaration.  Rather than inserting a
%%   definition directly, data should now go through this central mechanism
%%   to add memory section things like pragmas, modifiers, etc.  This
%%   function is similar to SLibApplyMemSecToDataDeclForSystem()
%function SLibApplyMemSecToDataDeclForGroup(definition, group, identifier, system, isModelData) void
  %return FcnApplyMemSecToDataDefnForGroup(definition, group, identifier, system, isModelData, TLC_TRUE, TLC_TRUE, TLC_TRUE)
%endfunction

%% Function: SLibTypeQualifierForGroup ===========================================
%% Abstract
%%   This function returns a type qualifier for a group
%function SLibTypeQualifierForGroup(group) void
  %assign msName = group.MemorySection
  %assign applyMemSec = FcnApplyMemSec()
  %if applyMemSec && !ISEMPTY(msName)
    %assign msDefn = SLibGetInternalMemorySectionDefForName(msName)
    %return SLibGetQualifier(msDefn)
  %else
    %return ""
  %endif
%endfunction

%% Function: SLibCoderDataGroupIsImported ========================================
%% Abstract:
%%     Return whether the data group has imported data scope
%function SLibCoderDataGroupIsImported(group) void
  %return group.DataScope == "Imported"
%endfunction

%% Function: SLibCoderDataGroupIsOpaque ========================================
%% Abstract:
%%     Return whether the data group has opaque data scope
%function SLibCoderDataGroupIsOpaque(group) void
  %return group.IsOpaque
%endfunction

%% Function: SLibCoderDataGroupIsImportedFromFile =================================
%% Abstract:
%%     Return whether the data group has imported data scope with a header 
%%     file other than model.h
%function SLibCoderDataGroupIsImportedFromFile(group) void
  %if group.IsLegacyStorageClass
    %return TLC_TRUE
  %endif
  
  %if !SLibCoderDataGroupIsImported(group)
    %return TLC_FALSE
  %endif

  %% Get the base system's vargroup and check the header file. If it's not
  %% model.h, then return
  %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]      
  %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)

  %assign modelNameHeader = ::CompiledModel.Name+".h"
  %assert varGroupIndex != -1
    
  %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIndex]
  %assign headerFile = varGroup.CoderDataGroupHeaderFile
  %if headerFile == modelNameHeader
    %return TLC_FALSE
  %else
    %return TLC_TRUE
  %endif
%endfunction
  
%% Function: SLibCoderDataGroupInstance ============================================
%% Abstract:
%%     Return the name of the instance of the data group
%function SLibCoderDataGroupInstance(group) void
  %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]      
  %assign varGroupIndex = FcnSysVarGroupIndex(baseSystem, "CoderDataGroup" + group.Name, 0)
  %if varGroupIndex != -1 && group.IsSelf != 1
    %return ::CompiledModel.VarGroups.VarGroup[varGroupIndex].StructureInstanceName  
  %else
    %assign token = "::tCoderDataGroup" + group.Name
    %return %<token>
  %endif
%endfunction


%% Function: SLibCoderDataGroupRTMFieldName ============================================
%% Abstract:
%%     Return the name of the field of the data group in the rtM
%function SLibCoderDataGroupRTMFieldName(group) void
  %if ::CompiledModel.SuppressSelf
    %return ""
  %endif

  %if SLibGetDoesSelfHasCoderDataGroup()
    %if group.AsStructure == "InParent"
      %assign eleNameOrIndex = "RCDG" + STRING(group.GroupIndex)
    %elseif group.AsStructure == "InSelf"
      %assign eleNameOrIndex = "VG" + STRING(SLibRootCoderGroupVarGroupIdx(group))
    %else
      %return ""
    %endif
    %assign selfVarGroupIdx = SLibGetSelfVarGroupIndex()
    %assign elIdx = SLibGetElementIdxFromVarGroup(selfVarGroupIdx, eleNameOrIndex)
    %% Undefined
    %if -1 == elIdx
      %return "CoderGroup" + group.Name
    %else
      %return SLibVarGroupElementName(selfVarGroupIdx, elIdx)
    %endif
  %else
    %assign rootVarGroupIndex = SLibGetRootVarGroupIdxForCoderGroup(group)
    %if rootVarGroupIndex > -1
      %assign rootVarGroup = ::CompiledModel.VarGroups.VarGroup[rootVarGroupIndex]
      %assert ISFIELD(rootVarGroup, "StructureReferenceName")
      %return rootVarGroup.StructureReferenceName
    %else
      %% Propagated coder data group case
      %return "CoderGroup" + group.Name
    %endif
  %endif
%endfunction

%% Function: SLibDataRecordIsInCoderGroup() =========================================
%% Abstract:
%%  Check if this record has a varGroupIndex and then check if
%%  that belongs to a coderDataGroupVarGroup. Return true if 
%%  that is the case. 
%function SLibDataRecordIsInCoderGroup(dataRec) void
  %assign coderGroupId = SLibGetCoderGroupIdForDataRecord(dataRec)
  %return coderGroupId != -1 ? TLC_TRUE : TLC_FALSE
%endfunction

%% Function: SLibGetCoderGroupIdForDataRecord
%% Abstract:
%%  Given a data record, returns the coder group vargroup index.
%%  If no such index can be found, returns -1.
%function SLibGetCoderGroupIdForDataRecord(dataRec) void
  %if( ISFIELD(dataRec,"VarGroupIdx") )
    %assign varGroupIdx = dataRec.VarGroupIdx[0]
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %if LibGetVarGroupCategory(varGroupIdx) == "HierarchicalCoderData"
      %assert ISFIELD(varGroup, "CoderDataGroupIndex")
      %return varGroup.CoderDataGroupIndex
    %endif
  %endif
  %return -1
%endfunction

%% Function: SLibIsLegacyStorageClassForDataRecord()  ================
%% Abstract:
%%  This function returns true if a particular data record
%%  belongs to a "Legacy Storage Class" vargroup. This is needed
%%  to help emit default mapping with Custom Storage classes.
%function SLibIsLegacyStorageClassForDataRecord(dataRec) void
  %if( ISFIELD(dataRec,"VarGroupIdx") )
    %assign varGroupIdx = dataRec.VarGroupIdx[0]
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %if varGroup.Category == "HierarchicalCoderData"
      %assign group = FcnGetCoderGroupForVarGroup(varGroup)
      %return group.IsLegacyStorageClass
    %endif
  %endif
  %return TLC_FALSE
%endfunction

%% Function: SLibGetCoderDataGroupStructForRecord() =========================================
%% Abstract:
%%  Assuming that the dataRec passed in is in a coder data group,
%%  return that coder data group struct name. 
%%  This function should only ever be called after calling 
%%  SLibDataRecordIsInCoderGroup() above passes true.  
%function SLibGetCoderDataGroupStructForRecord(dataRec) void
  %assert SLibDataRecordIsInCoderGroup(dataRec) == TLC_TRUE
  %assign structName = ""
  %if( ISFIELD(dataRec,"VarGroupIdx") )
    %assign varGroupIdx = dataRec.VarGroupIdx[0]
    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %if (LibGetVarGroupCategory(varGroupIdx) == "HierarchicalCoderData" && (varGroup.PackageAsStruct != 0))
      %assign structName = varGroup.Name
    %endif
  %endif
  %return structName
%endfunction

%% Function: SLibEmitRecordInCoderDataGroupStruct() =========================================
%% Abstract:
%%  Assuming that the CGType passed in has proper type, then
%%  we should group the member associated with this type. Some types 
%%  like 'fcn_call' should not be emitted. For now this function only
%%  checks for 'fcn_call' type. It could be expanded in future.
%function SLibEmitRecordInCoderDataGroupStruct(CGTypeIdx) void
  %assign emitRec = TLC_TRUE
  %assign cgType = ::CompiledModel.CGTypes.CGType[CGTypeIdx]
  %if(ISFIELD(cgType,"Name"))
    %if cgType.Name == "fcn_call"
      %assign emitRec = TLC_FALSE
    %endif
  %endif
  %return emitRec
%endfunction

%% Function: SLibAllocatesCoderDataGroup ==========================================
%% Abstract:
%%    Return if this model allocates specific data group
%function SLibAllocatesCoderDataGroup(group) void
  %if group.ContainsInstanceSpecificParameter
    %return !IsModelReferenceTarget()
  %endif

  %if (group.AsStructure == "InParent") && (group.IsInstanceSpecific == TLC_TRUE)
    %return IsModelReferenceTarget() ? ...
      !::CompiledModel.OkToMultiInstanceModelref : !MultiInstanceERTCode
  %else
    %return TLC_TRUE
  %endif
%endfunction

%% Function: SLibAllocatesCoderDataGroups ==========================================
%% Abstract:
%%    Return if this model allocates data groups in general
%function SLibAllocatesCoderDataGroups() void
  %if IsModelReferenceTarget()
    %return !::CompiledModel.OkToMultiInstanceModelref
  %else
    %return !MultiInstanceERTCode
  %endif
%endfunction

%% Function: SLibAccessGroupThroughSelf ===================================
%% Abstract:
%%    Return true if this group is InParent or InSelf
%function SLibAccessGroupThroughSelf(group) void
  %return (group.AsStructure == "InParent") || (group.AsStructure == "InSelf")
%endfunction

%% Function: SLibDataGroupStaticInit ======================================
%% Abstract:
%%    Return true if this group is statically initialized
%function SLibDataGroupStaticInit(group) void
  %return (group.DataInit == "Static")
%endfunction

%% Function: SLibDataGroupMemorySectionConst =================================
%% Abstract:
%%    Return true if this group has a constant memory section
%function SLibDataGroupMemorySectionConst(group) void
  %return group.IsMemorySectionConst
%endfunction

%% Function: SLibSuppressRTMDeclaration ========================================
%% Abstract:
%%  Return true if the RTM declaration should be suppressed.
%%
%function SLibSuppressRTMDeclaration() void
  %assign varGroupIdx = SLibGetSelfCoderDataGroupVarGroupIndex()
  %if -1 < varGroupIdx && !SLibSynthesizedRTM()
    %return !SLibVarGroupIsStruct(varGroupIdx)
  %endif
  %return TLC_FALSE
%endfunction

%% Function: SLibNeedGroupTypesForTesting ========================================
%% Abstract:
%%  Return true the model has Imported groups and the
%%  GenerateImportedDataGroupsTypes feature is on.
%%
%function SLibNeedGroupTypesForTesting()
  %assign hasImportedGroups = TLC_FALSE
  %foreach idx = ::CompiledModel.NumCoderDataGroups
    %assign group = ::CompiledModel.CoderDataGroup[idx]
    %if SLibCoderDataGroupIsImported(group)
      %assign hasImportedGroups = TLC_TRUE
      %break
    %endif
  %endforeach
  %return hasImportedGroups && ::CompiledModel.GenerateImportedDataGroupsTypes
%endfunction


%% Function: IsFieldAndTrue_loc ========================================
%% Abstract:
%%  Returns true if a record contains a field and that field is true otherwise return false
%%
%function IsFieldAndTrue_loc(record,field) void
  %return ISFIELD(record,field) && record.%<field> == TLC_TRUE
%endfunction

%% Function: isDynamicDeclarationRequired_loc ========================================
%% Abstract:
%%  Helper function to select dynamic coder data groups to be declared within a model. This will also return true
%%  for statically initialized groups when we are externally declaring the group
%%
%function isDynamicDeclarationRequired_loc(prefix,instanceData) void
  %if SLibDataGroupStaticInit(instanceData.group)
    %return TLC_FALSE
  %else
    %assign isAllocatedInCppClass = instanceData.group.AsStructure == "InSelf" && GenerateClassInterface
    %assign AllocateGroup = SLibAllocatesCoderDataGroup(instanceData.group) || isAllocatedInCppClass
    %return AllocateGroup || (prefix == "static")
  %endif
%endfunction

%% Function: isStaticDeclarationRequired_loc ========================================
%% Abstract:
%%  Helper function to select statically initialized coder data groups to be declared within a model.
%%
%function isStaticDeclarationRequired_loc(prefix,instanceData) void
  %if !SLibDataGroupStaticInit(instanceData.group)
    %return TLC_FALSE
  %% Speical case for declare instP group even when not allocated
  %elseif (prefix == "extern") && instanceData.group.ContainsInstanceSpecificParameter
    %return TLC_TRUE
  %else
    %return SLibAllocatesCoderDataGroup(instanceData.group)
  %endif
%endfunction

%% Function: isImportExportGroupEmitted_loc ========================================
%% Abstract:
%%  Helper function to filter coder groups based on wheter they are exported or imported (needed for testing purposes)
%%
%function isImportExportGroupEmitted_loc(group,instanceFilter) void
  %if SLibCoderDataGroupIsImportedFromFile(group)
    %return IsFieldAndTrue_loc(instanceFilter,"Imported")
  %else
    %return IsFieldAndTrue_loc(instanceFilter,"Exported")
  %endif
%endfunction

%% Function: isStandaloneAccessThroughSelfGroupEmitted_loc ========================================
%% Abstract:
%%  Helper function to filter coder groups based on wheter they are standalone or accessed
%%  through self
%%
%function isStandaloneAccessThroughSelfGroupEmitted(group,instanceFilter) void
  %if group.AsStructure == "Standalone"
    %return IsFieldAndTrue_loc(instanceFilter,"Standalone")
  %else
    %return IsFieldAndTrue_loc(instanceFilter,"AccessThroughSelf")
  %endif
%endfunction

%% Function: SLibEmitStaticInitCoderDataGroup ========================================
%% Abstract:
%%  Return declaration of staticically initialized data
%%
%function SLibEmitStaticInitCoderDataGroup(system,classQualifier,prefix,parentGroup,instanceData) void
  %assign declaration = ""
  %if isStaticDeclarationRequired_loc(prefix,instanceData)
    %if prefix == "extern"
      %% Extern declaration is added after memory section to avoid compiler warnings
      %assign prefix = ""
      %assign init = ""
    %else
      %assign instanceInit = instanceData.group.AsStructure == "InSelf" ? instanceData.group.Initializer : parentGroup.Initializer
      %if ISEMPTY(instanceInit)
        %assign init = ""
      %else
      %assign init = " = " + SLibCoderDataGroupElementInit(instanceData.group, instanceInit, instanceData.idx)
    %endif
    %endif
    %openfile declaration
    %if SLibAutosarCompilerAbstractionRequired()
      %<prefix> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, instanceData.baseType, TLC_FALSE, TLC_FALSE, instanceData.identifier, "DataGlobal")>%<init>;
    %else
      %assert !WHITE_SPACE(instanceData.baseType) && !WHITE_SPACE(instanceData.identifier)
      %<prefix> %<instanceData.baseType> %<classQualifier>%<instanceData.identifier>%<init>;
    %endif
    %closefile declaration
  %endif
  %return declaration
%endfunction

%% Function: SLibEmitDynamicInitCoderDataGroup ========================================
%% Abstract:
%%  Return declaration of dynamically initialized data
%%
%function SLibEmitDynamicInitCoderDataGroup(system,classQualifier,prefix,parentGroup,instanceData) void
  %assign declaration = ""
  %if prefix == "extern"
    %% Extern declaration is added after memory section to avoid compiler warnings
    %assign prefix = ""
  %endif
  %if isDynamicDeclarationRequired_loc(prefix,instanceData)
    %openfile declaration
    %if SLibAutosarCompilerAbstractionRequired()
      %<prefix> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_FALSE, instanceData.baseType, TLC_FALSE, TLC_FALSE, instanceData.identifier, "DataGlobal")>;
    %else
      %assert (!WHITE_SPACE(instanceData.baseType) && !WHITE_SPACE(instanceData.identifier))
      %<prefix> %<instanceData.baseType> %<classQualifier>%<instanceData.identifier>;
    %endif
    %closefile declaration
  %endif
  %return declaration
%endfunction

%% Function: FcnSkipDeclareCoderDataGroupInstance_loc ======================================
%% Abstract: 
%%  Should we skip declaring an instance for this coder data group element?
%%
%function FcnSkipDeclareCoderDataGroupInstance_loc(group, varIdx)
  %assign baseType   = SLibCoderDataGroupElementBaseType(group, varIdx)
  %assign crossgroup = SLibCrossCoderDataGroupElement(group,varIdx)
  %return baseType == "fcn_call" || ...
        (!ISEMPTY(crossgroup) && SLibCoderDataGroupNumElements(crossgroup) == 0)
%endfunction
  
%% Function: SLibDeclareCoderDataGroupInstances_loc ========================================
%% Abstract:
%%  Loop through Coder Data Groups and declare data based on supplied emit functions
%%
%function SLibDeclareCoderDataGroupInstances_loc(system,prefix,emitFunctions,instanceFilter) void
  %assign returnBuffer = ""
  %assign externDecl = (prefix == "extern")
  %foreach idx = ::CompiledModel.NumCoderDataGroups
    %assign group = ::CompiledModel.CoderDataGroup[idx]
    %assign numVars = SLibCoderDataGroupNumElements(group)
    %% Prescreen data groups based on traits independent of group properties like static/dynamic init
    %if numVars == 0 || ...
      (GenerateClassInterface && group.IsInstanceSpecific && WHITE_SPACE(prefix)) || ...
      (GenerateClassInterface && !group.IsInstanceSpecific && externDecl) || ...
      group.IsOpaque || ...
      !isStandaloneAccessThroughSelfGroupEmitted(group,instanceFilter) || ...
      !isImportExportGroupEmitted_loc(group,instanceFilter) || ...
      (SLibIsGroupSelfCoderGroup(group) && IsFieldAndTrue_loc(instanceFilter,"ModelData")) || ...
      (group.AsStructure == "InSelf" && ...
      (SLibGetDoesSelfHasCoderDataGroup() || !SLibGetUseRTMcgType() && !ISEMPTY(SLibCoderDataGroupRTMFieldName(group)) && !GenerateClassInterface ))
      %continue
    %endif
    %assign emitComment = TLC_TRUE
    %assign isFirstElement = TLC_TRUE
    %assign lastElementIndex = 0
    %foreach varIdx = numVars
      %if !FcnSkipDeclareCoderDataGroupInstance_loc(group, varIdx)
        %assign lastElementIndex = varIdx
      %endif
    %endforeach
    %assign classQualifier = ""
    %if GenerateClassInterface && !group.IsInstanceSpecific
      %assign classQualifier = ::CPPClassName + "::"
    %endif  
    %foreach varIdx = numVars
      %assign declaration  = ""
      %assign declarationWithMemSection = ""
      %assign crossgroup = SLibCrossCoderDataGroupElement(group,varIdx)
      %% create closure of group instance specific data to stabalize emit function interfaces
      %createrecord instanceData { \
        idx        varIdx \
        identifier SLibCoderDataGroupElementInstance(group, varIdx) \
        baseType   SLibCoderDataGroupElementBaseType(group, varIdx) \
        sysIdx     SLibCrossSystemIdxElement(group, varIdx) \
        group      ISEMPTY(crossgroup)?group:crossgroup \
      }
      %addtorecord instanceData groupToken "CoderDataGroup"+instanceData.group.Name
      %% filter out fcn_call port types and empty coder data groups
      %if FcnSkipDeclareCoderDataGroupInstance_loc(group, varIdx)
          %continue
      %endif
      %% cycle through emit functions to get declaration
      %foreach fcnIdx = SIZE(emitFunctions,1)
        %assign tmpBuf = %<emitFunctions[fcnIdx]>(system,classQualifier,prefix,group,instanceData)
        %if !WHITE_SPACE(tmpBuf)
          %assign declaration = declaration + tmpBuf + "\n"
        %endif
      %endforeach
      %% apply memory section code to declaration
      %if !WHITE_SPACE(declaration)
        %openfile declarationWithMemSection
        %assign treatAsModelData = !(SLibIsGroupSelfCoderGroup(group) && group.AsStructure == "None" && instanceData.sysIdx != GetBaseSystemIdx())
        %assign varSys = instanceData.sysIdx > -1 ? ::CompiledModel.System[instanceData.sysIdx] : system
        %<SLibAddPreStructDeclarePragma(instanceData.identifier)>\
        %if IsModelReferenceSimTarget()
          %<prefix> %<declaration>\
        %else
          %<FcnApplyMemSecToDataDefnForGroup(declaration,instanceData.group,instanceData.identifier, varSys, ...
            treatAsModelData, externDecl,isFirstElement,(varIdx==lastElementIndex))>\
        %endif
        %<SLibAddPostStructDeclarePragma(instanceData.identifier)>\
        %closefile declarationWithMemSection
      %endif
      %% Add comment to declaration if needed
      %if !WHITE_SPACE(declarationWithMemSection)
        %% emit comment if we either are switching coder groups within the group or this is the first emitted var
        %assign comment = (emitComment || !ISEMPTY(crossgroup)) ? "/* "+instanceData.group.Identification+" */\n" : ""
        %% reset comment emission switch based on if we changed groups from the parent group
        %assign emitComment = !ISEMPTY(crossgroup)
        %assign returnBuffer = returnBuffer + comment + declarationWithMemSection
      %endif
      %assign isFirstElement = TLC_FALSE
    %endforeach /% numVars %/
  %endforeach /% ::CompiledModel.NumCoderDataGroups %/
  %return returnBuffer
%endfunction /% SLibDeclareCoderDataGroupInstances_loc %/

%% Function: SLibDeclareCoderDataGroupInstances ========================================
%% Abstract:
%%  Return declaration of both static and dynamic initialized coder data groups
%% Filter supplied can specify what type of data group
%%   - Dynamic: dyncamic initialized groups
%%   - Static: static initialized groups
%%   - Imported: imported groups not in model.h
%%   - Exported: exported groups and imported groups in model.h
%%   - Standalone: groups with AsStructure set to Standalone
%%   - AccessThroughSelf: groups with AsStructure set to InSelf or InParent
%%   - ModelData: skip model data group
%%
%function SLibDeclareCoderDataGroupInstances(system,prefix,InstanceFilter) void
  %assign idx = 0
  %assign emitFunctions = ""
  %assign comma = ""
  %if IsFieldAndTrue_loc(InstanceFilter,"Static")
    %assign emitFunctions = emitFunctions+comma+"\"SLibEmitStaticInitCoderDataGroup\""
    %assign comma = ","
  %endif
  %if IsFieldAndTrue_loc(InstanceFilter,"Dynamic")
    %assign emitFunctions = emitFunctions+comma+"\"SLibEmitDynamicInitCoderDataGroup\""
    %assign comma = ","
  %endif
  %return SLibDeclareCoderDataGroupInstances_loc(system,prefix,[%<emitFunctions>],InstanceFilter)
%endfunction

%% Function FcnWriteDataTransferHeadersandDefines =====================================
%% Abstract:
%%
%function FcnWriteDataTransferHeadersandDefines() void
  %openfile buffer
  %if (::CompiledModel.OutlineRTBFBT & 4) && !SLibIsCompactFileFormat()
    #include "%<::CompiledModel.Name>_private.h"       
  %endif
  #include "%<::CompiledModel.Name>.h"       
  %closefile buffer
  %return buffer
%endfunction


%endif%%  _DATAGROUPLIB_
