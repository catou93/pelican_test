%% ==============================================================================
%% 
%% 
%% 
%%
%% Abstract:
%%   Output file template library
%%
%% Copyright 1994-2016 The MathWorks, Inc.
%%
%selectfile NULL_FILE

%% =============================================================================
%% Public functions
%% =============================================================================

%% DocFunction{Code Configuration Functions}: LibGetNumSourceFile ===============
%% Abstract:
%%   Get the number of source files (.c and .h) that have been created.
%%
%% Call syntax:
%%   %assign numFiles = LibGetNumSourceFiles()
%%
%% Returns:
%%   Returns the number of files (Number).

%function LibGetNumSourceFiles() void
  %return LibGetNumModelFiles()
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetSourceFileTag ===============
%% Abstract:
%%   Returns <fileName>_h and <fileName>_c for header and source files,
%%   respectively where fileName is the name of the model file.
%%
%% Call syntax:
%%   %assign tag = LibGetSourceFileTag(fileIdx)
%%
%% Arguments:
%%   fileIndex (Number) - File index.
%%
%% Returns:
%%   Returns the tag (String).

%function LibGetSourceFileTag(fileIdx) void
  %return LibGetModelFileTag(fileIdx)
%endfunction

%% DocFunction{Code Configuration Functions}: LibCreateSourceFileAtPath ===============
%% Abstract:
%%   Create a new C file, and return its reference.  If the file already exists,
%%   simply return its reference.
%%
%% Call syntax:
%%   %assign fileH = LibCreateSourceFileAtPath("Source", "Custom", "../slprj/ert/_shareutils/foofile","foofile")
%%
%% Arguments:
%%   type (String):
%%     Valid values are "Source" and "Header" for .c and .h files,
%%     respectively.
%%
%%   creator (String):
%%     Who's creating the file?  An error is reported if different creators
%%     attempt to create the same file.
%%
%%   namewithpath (String):
%%     Name of the file (with the file path but without the extension).
%%
%%   basename (String):
%%     Name of the file (without the path or extension).
%%
%%   Note: For files destined to the model build dir, use the simpler
%%         LIbCreateSourceFile(type,creator,name) 
%%
%% Note: File are not written to disk if they are empty.
%%
%% Returns:
%%   Reference to the model file (Scope).
%%
%function LibCreateSourceFileAtPath(type,creator,namewithpath,basename) void
  %assign type = (type == "Source") ? "SystemBody" : "SystemHeader"
  %return SLibAddModelFileWithBasename(type,creator,namewithpath,basename)
%endfunction

%% DocFunction{Code Configuration Functions}: LibCreateSourceFile ===============
%% Abstract:
%%   Create a new C file, and return its reference.  If the file already exists,
%%   simply return its reference.
%%
%% Call syntax:
%%   %assign fileH = LibCreateSourceFile("Source", "Custom", "foofile")
%%
%% Arguments:
%%   type (String):
%%     Valid values are "Source" and "Header" for .c and .h files,
%%     respectively.
%%
%%   creator (String):
%%     Who's creating the file?  An error is reported if different creators
%%     attempt to create the same file.
%%
%%   name (String):
%%     Name of the file (without the extension).
%%
%% Note: File are not written to disk if they are empty.
%%
%% Returns:
%%   Reference to the model file (Scope).

%function LibCreateSourceFile(type,creator,name) void
  %assign type = (type == "Source") ? "SystemBody" : "SystemHeader"
  %return SLibAddModelFile(type,creator,name)
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetSourceFileFromIdx ===========
%% Abstract:
%%   Return a model file reference based on its index.  This is very useful
%%   for a common operation on all files.  For example, to set the leading file
%%   banner of all files.
%%
%% Call syntax:
%%   %assign fileH = LibGetSourceFileFromIdx(fileIdx)
%%
%% Arguments:
%%   fileIdx (Number): Index of model file (that is internally managed by Simulink Coder).
%%
%% Returns:
%%   Reference (Scope) to the model file.

%function LibGetSourceFileFromIdx(fileIdx) void
  %return ModelFiles.ModelFile[fileIdx]
%endfunction

%% DocFunction{Code Configuration Functions}: LibSetSourceFileSection ===========
%% Abstract:
%%   Add to the contents of a file.  Valid attributes include:
%%
%%   Banner            - Set the file banner (comment) at the top of the file.
%%   Includes          - Append to the #include section.
%%   Defines           - Append to the #define section.
%%   IntrinsicTypes    - Append to the intrinsic typedef section.  Intrinsic
%%                       types are those that only depend on intrinsic C types.
%%   PrimitiveTypedefs - Append to the primitive typedef section.  Primitive
%%                       typedefs are those that only depend on intrinsic C types
%%                       and any typedefs previously defined in the
%%                       IntrinsicTypes section.
%%   UserTop           - Append to the "user top" section.
%%   Typedefs          - Append to the typedef section.  Typedefs can depend on
%%                       any previously defined type.
%%   Enums             - Append to the enumerated types section.
%%   Definitions       - Append to the data definition section.
%%   ExternData        - (reserved) extern data.
%%   ExternFcns        - (reserved) extern functions.
%%   FcnPrototypes     - (reserved) function prototypes.
%%   Declarations      - Append to the data declaration section.
%%   Functions         - Append to the C functions section.
%%   CompilerErrors    - Append to the #error section.
%%   CompilerWarnings  - Append to the #warning section.
%%   Documentation     - Append to the documentation (comment) section.
%%   UserBottom        - Append to the "user bottom" section.
%%
%%  Code is emitted by Simulink Coder in the order in which it is listed
%%  above.
%%
%%  Example call syntax (iterating over all file):
%%
%%  %openfile tmpBuf
%%    whatever
%%  %closefile tmpBuf
%%
%%  %foreach fileIdx = LibGetNumSourceFiles()
%%    %assign fileH = LibGetSourceFileFromIdx(fileIdx)
%%    %<LibSetSourceFileSection(fileH,"SectionOfInterest",tmpBuf)>
%%  %endforeach
%%
%%  %assign fileH = LibCreateSourceFile("Header","Custom","foofile")
%%  %<LibSetSourceFileSection(fileH,"Defines","#define FOO 5.0\n")
%%
%%  Arguments:
%%    fileH   - Reference or index to a file (Scope or Number).
%%    section - File section of interest (String).
%%    value   - Value (String).

%function LibSetSourceFileSection(fileH, section, value) void
  %if TYPE(fileH) != "Scope"
    %if TYPE(fileH) == "Number"
      %assign fileH = ModelFiles.ModelFile[fileH]
    %else
      %assign errTxt = "LibSetSourceFileSection expects a reference or " ...
	"and index to a file.  It was passed a %<TYPE(fileH)>"
      %<LibReportError(errTxt)>
    %endif
  %endif
  %if section == "ExternData" || section == "ExternFcns" || section == "FcnPrototypes"
    %assign errTxt = "%<section> is reserved for Simulink Coder."
    %setcommandswitch "-v1"
    %<LibReportError(errTxt)>
  %endif
  %<SLibSetModelFileAttribute(fileH,section,value)>
%endfunction

%% Function: LibGetSourceFileSection ============================================
%% Abstract:
%%   Get the contents of a file.  See LibSetSourceFileSection for list of valid
%%   sections.
%%
%%  Arguments:
%%    fileIndex - Reference or index to a file (Scope or Number).
%%    section   - File section of interest (String).

%function LibGetSourceFileSection(fileIdx, section) void
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %return LibGetModelFileAttribute(fileIdx,section)
%endfunction

%% Function: LibGetSourceFileIndent ============================================
%% Abstract:
%%   Get the Indent flag of a file.
%%
%%  Arguments:
%%    fileIndex - Reference or index to a file (Scope or Number).

%function LibGetSourceFileIndent(fileIdx) void
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif

  %return SLibDirectAccessGetFileAttribute(ModelFiles.ModelFile[fileIdx], "Indent")
%endfunction

%% Function: LibGetSourceFileShared ============================================
%% Abstract:
%%   Get the Shared flag of a file. This is set for shared utility functions
%%   being generated to _sharedutils. Note shared type use a different flag
%%   (see LibGetSourceFileSharedType())
%%
%%  Arguments:
%%    fileIndex - Reference or index to a file (Scope or Number).

%function LibGetSourceFileShared(fileIdx) void
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif
  
  %return SLibDirectAccessGetFileAttribute(ModelFiles.ModelFile[fileIdx], "Shared")
%endfunction

%% Function: LibGetSourceFileSharedType ============================================
%% Abstract:
%%   Get the Shared Type flag of a file. This is set for shared types
%%   being generated to _sharedutils. Note shared type use a different flag
%%   (see LibGetSourceFileSharedType())
%%
%%  Arguments:
%%    fileIndex - Reference or index to a file (Scope or Number).

%function LibGetSourceFileSharedType(fileIdx) void
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif
  
  %return SLibDirectAccessGetFileAttribute(ModelFiles.ModelFile[fileIdx], "SharedType")  
%endfunction

%% Function: LibIndentSourceFile ================================================
%% Abstract:
%%   Indent a file with the c_beautifier utility (from within TLC environment).
%%
%% Call syntax:
%%   %<LibIndentSourceFile("foofile.c","")>
%%
%% Arguments:
%%   fileName  - Name of file (String).
%%   modelName - Name of model (String). (optional argument)
%%               

%function LibIndentSourceFile(fileName,modelName) void
  %<SLibIndentFile(fileName,modelName)>
%endfunction

%% DocFunction{Code Configuration Functions}: LibSetSourceFileCodeTemplate ======
%% Abstract:
%%   By default, *.c and *.h files are generated with the code templates
%%   specified in the GUI.  This function allows you to change the
%%   the template for a file.  Uses the "Code templates" entered into the
%%   Templates UI.
%%
%%   Note: Custom templates is a feature of Embedded Coder.
%%
%% Call syntax:
%%   %assign tag = LibSetSourceFileCodeTemplate(opFile,name)
%%
%% Arguments:
%%   opFile (Scope)  - Reference to file
%%   name   (String) - Name of the desired template
%%
%% Returns:
%%   None

%function LibSetSourceFileCodeTemplate(opFile,name) void
  %<SLibSetModelFileAttribute(opFile,"CodeTemplate",name)>
%endfunction

%% DocFunction{Code Configuration Functions}: LibSetSourceFileOutputDirectory ===
%% Abstract:
%%   By default, *.c and *.h files are generated into the build directory.
%%   This function allows you to change the default location.  Note that
%%   the caller is reponsible for specifying a valid directory.
%%
%% Call syntax:
%%   %assign tag = LibSetSourceFileOutputDirectory(opFile,dirName)
%%
%% Arguments:
%%   opFile  (Scope)  - Reference to file
%%   dirName (String) - Name of the desired output directory
%%
%% Returns:
%%   None

%function LibSetSourceFileOutputDirectory(opFile,name) void
  %<SLibSetModelFileAttribute(opFile,"OutputDirectory",name)>
%endfunction


%% DocFunction{Code Configuration Functions}: LibCallModelInitialize ============
%% Abstract:
%%   Returns necessary code for calling the model's initialize function (valid
%%   for ERT only).

%function LibCallModelInitialize() void
  %openfile tmpFcnBuf
  %<GenerateModelInitFcnName()>(%<SLibModelFcnArgs("Initialize",TLC_TRUE,"")>);
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibCallModelStep ==================
%% Abstract:
%%   Returns necessary code for calling the model's step function (valid
%%   for ERT only).

%function LibCallModelStep(tid) void
  %assign rootSystem.CurrentTID =tid 
  %openfile tmpFcnBuf
  %<FcnCallMdlStep(tid)>
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibCallModelTerminate =============
%% Abstract:
%%   Returns necessary code for calling the model's terminate function (valid
%%   for ERT only).

%function LibCallModelTerminate() void
  %openfile tmpFcnBuf
  %if IncludeMdlTerminateFcn
    %<::CompiledModel.Name>_terminate(%<SLibModelFcnArgs("Terminate",TLC_TRUE,"")>);
  %endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibCallSetEventForThisBaseStep ====
%% Abstract:
%%   Returns necessary code for calling the model's set events function (valid
%%   for ERT only).
%%
%% Args:
%%   buffername - Name of the variable used to buffer the events.  For the
%%                example ert_main.c this is "eventFlags".

%function LibCallSetEventForThisBaseStep(buffername) void
  %return EventFlagsFunction("%<::CompiledModel.Name>_", buffername)
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelData =================
%% Abstract:
%%   Returns necessary data for the model (valid for ERT only).

%function LibWriteModelData() void
  %return SLibDeclareModelFcnArgs(TLC_TRUE)
%endfunction
  
%% DocFunction{Code Configuration Functions}: LibSetRTModelErrorStatus ==========
%% Abstract:
%%   Returns the code required set the model error status
%%
%% Args:
%%   str (String) - char * to a C string
%%
%% Call syntax:
%%   %<LibSetRTModelErrorStatus("\"Overrun\"")>;

%function LibSetRTModelErrorStatus(str) void
  %return RTMSetErrStat(str)
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetRTModelErrorStatus ==========
%% Abstract:
%%   Returns the code required to get the model error status
%%
%% Call syntax:
%%   %<LibGetRTModelErrorStatus()>;

%function LibGetRTModelErrorStatus() void
  %return RTMGetErrStat()
%endfunction

%% DocFunction{Sample Time Functions}: LibIsSingleRateModel =====================
%% Abstract:
%%   Return true if model is single rate and false otherwise.

%function LibIsSingleRateModel() void
  %assign rootSystem = System[NumSystems-1]
  %return LibIsSingleRateSystem(rootSystem)
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetMdlSrcBaseName ==============
%% Abstract:
%%   Return the base name of the model's main source (e.g., model.c) file

%function LibGetMdlSrcBaseName() void
  %return ::CompiledModel.Name
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetMdlPubHdrBaseName ===========
%% Abstract:
%%   Return the base name of the model's public header (e.g., model.h) file

%function LibGetMdlPubHdrBaseName() void
  %return ::CompiledModel.Name
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetMdlPrvHdrBaseName ===========
%% Abstract:
%%   Return the base name of the model's private header (e.g., model_private.h)
%%   file

%function LibGetMdlPrvHdrBaseName() void
  %return ::CompiledModel.Name + "_private"
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetModelDotCFile ==============
%% Abstract:
%%   Get the record for the model.c file. Additional code can then be cached
%%   using LibSetSourceFileSection().
%%
%% Call syntax:
%%   %assign srcFile = LibGetModelDotCFile()
%%   %<LibSetSourceFileSection(srcFile, "Functions", mybuf)>
%% 
%% Returns:
%%   Returns the model.c source file record.

%function LibGetModelDotCFile() void
  %return LibCreateSourceFile("Source","Simulink",::CompiledModel.Name)
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetModelDotHFile ==============
%% Abstract:
%%   Get the record for the model.h file. Additional code can then be cached
%%   using LibSetSourceFileSection().
%%
%% Call syntax:
%%   %assign hdrFile = LibGetModelDotHFile()
%%   %<LibSetSourceFileSection(hdrFile, "Functions", mybuf)>
%% 
%% Returns:
%%   Returns the model.h source file record.

%function LibGetModelDotHFile() void
  %return LibCreateSourceFile("Header","Simulink",::CompiledModel.Name)
%endfunction

%% Function: LibIsSingleTasking =================================================
%% Abstract:
%%   Return true if the model is configured for singletasking execution and
%%   false otherwise (i.e., multitasking).

%function LibIsSingleTasking() void
  %return SLibSingleTasking()
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelInput ================
%% Abstract:
%%   Return the code necessary to write to a particular root input (i.e., a
%%   model inport block).   This function is valid for ERT only, and not valid 
%%   for referenced models.
%%
%% Args:
%%   tid (Number):  Task identifier (0 is fastest rate and n is the slowest)
%%   rollThreshold: Width of signal before wrapping in a for loop.

%function LibWriteModelInput(tid,rollThreshold) void
  %if IsModelReferenceTarget()
     %assign errTxt = "LibWriteModelInput may not be called for referenced " + ...
       "models; you may wish to guard its invocation with !IsModelReferenceTarget()."
     %<LibReportError(errTxt)>
  %endif
  %openfile tmpFcnBuf
  %if MultiInstanceERTCode && !RootIOStructures
    %assign localUQualifier = "_"
  %else
    %assign localUQualifier = "."
  %endif
  %foreach idx = ExternalInputs.NumExternalInputs
    %assign extInp = ::CompiledModel.ExternalInputs.ExternalInput[idx]
    %with extInp
      %if TID == tid
	%assign rhs = "your_value"
	/* InportID: %<idx>, TaskID: %<tid> */
	%assign id = LibGetRecordIdentifier(extInp)
	%assign optStr = ""
	%if StorageClass == "Auto"
	  %assign optStr = "%<LibGetExternalInputStruct()>%<localUQualifier>"
	%endif
	%if StorageClass == "ImportedExternPointer"
	  %assign id = "%<id>_value"
	%endif
	%assign portWidth = LibGetRecordWidth(extInp)
	%assign isComplex = LibGetRecordIsComplex(extInp)
	%if portWidth == 1
	  %if isComplex
	    %<optStr>%<id>.re = %<rhs>;
	    %<optStr>%<id>.im = %<rhs>;
	  %else
	    %<optStr>%<id> = %<rhs>;
	  %endif
	%elseif portWidth < rollThreshold
	  %foreach sigIdx = portWidth
	    %if isComplex
	      %<optStr>%<id>[%<sigIdx>].re = %<rhs>;
	      %<optStr>%<id>[%<sigIdx>].im = %<rhs>;
	    %else  
	      %<optStr>%<id>[%<sigIdx>] = %<rhs>;
	    %endif
	  %endforeach
	%else %% portWidth > rollThreshold
	  {
	    int i = 0;
	    for(i = 0; i < %<portWidth>; i++) {
	      %if isComplex
		%<optStr>%<id>[i].re = %<rhs>;
		%<optStr>%<id>[i].im = %<rhs>;
	      %else
		%<optStr>%<id>[i] = %<rhs>;
	      %endif
	    }
	  }
	%endif
      %endif
    %endwith %% extInp
  %endforeach
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelOutput ===============
%% Abstract:
%%   Return the code necessary to write to a particular root output (i.e., a
%%   model outport block).   This function is valid for ERT only, and not valid 
%%   for referenced models.
%%
%% Args:
%%   tid (Number):  Task identifier (0 is fastest rate and n is the slowest)
%%   rollThreshold: Width of signal before wrapping in a for loop.

%function LibWriteModelOutput(tid,rollThreshold) void
  %if IsModelReferenceTarget()
     %assign errTxt = "LibWriteModelOutput may not be called for referenced " + ...
       "models; you may wish to guard its invocation with !IsModelReferenceTarget()."
     %<LibReportError(errTxt)>
  %endif
  %openfile tmpFcnBuf
  %if MultiInstanceERTCode && !RootIOStructures
    %assign localYQualifier = "_"
  %else
    %assign localYQualifier = "."
  %endif
  %assign lhs = "your_variable"
  %foreach idx = ExternalOutputs.NumExternalOutputs
    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx       = extOut.Block[0]
    %assign blkIdx       = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %with System[sysIdx]
      %with outportBlock
	%if tid == SLibGetNumericTID(outportBlock)
	  %assign portWidth = LibBlockInputSignalWidth(0)
          %assign id = LibGetRecordIdentifier(outportBlock)
	  /* OutportID: %<idx>, TaskID: %<tid> */
	  %if portWidth == 1
	    %if SLibExternalOutputIsVirtual(outportBlock)
	      %<lhs> = %<LibBlockInputSignal(0, "", "", 0)>;
	    %else
	      %<lhs> = %<LibGetExternalOutputStruct()>%<localYQualifier>%<id>;
	    %endif
	  %elseif portWidth < rollThreshold
	    %foreach sigIdx = portWidth
	      %if SLibExternalOutputIsVirtual(outportBlock)
		%<lhs> = %<LibBlockInputSignal(0, "", "", sigIdx)>;
	      %else
		%<lhs> = %<LibGetExternalOutputStruct()>%<localYQualifier>%<id>[%<sigIdx>];
	      %endif
	    %endforeach
	  %else %% portWidth > rollThreshold
	    {
	      int i = 0;
	      for(i = 0; i < %<portWidth>; i++) {
		%if SLibExternalOutputIsVirtual(outportBlock)
		  %<lhs>[i] = %<LibBlockInputSignal(0, "i", "", 0)>;
		%else
		  %<lhs>[i] = %<LibGetExternalOutputStruct()>%<localYQualifier>%<id>[i];
		%endif
	      }
	    }
	  %endif
	%endif
      %endwith %% outportBlock
    %endwith %% System[sysIdx]
  %endforeach
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelInputs ===============
%% Abstract:
%%   Return the code necessary to write to root inputs (i.e., all the
%%   model inport blocks).  This function is valid for ERT only, and not valid 
%%   for referenced models.

%function LibWriteModelInputs() void
  %if IsModelReferenceTarget()
     %assign errTxt = "LibWriteModelInputs may not be called for referenced " + ...
       "models; you may wish to guard its invocation with !IsModelReferenceTarget()."
     %<LibReportError(errTxt)>
  %endif
  %openfile varbufs
  %foreach tid = LibNumSynchronousSampleTimes()
    %<LibWriteModelInput(tid,RollThreshold)>\
  %endforeach
  %closefile varbufs
  
  %if WHITE_SPACE(varbufs)
    %return ""
  %else
    %openfile tmpFcnBuf
    #if 0
    %<varbufs>\
    #endif
    %closefile tmpFcnBuf
    %return tmpFcnBuf
  %endif
%endfunction

%% DocFunction{Code Configuration Functions}: LibWriteModelOutputs ==============
%% Abstract:
%%   Return the code necessary to write to root outputs (i.e., all the
%%   model outport blocks).   This function is valid for ERT only, and not valid 
%%   for referenced models.

%function LibWriteModelOutputs() void
  %if IsModelReferenceTarget()
     %assign errTxt = "LibWriteModelOutputs may not be called for referenced " + ...
       "models; you may wish to guard its invocation with !IsModelReferenceTarget()."
     %<LibReportError(errTxt)>
  %endif
  %openfile varbufs
  %foreach tid = LibNumSynchronousSampleTimes()
    %<LibWriteModelOutput(tid,RollThreshold)>\
  %endforeach
  %closefile varbufs
  
  %if WHITE_SPACE(varbufs)
    %return ""
  %else
    %openfile tmpFcnBuf
    #if 0
    %<varbufs>\
    #endif
    %closefile tmpFcnBuf
    %return tmpFcnBuf
  %endif
%endfunction

%% DocFunction{Sample Time Functions}: LibNumDiscreteSampleTimes ================
%% Abstract:
%%   Return the number of discrete sample times in the model

%function LibNumDiscreteSampleTimes() void
  %return ::CompiledModel.NumSynchronousSampleTimes - LibIsContinuous(0)
%endfunction            

%function LibGetTID01EQ() void
  %return ::CompiledModel.FixedStepOpts.TID01EQ
%endfunction

%function LibGetSampleTimePeriodAndOffset(tid, idx) void
  %return ::CompiledModel.SampleTime[tid].PeriodAndOffset[idx]
%endfunction


%% DocFunction{Sample Time Functions}: LibNumSynchronousSampleTimes ================
%% Abstract:
%%   Return the number of synchronous sample times in the model

%function LibNumSynchronousSampleTimes() void
  %return ::CompiledModel.NumSynchronousSampleTimes
%endfunction

%% DocFunction{Sample Time Functions}: LibNumAsynchronousSampleTimes ============
%% Abstract:
%%   Return the number of asynchronous sample times in the model

%function LibNumAsynchronousSampleTimes() void
  %return ::CompiledModel.NumAsynchronousSampleTimes
%endfunction

%% DocFunction{Code Configuration Functions}: LibAddSourceFileCustomSection =====
%% Abstract:
%%   Add a custom section to a source file.  You must associate a custom
%%   section with one of the built-in sections: Includes, Defines, Types,
%%   Enums, Definitions, Declarations, Functions, or Documentation.
%%
%%   No action if the section already exists, except to report an error
%%   if a inconsistent built-in section association is attempted.
%%
%%   Only available with Embedded Coder.
%%
%% Arguments:
%%   file           - Source file reference (Scope)
%%   builtInSection - Name of the associated built-in section (String)
%%   newSection     - Name of the new (custom) section (String)

%function LibAddSourceFileCustomSection(file,builtInSection,newSection) void

  %if !SLibIsERTTarget()
    %assign errTxt = "LibAddSourceFileCustomSection is only available with " ...
      "ERT-based (Embedded Coder) targets."
    %<LibReportError(errTxt)>
  %endif

  %<ADD_CUSTOM_SECTION(file.Index, builtInSection, newSection)>
%endfunction

%% DocFunction{Code Configuration Functions}: LibIsSourceFileCustomSection =====
%% Abstract:
%%   Returns whether a section is a custom section in the specified file.
%%
%%   Only available with Embedded Coder.
%%
%% Arguments:
%%   file           - Source file reference (Scope)
%%   sectionName    - Name of the (custom) section (String)
%function LibIsSourceFileCustomSection(file, sectionName) void
  %return IS_CUSTOM_SECTION(file.Index, sectionName)
%endfunction


%% DocFunction{Code Configuration Functions}: LibSetSourceFileCustomSection =====
%% Abstract:
%%   Set a custom section previously created with LibAddSourceFileCustomSection.
%%
%%   Only available with Embedded Coder.
%%
%% Arguments:
%%   file   - Source file reference or index  (Scope or Number)
%%   attrib - Name of custom section          (String)
%%   value  - value to be appended to section (String)

%function LibSetSourceFileCustomSection(file,attrib,value) void
  %if TYPE(file) != "Scope"
    %if TYPE(file) == "Number"
      %assign file = ModelFiles.ModelFile[file]
    %else
      %assign errTxt = "LibSetSourceFileCustomSection expect a " ...
	"reference or an index to a file.  It was passed a: " ...
	"%<TYPE(file)>"
      %<LibReportError(errTxt)>
    %endif
  %endif

  %if ISEMPTY(value)
    %assign value = ""
  %endif
  %<ADD_CUSTOM_SECTION_CONTENT(file.Index, attrib, value)>
%endfunction

%% DocFunction{Code Configuration Functions}: LibGetSourceFileCustomSection =====
%% Abstract:
%%   Get a custom section previously created with LibAddSourceFileCustomSection.
%%
%% Arguments:
%%   file   - Source file reference or index (Scope or Number)
%%   attrib - Name of custom section         (String)

%function LibGetSourceFileCustomSection(file,attrib) void
  %if TYPE(file) != "Scope"
    %if TYPE(file) == "Number"
      %assign file = ModelFiles.ModelFile[file]
    %else
      %assign errTxt = "LibGetSourceFileCustomSection expect a " ...
	"reference or an index to a file.  It was passed a: " ...
	"%<TYPE(file)>"
    %endif
  %endif

  %assign retVal = GET_CUSTOM_SECTION_CONTENT(file.Index, attrib)
  %return retVal
%endfunction

%% =============================================================================
%% Add ModelFiles to ::CompiledModel
%% =============================================================================

%with ::CompiledModel
  %addtorecord ::CompiledModel \
  ModelFiles {               \
    NumModelFiles    0       \
    NumSupportFiles  0       \
    ComplianceLevel -1       \
  }
%endwith %% ::CompiledModel


%% =============================================================================
%% Private functions (MathWorks use only)
%% =============================================================================

%function SLibGetTag(type, name) void

  %% In case name contains . and other funny char
  %assign name = LibConvertNameToIdentifier(name)

  %switch type
    %case "SystemHeader"
      %assign tag = "%<name>_h"
      %break
    %case "SystemBody"
      %assign tag = "%<name>_c"
      %break
    %default
      %assign errTxt = "unknown type: %<type>"
      %<LibReportFatalError(errTxt)>
  %endswitch
  %return tag
%endfunction

%function SLibSectionIsInFileContents(fileRec, sectionName) void
  %switch sectionName
    %case "Banner"
    %case "Includes"
    %case "ModelTypesIncludes"
    %case "ModelTypesDefines"
    %case "Defines"
    %case "ModelTypesTypedefs"
    %case "IntrinsicTypes"
    %case "PrimitiveTypedefs"
    %case "UserTop"
    %case "Typedefs"
    %case "Enums"
    %case "Definitions"
    %case "ExternData"
    %case "ExternFcns"
    %case "FcnPrototypes"
    %case "Declarations"
    %case "Functions"
    %case "CompilerErrors"
    %case "CompilerWarnings"
    %case "Documentation"
    %case "UserBottom"
      %return TLC_TRUE
    %default
      %return TLC_FALSE
  %endswitch
%endfunction
  
%% Function: SLibSetSourceFileCustomTokenInUse =================================
%% Abstract:
%%   The rtw_expand_template script identifies and set customs tokens with
%%   this function.  This allows custom sections to be placed in the
%%   appropriate section when a token is missing.
%%
%function SLibSetSourceFileCustomTokenInUse(fileIdx,token) void
  %<SET_CUSTOM_SECTION_TOKEN_IN_USE(fileIdx, token)>
%endfunction

%% Function: LibGetFileRecordName =================================
%% Abstract:
%%   This function takes a model file record and returns the file name
%%   (including path) without the file extension. To retrieve the file name
%%   with file extension (including path), call LibGetModelFileAttribute and
%%   pass in "Name" as the file attribute.
%% 
%function LibGetFileRecordName(fileRec) void
  %return GET_FILE_ATTRIBUTE(fileRec.Index, "NameWithoutExtension")
%endfunction

%% Function: FcnAppendMissingTokens ============================================
%% Abstract:
%%   Since custom sections can be added without a corresponding token in
%%   the code template file, we need to gracefully accomodate missing tokens.
%%   If the custom token is missing, it's placed just below it's registered
%%   built-in section.
%%
%function FcnAppendMissingTokens(opFile,section) void
  %<APPEND_MISSING_TOKENS(opFile.Index, section)>
%endfunction


%% Check if model file exists
%function SLibDoesModelFileExist(type,name) void
  %assign fullName = SLibGetFullFileName(name, type)
  %assign fileIdx = SOURCE_FILE_EXISTS(fullName)
  %if fileIdx >= 0
    %assign mf = ModelFiles.ModelFile[fileIdx]
    %return mf
  %else
    %return ""
  %endif
%endfunction

%% Check if the file is an Imported shared type file
%function SLibFileIsImportedAndShared(fileIdx) void
  %assign filter  = LibGetModelFileAttribute(fileIdx,"Filter")
  %assign isSharedType = LibGetSourceFileSharedType(fileIdx)
  %assign isImportedSharedTypeFile = filter && isSharedType
  %return isImportedSharedTypeFile
%endfunction

%% Function SLibAddGeneratedFileToList ===================================
%% Abstract:
%%   Adds specified file to TLC global variable GeneratedFileList
%%
%function SLibAddGeneratedFileToList(filename, category, type, dir) void
  %assign errTxt = FEVAL("coder.internal.slcoderReport", "addFileInfo", ...
    LibGetModelName(), filename, category, type, dir)
%endfunction %%SLibAddGeneratedFileToList

  
%% Function: SLibAddModelFile =========================================== 
%% Create a new model file, or return its existing reference.
%%
%% "type" is the type of file, e.g. "SystemBody" (.c file) or "SystemHeader" (.h file)
%% "creator" is typically "Simulink".
%% "name" is the base name of the file if writing to the build directory,
%%        and is the full path if writing to some other directory (e.g. _sharedutils)
%% 
%% For example: Building model "foo" to build directory ./foo_ert_rtw/ .
%%              If creating source file "foo.h" to build directory, then:
%%                type="SystemHeader", creator="Simulink", 
%%                name="foo", basename="foo".
%%              If creating shared type "a.h" in the shared utilities dir:
%%                type="SystemHeader", creator="Simulink", 
%%                name="<fullpathto>/_sharedutils/a", basename="a"
%%
%function SLibAddModelFile(type, creator, name) void
  %return SLibAddModelFileWithBasename(type, creator, name, name)
%endfunction

%function SLibGetFullFileName(name, type)
  %assign headerExt = ".h"
  %assign sourceExt = "." + ::LangFileExt
  %assign extension = type == "SystemHeader" ? headerExt : sourceExt
  %return "%<name>%<extension>"
%endfunction

%% Function: SLibSynchronizeFileRepWithFileRecords
%%
%% This function synchronizes the model file records inside CompiledModel
%% with the records inside the file repository. This needs to be called
%% at the beginning of TLC and after any additional files are added to
%% the file repository outside of TLC.
%function SLibSynchronizeFileRepWithFileRecords() void
  
  %assign numFileRecords = ::CompiledModel.ModelFiles.NumModelFiles
  
  %% Iterate over each file in the repository. Add file records for
  %% additional files
  %foreach fileIdx = LibGetNumSourceFiles()
    %if fileIdx >= numFileRecords
      %addtorecord ::CompiledModel.ModelFiles   \
        ModelFile {                             \
        Index                  fileIdx          \
      }
      %assign ::CompiledModel.ModelFiles.NumModelFiles = ::CompiledModel.ModelFiles.NumModelFiles + 1

      %assign type = GET_FILE_ATTRIBUTE(fileIdx, "Type")
      %% Include the code template from "rtw_code.tlc" (or custom template)
      %if ERTCustomFileBanners
        %assign template = (type == "SystemBody") ? ...
          ERTSrcFileBannerTemplate : ERTHdrFileBannerTemplate
      %else
        %assign template = "rtw_code.tlc"
      %endif

      %assign success = SET_FILE_ATTRIBUTE(fileIdx, "CodeTemplate", template)
    %endif
  %endforeach
%endfunction

%% Function: SLibAssignCustomCodeTemplates
%% Iterate over each file in DataObjectUsage Vector and check if they are
%% custom. For custom files, retrieve the fileIdx and set the CodeTemplate
%% object appropriately 
%function SLibAssignCustomCodeTemplates() void
  %if LibGetNumSourceFiles() > 0 && ISFIELD(::CompiledModel,"DataObjectUsage")
    %foreach fileIdx = ::CompiledModel.DataObjectUsage.NumFiles[0]
        %assign dataObjectFileRec = ::CompiledModel.DataObjectUsage.File[fileIdx]
        %if dataObjectFileRec.IsCustom == "yes"
            %assign type = dataObjectFileRec.Type
            %if type == "header"
              %assign type = "SystemHeader"
            %elseif type == "source"
              %assign type = "SystemBody"
            %endif

            %assign modelFile = SLibDoesModelFileExist(type, dataObjectFileRec.Name)
            %if !ISEMPTY(modelFile) && !WHITE_SPACE(modelFile)
                %if dataObjectFileRec.Type == "header"
                    %<LibSetSourceFileCodeTemplate(modelFile, ERTDataHdrFileTemplate)>
                %else 
                    %<LibSetSourceFileCodeTemplate(modelFile, ERTDataSrcFileTemplate)>
                %endif
            %endif
        %endif
    %endforeach
  %endif
%endfunction

%function FcnReturnExistingFile(fileIndex, type, creator, name) void
  %assign mf = ::CompiledModel.ModelFiles.ModelFile[fileIndex]
  %assign existingCreator = SLibDirectAccessGetFileAttribute(mf, "Creator")
  %assign existingGroup = SLibDirectAccessGetFileAttribute(mf, "Group")
  %assign existingType = SLibDirectAccessGetFileAttribute(mf, "Type")
    
  %if creator != existingCreator
    %if type == "SystemHeader" && existingGroup == "utility" && existingType == "SystemHeader"
      %<SLibReportErrorWithIdAndArgs("RTW:tlc:ErrWhenGenSharedDataConflictModelFile", "%<name>"+".h")> 
    %else
      %assign errTxt = "%<creator> is attempting to create " ...
        "file %<name>, however, this file was already created " ...
        "by %<existingCreator>."
      %<LibReportFatalError(errTxt)>
    %endif
  %else
    %return mf
  %endif
%endfunction

%% Function: SLibAddModelFileWithBasename =========================================== 
%% Create a new model file, or return its existing reference.
%%
%% "type" is the type of file, e.g. "SystemBody" (.c file) or "SystemHeader" (.h file)
%% "creator" is typically "Simulink".
%% "name" is the base name of the file if writing to the build directory,
%%        and is the full path if writing to some other directory (e.g. _sharedutils)
%% 'basename' is always the base name of the file
%% 
%% For example: Building model "foo" to build directory ./foo_ert_rtw/ .
%%              If creating source file "foo.h" to build directory, then:
%%                type="SystemHeader", creator="Simulink", 
%%                name="foo", basename="foo".
%%              If creating shared type "a.h" in the shared utilities dir:
%%                type="SystemHeader", creator="Simulink", 
%%                name="<fullpathto>/_sharedutils/a", basename="a"
%%
%function SLibAddModelFileWithBasename(type, creator, name, basename) void

  %% Include the code template from "rtw_code.tlc" (or custom template)
  %if ERTCustomFileBanners
    %assign template = (type == "SystemBody") ? ...
      ERTSrcFileBannerTemplate : ERTHdrFileBannerTemplate
  %else
    %assign template = "rtw_code.tlc"
  %endif
 
  %assign fullName = SLibGetFullFileName(name, type)

  %assign findIdx = SOURCE_FILE_EXISTS(fullName)
  %if findIdx != -1
    %return FcnReturnExistingFile(findIdx, type, creator, name)
  %endif
    
  %% This creates a new file in the file repository
  %assign fileIdx = CREATE_SOURCE_FILE(fullName)
  %% Now, set the template, type and creator attributes
  %assign success = SET_FILE_ATTRIBUTE(fileIdx, "Type", type)
  %assign success = SET_FILE_ATTRIBUTE(fileIdx, "Creator", creator)
  %assign success = SET_FILE_ATTRIBUTE(fileIdx, "CodeTemplate", template)

  %% If the user has specified a different base name, then use that
  %if name != basename
    %assign success = SET_FILE_ATTRIBUTE(fileIdx, "BaseName", basename)
  %endif

  %% For backwards compatibility, create a file record that just uses the
  %% index. Operations will retrieve this record, and the use the index to
  %% access the file repository
  %addtorecord ::CompiledModel.ModelFiles   \
    ModelFile {                             \
    Index                  fileIdx          \
  }

  %assign ::CompiledModel.ModelFiles.NumModelFiles = ModelFiles.NumModelFiles + 1
  %return ModelFiles.ModelFile[fileIdx]
%endfunction

%% Function: SLibSetContentAttribute ========================================
%% Abstract: 
%%   Adds to the Contents field of a file
%%
%% Arguments:
%%   opFile - the file we are adding to (see ::CompiledModel.ModelFiles structure above)
%%   c - specifies the Contents section <opFile>.Contents
%%   attrib - the subfield of the Contents to add to, e.g. Includes or Typedefs or ...
%%   value - the text to add

%function SLibSetContentsAttribute(opFile, c, attrib, value) void
  %if !WHITE_SPACE(value)
    %assign success = SET_FILE_ATTRIBUTE(opFile.Index, attrib, value)
  %endif
%endfunction

%% Function: SLibDirectAccessGetFileAttribute ========================================
%% Abstract: 
%%   Returns the specified attribute of a file directly. This differs from 
%%   LibGetModelFileAttribute in that LibGetModelFileAttribute may format the data
%%   returned, while this function returns the raw value of the attribute.
%%
%% Arguments:
%%   file - the file we are accessing
%%   attrib - the attribute name (e.g. WrittenToDisk, RequiredIncludes)
%function SLibDirectAccessGetFileAttribute(file, attrib) void
  %return GET_FILE_ATTRIBUTE(file.Index, attrib)
%endfunction

%% Function: SLibDirectAccessSetFileAttribute ========================================
%% Abstract: 
%%   Sets specified attribute of a file directly. This differs from 
%%   SLibSetModelFileAttribute in that SLibSetModelFileAttribute may format the data
%%   before setting the attribute, while this function sets the raw value of the attribute.
%%
%% Arguments:
%%   file - the file we are accessing
%%   attrib - the attribute name (e.g. WrittenToDisk, RequiredIncludes)
%%   value - the attribute value
%function SLibDirectAccessSetFileAttribute(file, attrib, value) void
  %assign success = SET_FILE_ATTRIBUTE(file.Index, attrib, value)
%endfunction

%% Function: SLibDirectAccessGetFileContent ========================================
%% Abstract: 
%%   Returns the specified content of a file directly. This differs from 
%%   LibGetModelFileAttribute in that LibGetModelFileAttribute may format the data
%%   returned, while this function returns the raw value of the content.
%%
%% Arguments:
%%   file - the file we are accessing
%%   attrib - the content section name (e.g. Includes, Functions)
%function SLibDirectAccessGetFileContent(file, attrib) void
  %return GET_FILE_ATTRIBUTE(file.Index, attrib)
%endfunction

%% Function: SLibDirectAccessSetFileContent ========================================
%% Abstract: 
%%   Sets specified contents section of a file directly. This differs from 
%%   SLibSetModelFileAttribute in that SLibSetModelFileAttribute may format the data
%%   before setting the content, while this function sets the raw value of the content.
%%
%% Arguments:
%%   file - the file we are accessing
%%   attrib - the content section name (e.g. Includes, Functions)
%%   value - the content value
%function SLibDirectAccessSetFileContent(file, attrib, value) void
  %assign success = SET_FILE_ATTRIBUTE(file.Index, attrib, value)
%endfunction

%% This utility function appends additional files to RequiredIncludes
%function FcnAddCoderTypesFilesToRequiredIncludes(opFile) void
  %if SLibGetModelFileDeferredIncludeCoderTypes(opFile)
    %if LibGetModelFileAttribute(opFile.Index, "Group") == "utility"
      %assign files = []
      %assign files = files + SLibCoderTypesFilename()
      %assign rtwCtx = ::CompiledModel.RTWContext
      %assign fileBaseName = SLibDirectAccessGetFileAttribute(opFile, "BaseName")

      %assign isMultiword = SLibIsHostBasedSimulationTarget() ? ...
        TLC_TRUE : ...
        FEVAL("rtwprivate", "retrieveMultiWordUtilitiesAndFunctions", "%<LocalSharedCodeManagerFile>", rtwCtx, fileBaseName)
      %if isMultiword
        %assign files = files + SLibCoderMultiwordTypesFilename()
      %endif
    %else
      %assign files = SLibUsedCoderTypesFilenames()
    %endif
    %foreach fIdx = SIZE(files, 1)
      %<SLibSetModelFileAttribute(opFile, "RequiredIncludes", files[fIdx])>          
    %endforeach
  %endif
%endfunction

%function LibWriteFileSectionToDisk(fileIndex, attrib) Output
  %assign opFile = ModelFiles.ModelFile[fileIndex]
  %if attrib == "Includes"
    %<FcnAddCoderTypesFilesToRequiredIncludes(opFile)>
  %endif

  %<WRITE_FILE_SECTION(fileIndex, attrib)>
%endfunction

%function LibClearFileSectionContents(fileIndex,attrib) void
  %if TYPE(fileIndex) != "Number"
    %if TYPE(fileIndex) == "Scope"
      %assign fileIndex = fileIndex.Index
    %else
      %assign errTxt = "LibClearFileSectionContents expects an index or a" ...
        " reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif
  %<CLEAR_FILE_SECTION(fileIndex,attrib)>
%endfunction

%% Function: SLibSetModelFileAttribute ========================================
%% Abstract: 
%%   Adds to either the file Contents or to some other top-level section
%%   of the file (e.g. RequiredIncludes)
%%
%% Arguments:
%%   opFile - the file we are adding to (see ::CompiledModel.ModelFiles structure above)
%%   attrib - can specify a top-level section (field name) of the file to add to
%%            (e.g. RequiredIncludes), or can specify a sub-section (field name) of
%%            Contents (e.g. Includes or Typedefs or ...).
%%   value - the text to add
%function SLibSetModelFileAttribute(opFile,attrib,value) void
  %% After LibClearModelFileBuffers() is called, Contents will not
  %% exist. However, still allow access to SystemsInFile,
  %% RequiredIncludes, NeedsModelHeader.
  %assign c = ""
  %if attrib == "Filter"
    %assert (value == 1)
  %elseif attrib == "WrittenToDisk"
    %assert (value == TLC_TRUE)
  %endif 

  %assign success = SET_FILE_ATTRIBUTE(opFile.Index, attrib, value)
%endfunction


%% Function: SLibSetModelFileAttributeWithRequiredInclude ==================================
%% Abstract: 
%%   Like SLibSetModelFileAttribute, but this version also adds a specified include
%%   (currently always "rtwtypes.h") to the RequiredIncludes section
%%
%% Arguments:
%%   opFile - the file we are adding to (see ::CompiledModel.ModelFiles structure above)
%%   attrib - can specify a top-level section (field name) of the file to add to
%%            (e.g. RequiredIncludes), or can specify a sub-section (field name) of
%%            Contents (e.g. Includes or Typedefs or ...).
%%   value - the text to add
%%   incl - the include to add to RequiredIncludes. The caller should just
%%          pass the include file name, e.g. "rtwtypes.h", and later on the
%%          emitting code will wrap that in an include directive
%%          to turn it into: #include "rtwtypes.h"

%function SLibSetModelFileAttributeWithRequiredInclude(opFile,attrib,value,incl) void
  %% Call the underlying function twice, first to add to the RequiredIncludes,
  %% then to add to the given section. But note we're careful not to add the
  %% RequiredIncludes if we're not actually adding anything (i.e. if value is empty).
  %% 
  %if !WHITE_SPACE(value) && !WHITE_SPACE(incl)
    %<SLibSetModelFileAttribute(opFile, "RequiredIncludes", incl)>  
  %endif
  %<SLibSetModelFileAttribute(opFile, attrib, value)>  
%endfunction


%function SLibGetModelFileIndent(opFile) void
  %return SLibDirectAccessGetFileAttribute(opFile, "Indent")
%endfunction

%function SLibSetModelFileIndent(opFile, setting) void
  %<SLibDirectAccessSetFileAttribute(opFile, "Indent", setting)>
%endfunction

%function SLibGetModelFileShared(opFile) void
  %return SLibDirectAccessGetFileAttribute(opFile, "Shared")
%endfunction

%function SLibSetModelFileShared(opFile, setting) void
  %<SLibDirectAccessSetFileAttribute(opFile, "Shared", setting)>
%endfunction

%function SLibGetModelFileSharedType(opFile) void
  %return SLibDirectAccessGetFileAttribute(opFile, "SharedType")
%endfunction

%function SLibSetModelFileSharedType(opFile, setting) void
  %<SLibDirectAccessSetFileAttribute(opFile, "SharedType", setting)>  
%endfunction

%function SLibGetModelFileDeferredIncludeCoderTypes(opFile) void
  %return SLibDirectAccessGetFileAttribute(opFile, "DeferredIncludeCoderTypes")
%endfunction
  
%function SLibSetModelFileDeferredIncludeCoderTypes(opFile, setting) void
  %<SLibDirectAccessSetFileAttribute(opFile, "DeferredIncludeCoderTypes", setting)>  
%endfunction
  
%function SLibGetModelFileIsEmpty(opFile) void
  %return SLibDirectAccessGetFileAttribute(opFile, "IsEmpty")
%endfunction

%% Function: LibGetNumModelFiles ================================================
%% Abstract:
%%   Get the number of generated files.
%%
%function LibGetNumModelFiles() void
  %return NUM_SOURCE_FILES()
%endfunction


%% Function: LibGetModelFileTag =================================================
%% Abstract:
%%   Returns <fileName>_h and <fileName>_c for header and source files,
%%   respectively where fileName is the name of the model file.
%%   This is useful for creating a header file multiple inclusion guaurd.  For example,
%%     __RTW_GENERATED_HEADER_FILE_%<LibGetModelFileTag()>__
%%
%function LibGetModelFileTag(fileIdx) void
  %assign mf = ModelFiles.ModelFile[fileIdx]
  %assign baseName = SLibDirectAccessGetFileAttribute(mf, "BaseName")
  %assign fileType = SLibDirectAccessGetFileAttribute(mf, "Type")

  %assign ext  = fileType == "SystemBody" ? "_c" : "_h"
  %return "%<baseName>%<ext>"
%endfunction


%% Function: LibGetModelFileNeedHeaderGuard ====================================
%% Abstract:
%%   Return true if a header file guard is required, and false otherwise.
%%
%function LibGetModelFileNeedHeaderGuard(fileIdx) void
  %assign opFile = LibGetSourceFileFromIdx(fileIdx)
  %if LibGetModelFileAttribute(fileIdx,"Type") != "SystemHeader"
    %return 0
  %elseif LibGetSourceFileShared(fileIdx)
    %% Shared utility functions put out their own guard (in cache_sharedutils_lib.tlc)
    %% so return false here.
    %return 0
  %else
    %assign coderTypesFiles = SLibPotentialCoderTypesBaseNames()
    %assign nameForCompare = LibGetFileRecordName(opFile)

    %foreach fIdx = SIZE(coderTypesFiles, 1)
      %assign coderTypesFile = coderTypesFiles[fIdx]
      %if nameForCompare == coderTypesFile
        %return 0
      %endif
    %endforeach
  %endif
  %if CodeFormat == "S-Function"
    %assign tag = LibGetModelFileTag(fileIdx)
    %assign mdlName = LibGetModelName()
    %return tag != "%<mdlName>_mid_h" && tag != "%<mdlName>_sid_h"
  %else
    %return 1
  %endif
%endfunction

%% Function: LibGetSourceFileAttribute ====================================
%% Abstract:
%%   Gets a specified attribute of a file.
%%   Valid attributes are:
%%     Name (with file extension)
%%     BaseName
%%     Type
%%     Creator
%%     SystemsInFile
%%     RequiredIncludes
%%     UtilityIncludes
%%     Filter
%%     IsEmpty
%%     Indent
%%     WrittenToDisk
%%     Shared
%%     SharedType
%%     CodeTemplate
%%     OutputDirectory
%%     Group
%%
%% Arguments:
%%   fileIdx - file index
%%   attrib - A model attribute name
%function LibGetSourceFileAttribute(fileIdx, attrib)
  %if TYPE(fileIdx) != "Number"
    %if TYPE(fileIdx) == "Scope"
      %assign fileIdx = fileIdx.Index
    %else
      %assign errTxt = "LibGetSourceFileSection expects an index or a " ...
	"reference to a file."
      %<LibReportError(errTxt)>
    %endif
  %endif

  %switch attrib
    %case "Name" 
    %case "BaseName" 
    %case "Type"
    %case "Creator"
    %case "Filter"
    %case "IsEmpty"
    %case "OutputDirectory"
    %case "Group"
    %case "WrittenToDisk"
    %case "CodeTemplate"
      %return LibGetModelFileAttribute(fileIdx,attrib)
    %case "SystemsInFile"
    %case "RequiredIncludes"
    %case "UtilityIncludes"
    %case "Indent"
    %case "Shared"
    %case "SharedType"
      %assign opFile = ModelFiles.ModelFile[fileIdx]
      %return SLibDirectAccessGetFileAttribute(opFile, attrib)
    %default
      %assign errTxt = "Unknown file attribute: %<attrib>"
      %<LibReportFatalError(errTxt)>
  %endswitch
%endfunction

%% Function: LibGetModelFileAttribute ===========================================
%% Abstract:
%%   (MathWorks internal function.  External users, use LibGetSourceFileSection
%%   or LibGetSourceFileAttribute instead.)
%%   Gets a specified section of a file.
%%
%% Arguments:
%%   fileIdx - file index
%%   attrib - either a top-level field name or a sub-field of Contents

%function LibGetModelFileAttribute(fileIdx, attrib) void
  
  %assign opFile = ModelFiles.ModelFile[fileIdx]

  %% After LibClearModelFileBuffers() is called, Contents will not
  %% exist. However, still allow access to Name, BaseName, Type and Creator.
  %if ISFIELD(opFile,"Contents")
    %assign c = opFile.Contents
  %endif

  %switch attrib
    %case "Name" 
      %return GET_FILE_ATTRIBUTE(opFile.Index, attrib)
    %case "BaseName" 
      %assign baseName = GET_FILE_ATTRIBUTE(opFile.Index, "BaseName")
      %assign type = GET_FILE_ATTRIBUTE(opFile.Index, "Type")
      %return SLibGetFullFileName(baseName, type)
    %case "Type"
    %case "Creator"
    %case "Filter"
    %case "IsEmpty"
    %case "OutputDirectory"
    %case "Group"
    %case "WrittenToDisk"
    %case "CodeTemplate"
      %return SLibDirectAccessGetFileAttribute(opFile, attrib)
    %case "Banner"
      %return SLibDirectAccessGetFileContent(opFile, attrib)
    %case "Includes"
      %% This prepends the RequiredIncludes to the Includes, 
      %% but otherwise goes through the same steps as the
      %% the other fields of Contents (below)
      %<FcnAppendMissingTokens(opFile,attrib)> %% inserts from CustomContents if needed
      %% Roll together the RequiredIncludes, if any.
      %% Note what we have in the array is just the include filenames,
      %% so the code below wraps these in an "#include \"<filename>\"" directive.
      %assign includesContent = SLibDirectAccessGetFileContent(opFile, attrib)
      %<FcnAddCoderTypesFilesToRequiredIncludes(opFile)>

      %assign retValue = ""
      %assign retValue = GET_FILE_ATTRIBUTE(opFile.Index, attrib)
      %return retValue
    %case "Defines"
    %case "IntrinsicTypes"
    %case "PrimitiveTypedefs"
    %case "UserTop"
    %case "Typedefs"
    %case "Enums"
    %case "Definitions"
    %case "ExternData"
    %case "ExternFcns"
    %case "FcnPrototypes"
    %case "Declarations"
    %case "Functions"
    %case "CompilerErrors"
    %case "CompilerWarnings"
    %case "Documentation"
    %case "UserBottom"
    %case "ModelTypesIncludes"
    %case "ModelTypesDefines"
    %case "ModelTypesTypedefs"
      %% This inserts from the CustomContents section, if needed
      %<FcnAppendMissingTokens(opFile,attrib)>
      %assign content = GET_FILE_ATTRIBUTE(opFile.Index, attrib)
      %if !WHITE_SPACE(content)
	    %return "\n" + content
      %else
	    %return ""
      %endif
    %default
      %assign errTxt = "Unknown file attribute: %<attrib>"
      %<LibReportFatalError(errTxt)>
  %endswitch
%endfunction  %% LibGetModelFileAttribute

%% Function: LibClearModelFileBuffers ==========================================
%% Abstract:
%%   Clear the variables associated with Model File contents.
%%
%function LibClearModelFileBuffers() void
  %if ResetTLCGlobalsAfterUse
    %assign success = CLEAR_FILE_BUFFERS()
  %endif
%endfunction


%% Function: LibWriteToStandardOutput ==========================================
%% Abstract:
%%   Assuming the current file is NULL_FILE, write text to the MATLAB command
%%   window.  If the current file is not NULL_FILE, you need to reselect the
%%   appropriate file after a call to this function.
%%
%function LibWriteToStandardOutput(txt) void
%%
%% DO NOT INDENT THIS TLC CODE !!!
%%
%selectfile STDOUT
%if RTWVerbose
%<txt>
%endif
%selectfile NULL_FILE
%endfunction  %% LibWriteToStandardOutput


%% Function: LibSetCodeTemplateComplianceLevel =================================
%% Abstract:
%%   Synchronize a custom code template.  This function must be
%%   called from a code template.
%%
%function LibSetCodeTemplateComplianceLevel(level) void
  %assign ::CompiledModel.ModelFiles.ComplianceLevel = level
%endfunction

%% [EOF] codetemplatelib.tlc
