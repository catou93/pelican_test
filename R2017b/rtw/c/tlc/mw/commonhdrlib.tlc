%% ============================================================================
%% File : commonhdrlib.tlc
%%
%% Abstract:
%%   This system TLC library file contains functions that are common
%%   between the different code generators for producing the model's
%%   header file.
%%
%% 
%% Copyright 1994-2017 The MathWorks, Inc.
%%
%% ============================================================================
%selectfile NULL_FILE

%if EXISTS("_COMMONHDRLIB_") == 0
%assign _COMMONHDRLIB_ = 1

%function SLibGetOldStrNames() void
  %return (!((CodeFormat == "RealTime") || (SLibIsERTCodeFormat())) || isGRTMalloc)
%endfunction

%function SLibGetPrmsName(oldStrNames) void
  %return oldStrNames ? ::tDefaultParameters : "%<LibGetParametersStruct()>"
%endfunction

%% Function: LibCacheModelStructureDefinitions =================================
%% Abstract:
%%   This function creates the guts of each model structure.  It should be
%%   called after all code is generated, and just prior to final model
%%   registration.
%%
%function LibCacheModelStructureDefinitions() void
  %<LibCacheExportedGlobalSignalsDefinition()>
  %<LibCacheCustomReusableSignalsDefinition()>
  %<LibCacheImportedExternSignalsDefinition()>
  %<LibCacheImportedExternPointerSignalsDefinition()>
  %if CodeFormat != "S-Function" || Accelerator
    %<LibCacheNonAutoStorageClassDWorkDefinition()>
  %endif
  %if !SLibAutosarActive()
    %<LibCacheExternalInputsStructDefinitionByVarGroup()>
    %<LibCacheExternalOutputsStructDefinitionByVarGroup()>
    %<LibCacheExternalInputSizesStructDefinition()>
    %<LibCacheExternalOutputSizesStructDefinition()>
  %endif
%endfunction


%% Function: SLibOmitRecord ====================================================
%% Abstract:
%%    Returns true if variable associated with a record in the RTW file has been
%%    eliminated from the generated code, and can therefor be omitted in the
%%    initialization and interface API code generation.
%%
%function SLibOmitRecord(aRecord) void
  %return 1 == aRecord.IsRemovedInIR
%endfunction

%% Function: LibGetChildSystemStructCommentName ==================================
%% Abstract: 
%%   Given a system index and a child SS block (not graphical), this function returns
%%   the properly formatted name for comments. Used for nested structures. This handles the
%%   formatting of shared function comments vs. regular comments.
%%
%function LibGetChildSystemStructCommentName(sysIdx, childSSBlock)
  %assign dataGrSrcBlk = ISFIELD(childSSBlock, "GrSrc") ? SLibGrBlock(childSSBlock.GrSrc) : []
  %if (LibSystemIsReusedLibraryFcn(System[sysIdx]) && !ISEMPTY(dataGrSrcBlk) && ...
       ISFIELD(dataGrSrcBlk, "RLSCommentName"))
    %assign commentName = dataGrSrcBlk.RLSCommentName
  %else
    %assign commentName = "'" + childSSBlock.Name + "'"
    %if ::CompiledModel.System[childSSBlock.BlockIdx[1]].Synthesized
        %assign origBlkSet = ISFIELD(::CompiledModel.System[childSSBlock.BlockIdx[1]],"OriginatorBlock")
        %if origBlkSet
            %assign origBlockName = ::CompiledModel.System[childSSBlock.BlockIdx[1]].OriginatorBlock
            %assign commentName = "'" + origBlockName + "'"
        %else
            %assign commentName = ""
        %endif
    %endif   
  %endif   
  %return commentName
%endfunction

%% Function: FcnGetChildSystemTypedefs =========================================
%% Abstract: 
%%   Generic function called by functions that generate typedefs for the 
%%   various data structures. This creates the definitons for Child systems 
%%   that have typedef.
%%
%function FcnGetChildSystemTypedefs(sysIdx, struct, typetag) void
  %assign childsysTypedefs = ""
  %assign numElements = 0
  %assign res = ["", 0] %% TLC bug workaround
  %assign inlineFcn = "SLibGetSystem%<struct>"
  %with ::CompiledModel.System[sysIdx]
    %if NumChildSystems > 0
      %if struct == "Parameters"
	%assign childSystems = ChildPrmStructs
      %else
	%assign childSystems = ChildSystems
      %endif
      %openfile childsysTypedefs
      %foreach childIdx = NumChildSystems
	%assign chIdx = childSystems[childIdx]
	%% Is first memory instance ? And not a reduced subsystem
	%if chIdx[1] == 0 && chIdx[3] > -1
	  %assign   blk = System[chIdx[2]].Block[chIdx[3]]
	  %with blk
            %assign childSys = System[CallSiteInfo.SystemIdx]
            %% If a child is a standalone subsystem, do not
            %% include it in this hierarchy.
            %if childSys.StandaloneSubsystem
              %continue
            %endif
	    %%if ISFIELD(CallSiteInfo, "%<struct>"Arg) && childSys.Has%<struct>Arg
	    %if !SLibSystemHasOwnDataScope(childSys)
	      %assign inlRes = %<inlineFcn>(childSys.SystemIdx)
	      %assign numElements = numElements + inlRes[1]
	      %<inlRes[0]>\
	    %elseif childSys.Has%<struct>Arg
              %assign csIdx       = blk.CallSiteIdx
              %assign varGroupIdx = FcnSysVarGroupIndex(childSys, typetag, csIdx)
              %if varGroupIdx < 0
                %continue
              %endif
              %assign structType  = SLibVarGroupType(varGroupIdx, typetag)
              %assign structName  = SLibVarGroupName(varGroupIdx)
              %assign comment    = "/* '%<childSys.Name>' */"
              %<SLibIfLocalPreprocessorCondition(blk)>
              %assign ppIf = SLibIfLocalPreprocessorCondition(blk)
              %% This routine does not handle preprocessor conditions;
              %% We expect data structures that are supported in variant
              %% subsystems to use vargroups to generate their typedefs
              %assert ISEMPTY(ppIf) || WHITE_SPACE(ppIf)
              %if SLibSysVarGroupUsedAsMatrix(System[childSys.SystemIdx],typetag, csIdx)
                %assign structWidth = SLibSysVarGroupWidth(System[childSys.SystemIdx],typetag, csIdx)
                %<structType> %<structName>[%<structWidth>]; %<comment>
              %else
                %<structType> %<structName>; %<comment>
              %endif
	      %assign numElements = numElements + 1
	    %endif
	  %endwith
	%endif
      %endforeach
      %closefile childsysTypedefs
    %endif %% NumChildSystems > 0
  %endwith %% System[sysIdx]
  %if numElements > 0
    %assign res[0] = "%<childsysTypedefs>"
    %assign res[1] = %<numElements>
  %endif
  %return res
%endfunction %% FcnGetChildSystemTypedefs


%% Function: LibRegCommonIncludes ==============================================
%% Abstact:
%%   This function registers header files necessary to compile a standalone
%%   system.
%%
%function LibRegCommonIncludes(sysIdx) void
  %%
  %% Common Includes
  %%
  %<SLibAddToCommonIncludes(SLibCoderTypesFilename())>
  
  %if ::needZeroCrossingTypes
    %<SLibAddToCommonIncludes(SLibCoderZerocrossingTypesFilename())>
  %endif
  
  %if !GenRTModel || SLibModelHierarchyContainsNoninlinedSfcn() || ...
    IsModelReferenceForASimstructBasedTarget() || ...
    GenerateGRTWrapper
    %if (::CompiledModel.NumChildSFunctions > 0) && ...
      !Accelerator && CodeFormat != "S-Function"
      %assign fpath = FEVAL("matlabroot") + "\\rtw\\c\\src"
      %assign tf = FEVAL("coder.internal.callBuildInfo", ::CompiledModel.Name, 1, "addSourceFiles", "rt_matrx.c", fpath, "TLC") 
      %assign tf = FEVAL("coder.internal.callBuildInfo", ::CompiledModel.Name, 1, "addSourceFiles", "rt_printf.c", fpath, "TLC") 
    %endif
    %<SLibAddToNonSharedIncludes("simstruc.h")>
    %<SLibAddToNonSharedIncludes("fixedpoint.h")>
  %elseif SLibIsERTCodeFormat()
    %if ::ExtMode == 1 
      %<SLibAddToNonSharedIncludes("rtw_extmode.h")>
      %<SLibAddToNonSharedIncludes("sysran_types.h")>
    %endif
    %if ::CompiledModel.ConfigSet.SupportContinuousTime == 1
      %<SLibAddToNonSharedIncludes("rtw_continuous.h")>
      %if !PurelyIntegerCode
        %<SLibAddToNonSharedIncludes("rtw_solver.h")>
      %endif
    %endif
  %endif

  %if isRSim %% ok ModelReference
    %if isRAccel
      %<SLibAddToNonSharedIncludes("raccel.h")>
      %<SLibAddToNonSharedIncludes("slsv_diagnostic_codegen_c_api.h")>
      %if ISFIELD(::CompiledModel,"ModelHasParallelForEachSS") && ...
        ::CompiledModel.ModelHasParallelForEachSS
        %<SLibAddToNonSharedIncludes("slexec_parallel.h")>
      %endif
    %else
      %<SLibAddToNonSharedIncludes("rsim.h")>
    %endif
  %endif
  
  %if MatFileLogging != 0
    %assign fpath = FEVAL("matlabroot") + "\\rtw\\c\\src"
    %assign tf = FEVAL("coder.internal.callBuildInfo", ::CompiledModel.Name, 1, "addSourceFiles", "rt_logging.c", fpath, "TLC") 
    %<SLibAddToNonSharedIncludes("rt_logging.h")>
  %endif
  
  %if CreateTransitionTable == 1 
    %<SLibAddToNonSharedIncludes("dt_info.h")>
  %endif
  %if ExtMode == 1
    %<SLibAddToNonSharedIncludes("ext_work.h")>
  %endif
  %if UsingMalloc || FcnIsERTMalloc() || isRSim || isRSimWithSolverModule %% ok Model Reference
    %<SLibAddToNonSharedIncludes("<stdlib.h>")>
  %endif

  %if SLibAutosarActive()
    %if MultiInstanceERTCode       
      %% Add Rte_<swc>.h to model_private.h (only once)
      %if !ISFIELD(RTWAutosar, "Rte_SWC_Header_Included")
        %addtorecord RTWAutosar Rte_SWC_Header_Included TLC_TRUE  
        %assert !SLibIsCompactFileFormat() %% Must have Modular File packaging        
        %openfile tmpBuf
        #include "%<MainAutosarInterfaceName()>.h"
        %closefile tmpBuf
        %<SLibCacheCodeToFile("mdl_priv_hdr_incl", tmpBuf)>
      %endif
    %else
      %<SLibAddToNonSharedIncludes("%<MainAutosarInterfaceName()>.h")>
    %endif
  %endif
  
  
  %%
  %% Custom user code for adding header files which
  %% contain profiling information
  %%
  %<SLibGenProfHeaders()>

%endfunction %% LibRegCommonIncludes

%% Function: LibDumpCommonDefines ==============================================
%% Abstract:
%%    Common Defines - Does not include generic model defines.
%%    Returns macros necessary to compile a standalone system.
%%
%function LibDumpCommonDefines(sysIdx) void
  %openfile tmpDefineBuf
  
  %if UsingMalloc || isRSim
    %<LibDeclareMemoryAllocationMacros()>\
  %endif

  %closefile tmpDefineBuf
  %return tmpDefineBuf
%endfunction %% LibDumpCommonDefines 

%% Function: LibDeclareERTDefines ==============================================
%% Abstract:
%%   Returns ERT specific macros necessary to compile a standalone system.
%%
%function LibDeclareERTDefines(sysIdx) void
  %openfile tmpDefineBuf
  %if MatFileLogging == 1 || GenerateGRTWrapper

    #define QUOTE1(name) #name
    #define QUOTE(name) QUOTE1(name)    /* need to expand name */
    %if MatFileLogging == 1
      #ifndef SAVEFILE
      # define MATFILE2(file) #file ".mat"
      # define MATFILE1(file) MATFILE2(file)
      # define MATFILE MATFILE1(MODEL)
      #else
      # define MATFILE QUOTE(SAVEFILE)
      #endif
    %endif
  %endif
  %closefile tmpDefineBuf
  %return tmpDefineBuf
%endfunction  

%% Function: LibSFcnPreSimstrucDefines =========================================
%% Abstract:
%%   Return the neccesary macros the need to be declared before the   
%%   simstruct will be included for the S-Function target and Accelerator.
%%
%function LibSFcnPreSimstrucDefines(system) void
  %assign tmpDefineBuf = ""
  
  %openfile tmpDefineBuf
  %assign tmpName = Accelerator ? "simulink_only_sfcn" : Name
  %if system.Type == "root"
    #define S_FUNCTION_NAME %<tmpName> 
  %endif
  #define S_FUNCTION_LEVEL 2
  #define RTW_GENERATED_S_FUNCTION
  %closefile tmpDefineBuf
  %return tmpDefineBuf
%endfunction %% LibSFcnPreSimstrucDefines

%% Function: LibSFcnPostSimstrucDefines ========================================
%% Abstract:
%%   Return the neccesary macros the need to be declared after the   
%%   simstruct is included for the S-Function target and Accelerator.
%%
%function LibSFcnPostSimstrucDefines() void
  %assign tmpDefineBuf = ""
  %if !Accelerator
    %openfile tmpDefineBuf
    #if !defined(MATLAB_MEX_FILE)
    #include "rt_matrx.h"
    #endif

    #if !defined(RTW_SFUNCTION_DEFINES)
    #define RTW_SFUNCTION_DEFINES
    typedef struct {
      void *blockIO;
      void *defaultParam;
      void *nonContDerivSig;
    } LocalS;
    
    #define %<RTMSet("LocalBlockIO","io")> ...
      ((LocalS *)%<RTMGet("UserData")>)->blockIO = ((void *)(io))
    #define %<RTMGet("LocalBlockIO")> ...
      ((LocalS *)%<RTMGet("UserData")>)->blockIO
    
    #define %<RTMSet("LocalDefaultParam", "paramVector")> ...
      ((LocalS *)%<RTMGet("UserData")>)->defaultParam = (paramVector)
    #define %<RTMGet("LocalDefaultParam")> ...
      ((LocalS *)%<RTMGet("UserData")>)->defaultParam

    #define %<RTMSet("LocalNonContDerivSig", "pSig")> ...
      ((LocalS *)%<RTMGet("UserData")>)->nonContDerivSig = (pSig)
    #define %<RTMGet("LocalNonContDerivSig")> ...
      ((LocalS *)%<RTMGet("UserData")>)->nonContDerivSig
    #endif
    
    %closefile tmpDefineBuf
  %endif
  %return tmpDefineBuf
%endfunction  

%% Function: LibDeclareTrueFalse ===============================================
%% Abstract:
%%   Define TRUE/FALSE = 0/1 and also Define fcn_call_T and pointer_T.
%%   This is a  temporary fix so that external mode code can compile (these
%%   types shows up in the model_dt.c file).  Note that these types should
%%   never be accessed by RTW.  Also define action_T like fcn_call_T
%%   for the same reasons.
%% WARNING: This function will be obsoleted in next release, definition is inside
%%          rtwtypes.h.
%%
%function LibDeclareTrueFalse() void
  %warning This function will be obsoleted in next release. True/False definitions is inside rtwtypes.h.
  %openfile tmpFcnBuf

  #ifndef TRUE
  # define TRUE (1)
  #endif
  #ifndef FALSE
  # define FALSE (0)
  #endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%function SLibGenerateProprocessorDefnForVariantObjectsWithCSC() void
%% Abstract:
%% generate pre-processor definitions for CSC's used in variant choice
%% blocks.
  %if ISFIELD(GlobalMemoryMap,"CustomData")
      %openfile tmpFcnBuf
      %assign nDataRecs = GlobalMemoryMap.NumCustomData
      %foreach dataRecIdx = nDataRecs
	%assign customDataRec = GlobalMemoryMap.CustomData[dataRecIdx]
	%assign nData         = customDataRec.NumData
	%assign cscDefn       = SLibGetCSCDefForCSC(customDataRec)
        
	%foreach dataIdx = nData
	  %if nData == 1
	    %assign data = customDataRec.Data
	  %else
	    %assign data = customDataRec.Data[dataIdx]
	  %endif
 
          %with data
            %if (SLibGetDataInitForData(cscDefn, data) == "Macro" && cscDefn.DataScope == "Imported")
              %assign id   = LibGetRecordIdentifier(data.RTWRecord)
              %assign varName = LibGetRecordVarName(data.RTWRecord)
              %assign ppIf = ""
              %if EXISTS(data.PPIf)
                %assign ppIf = data.PPIf
              %endif
              %assign ppEndif = ""
             
              %if EXISTS(data.PPEndIf)
                %assign ppEndif = data.PPEndIf
              %endif
             
              %if varName == id
                %assign idDescr = "variable for the parameter \"%<varName>\""
              %else
                %assign idDescr = "variable \"%<id>\" for the parameter \"%<varName>\""
              %endif
 
              %if !ISEMPTY(ppIf)
                %<ppIf>
                #ifndef %<id>
                #error The %<idDescr> is not defined
                #endif
                %<ppEndif>
              %endif
             %endif
          %endwith  
        %endforeach
      %endforeach
      %closefile tmpFcnBuf
      %return tmpFcnBuf
 %endif
%endfunction  

%% Function: SLibGenerateVariantStuff ===============================================
%% Abstract:
%%   Generate Simulink.Variant definitions and constraint checking
%%
%function SLibGenerateVariantStuff() void
  %if !(::CompiledModel.HasCodeVariants)
    %return
  %endif
  
  %% Enumerated types used by Simulink.Variant definitions
  %openfile variantEnumeratedTypes
  %<SLibDeclarePreprocessorEnums()>\
  %closefile variantEnumeratedTypes
  %<SLibCacheCodeToFile("data_simulink_variant_define", variantEnumeratedTypes)>
  %undef variantEnumeratedTypes
  
  %% Simulink.Variant definitions
  %openfile simulinkVariantObjects
  %<SLibDeclareSimulinkVariantObjects(TLC_FALSE)>\
  %<SLibErrorCheckInlineVariantsWithAZVC()>
  %closefile simulinkVariantObjects
  %<SLibCacheCodeToFile("data_simulink_variant_define", simulinkVariantObjects)>
  %undef simulinkVariantObjects
  
  %% Simulink.Params or mpt.Params  with guards
  %openfile paramWithGuards
  %% Add CSC symbols used in Variant choices
  %% This is called here to make sure that we have #defines' for Variant objects
  %% created already.The #error checks for Simulink.Parameters were done in customstoragelib.tlc
  %% but at that time we don't have #define's for Simulink.Variant objects so it is invalid to 
  %% add protection in customstoragelib.tlc for Simulink.Parameters used in Variant choices.
  %% we do it to here, so that generated code looks correct. 
  %<SLibGenerateProprocessorDefnForVariantObjectsWithCSC()>
  %closefile paramWithGuards
  %%<SLibCacheCodeToFile("mdl_priv_macro_define", paramWithGuards)>
  %<SLibCacheCodeToFile("param_variant_errorChecks", paramWithGuards)>
  %undef paramWithGuards
  
    %% constraint checking
  %openfile preprocessorConstraints
  %<SLibDeclarePreprocessorConstraints()>\
  %closefile preprocessorConstraints
  %<SLibCacheCodeToFile("data_simulink_variant_define", ...
    preprocessorConstraints)>
  %undef preprocessorConstraints
%endfunction  

%% Function: SLibDeclarePrimitiveTypedefs ======================================
%% Abstract:
%%   Uses intrinsic types.
%%
%function SLibDeclarePrimitiveTypedefs() void
  %openfile tmpFcnBuf
  %% This is by design, do not remove this function since we will
  %% have primitive typedefs in the future.
  %if 0
    
    /* Primitive typedefs */
    #ifndef TMW_PRIMITIVE_TYPEDEFS
    #define TMW_PRIMITIVE_TYPEDEFS
    #endif
  %endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: LibDeclareGenericModelDefines =====================================
%% Abstract:
%%   Declare generic model defines 
%%
%function LibDeclareGenericModelDefines() void
  %openfile tmpFcnBuf
  #define MODEL_NAME %<Name>
  #define NSAMPLE_TIMES (%<NumSampleTimes>) /* Number of sample times */
  #define NINPUTS (%<NumModelInputs>)       /* Number of model inputs */
  #define NOUTPUTS (%<NumModelOutputs>)     /* Number of model outputs */
  #define NBLOCKIO (%<BlockOutputs.NumSignalsInBlockIO>) ...
    /* Number of data output port signals */
  #define NUM_ZC_EVENTS (%<NumZCEvents>) /* Number of zero-crossing events */
  
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: LibDeclareNCSTATES ================================================
%% Abstract:
%%   Create the number of continous states define.
%%
%function LibDeclareNCSTATES() void
  %openfile tmpFcnBuf
  #ifndef NCSTATES
  # define NCSTATES (%<NumContStates>)   /* Number of continuous states */
  #elif NCSTATES != %<NumContStates>
  # error Invalid specification of NCSTATES defined in compiler command
  #endif
  
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: SLibDeclareSimulinkVariantObjects ================================
%% Abstract:
%%   Create the #define for each Simulink.Variant object, which are used
%%   to select model code variants when IsStub is equal to False.
%%   Create the #define for each Autosar.VariationPointProxy object, which are used
%%   to select model code variants when IsStub is equal to True.
%%
%function SLibDeclareSimulinkVariantObjects(IsStub) void
  %openfile tmpSVBuf
  %assign nsparams = ::CompiledModel.CodeVariants.NumNormalVariantControlVars
  %if nsparams > 0 
    %% get the number of non simulink params. if there exists more than '0' non-simulink
    %% params, we will define them in a new hdeader file.
    %with ::CompiledModel.CodeVariants
         /**
           * You can use the following defines via the compiler command line to change the
           * values of normal variant control variables. A normal variant control variable
           * is a plain MATLAB variable, i.e. not a Simulink.Parameter. By default the
           * value defined for a normal variant control variable is set to the value seen
           * by Simulink when building the model.
           *
           *  1. Specify -DSKIP_VARIANT_DEFINES -DVC_VARIABLE1=VALUE1 ... when compiling
           *     Defining SKIP_VARIANT_DEFINES instructs this header to not define the
           *     variant control variables, (e.g. VC_VARIABLE1) to the value that existed
           *     when generating code. You then need to define each of your variant control
           *     variables (e.g. -DSKIP_VARIANT_DEFINES -DVC_VARIABLE1=123) during compile.
           *  2. Specify -DUSE_VARIANT_DEFINES_HEADER="header.h"
           *     This is similar to defining SKIP_VARIANT_DEFINES when compiling, in that
           *     this header does not define the variant control variables, (e.g. VC_VARIABLE1)
           *     to the value that existed when generating code. You then must put these
           *     defines in your header.h file.
           *
           * If you'd like to explicitly specify the code generation behavior for the
           * variant control variables, you need to define the variant control variable
           * as a Simulink.Parameter with the appropriate code generation options sepecified
           * as described in the Simulink documentation.
           */

           #ifdef USE_VARIANT_DEFINES_HEADER
           #define SKIP_VARIANT_DEFINES
           #define VARIANT_DEFINES_HEADER_STR(h) #h
           #define VARIANT_DEFINES_HEADER(h) VARIANT_DEFINES_HEADER_STR(h)
           #include VARIANT_DEFINES_HEADER(USE_VARIANT_DEFINES_HEADER)
           #endif /* USE_VARIANT_DEFINES_HEADER */

           #ifndef SKIP_VARIANT_DEFINES
           %foreach paramIdx = nsparams
             %assign nsVar =  NormalVariantControlVars[paramIdx].Name
             %assign value =  NormalVariantControlVars[paramIdx].Value
             #define %<nsVar> %<value>
           %endforeach

           #endif /* SKIP_VARIANT_DEFINES */

          /*
           * Validate the variant control variables are consistent with the model requirements
           */
          %foreach paramIdx = nsparams
            %assign paramName =  NormalVariantControlVars[paramIdx].Name
            #if !defined(%<paramName>)
            #error %<paramName> is not defined
            #endif
           %endforeach
    %endwith
  %endif
  
  %if ::CompiledModel.HasCodeVariants && ...
      ::CompiledModel.CodeVariants.NumSimulinkVariantObjects > 0
    %with ::CompiledModel.CodeVariants
      %assign numSVIdxs = NumVariantObjectOrderedIndexs
      %foreach svIdxIdx = numSVIdxs
        %% get the index of the SV object from the table of indexes,
        %% which is in SV object dependency order
        %assign svIdx = VariantObjectOrderedIndexs[svIdxIdx]
        %with SimulinkVariantObject[svIdx]
          %% if the Condition is same as Name, it means we are using
          %% conditions directly, and not Simulink.Variant objects.
          %% We don't need to create #define for Conditions.
          %if Name != Condition
            %% For non-stub file, we  generate the simulink variant definition,
            %% For stub file, we generate the autosar variationpointproxy definition
            %% For R2013b, IsImported is true only for Autosar VPPs. It needs to be fixed
            %% in future versions.
            %if IsStub && IsImported
              #ifndef Rte_SysCon_%<Name>
              #define Rte_SysCon_%<Name> (%<Condition>)
              #endif
            %elseif !IsStub && !IsImported
              #ifndef %<Name>
              #define %<Name> (%<Condition>)
              #endif
            %endif
          %endif
        %endwith
      %endforeach
    %endwith
  %endif
  %% Add Variant symbols from Model ref 
  %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
    ::CompiledModel.ModelReferenceBlocks : []
  %if !ISEMPTY(mdlRefBlks)
    %foreach rowIdx = SIZE(mdlRefBlks,0)
      %assign mdlRefInfo   = mdlRefBlks[rowIdx]
      %assign mSysIdx      = mdlRefInfo[0]
      %assign bIdx         = mdlRefInfo[1]
      %assign blkInterface = GetModelrefInterface(System[mSysIdx].Block[bIdx])

      %if ISFIELD(blkInterface, "CodeVariants")
        %assign variantControl = blkInterface.CodeVariants.VariantControl
        %if ISFIELD(variantControl, "Variant")
          %assign numVariants = SIZE(variantControl.Variant, 1)
          %foreach idx = numVariants
            %assign variant = variantControl.Variant[idx]
            %if variant.Name != variant.Condition
                %if IsStub && variant.IsImported
                  #ifndef Rte_SysCon_%<variant.Name>
                  #define Rte_SysCon_%<variant.Name> (%<variant.Condition>)
                  #endif
                %elseif !IsStub && !variant.IsImported
                  #ifndef %<variant.Name>
                  #define %<variant.Name> (%<variant.Condition>)
                  #endif
                %endif 
            %endif
          %endforeach 
        %endif
      %endif
    %endforeach
  %endif

  %closefile tmpSVBuf
  %if !ISEMPTY(tmpSVBuf)
    %openfile retBuf
    /* Model Code Variants */
    %<tmpSVBuf>
    %closefile retBuf
    %return retBuf
  %else
    %return
  %endif
%endfunction

%% Function: SLibEnumeralPreprocessorSymbol ====================================
%% Abstract:
%%   Create a unique preprocessor symbol for an enumeral of an enumerated
%%   type. The symbol consists of the type name with the enumeral name
%%   appended.
%%
%function SLibEnumeralPreprocessorSymbol(enumDataTypeId, enumIdx) void
  %assign enumTypeName = DataTypes.DataType[enumDataTypeId].Name
  %assign enumeralName = SLibGetEnumTypeCodeGenStringFromIndex(enumDataTypeId, enumIdx)
  %return "%<enumTypeName>_%<enumeralName>"
%endfunction

%% Function: SLibDeclarePreprocessorEnums ======================================
%% Abstract:
%%   Create a #define for each enumeral of all enumerated types listed
%%   in the EnumeratedTypeIds vector of the CodeVariants record
%%   to select model code variants
%%
%function SLibDeclarePreprocessorEnums() void
  %if ::CompiledModel.HasCodeVariants && ...
      ::CompiledModel.CodeVariants.NumEnumeratedTypeIds > 0
    %with ::CompiledModel.CodeVariants
      %openfile tmpEnumsBuf
      
      /* Simulink enumerals used in Code Variant condition expressions */
      %assign numEnumTypes = NumEnumeratedTypeIds
      %foreach enumTypeIdx = numEnumTypes
        %assign enumDataTypeId = EnumeratedTypeIds[enumTypeIdx]
        %% we assume the index into the DataTypes table is the same
        %% as the type ID of the type. verify that here:
        %assert LibIsEnumDataType(enumDataTypeId)
        %assert enumDataTypeId == DataTypes.DataType[enumDataTypeId].Id
        
        %assign enumTypeName = DataTypes.DataType[enumDataTypeId].Name
        #ifndef _RTW_ENUMS_%<enumTypeName>_
        #define _RTW_ENUMS_%<enumTypeName>_
        %foreach enumIdx = FcnGetEnumTypeNumEnums(enumDataTypeId)
          %assign enumeralPreprocessorSymbol = ...
            SLibEnumeralPreprocessorSymbol(enumDataTypeId, enumIdx)
          %assign enumeralValue = SLibGetEnumTypeValueFromIndex(enumDataTypeId, enumIdx)
          #define %<enumeralPreprocessorSymbol> %<enumeralValue>
        %endforeach

        #endif
      %endforeach
      
      %closefile tmpEnumsBuf
    %endwith
    %return tmpEnumsBuf
  %else
    %return
  %endif
%endfunction

%% Function: SLibErrorCheckInlineVariantsWithAZVC ==============================
%% Abstract:
%% Error check Inline Variant blocks that when AZVC is off, we need atleast 
%% one variant
%function  SLibErrorCheckInlineVariantsWithAZVC() void
  %if (!::CompiledModel.HasInlineVariants)
    %return 
  %endif

  %if (!EXISTS(::CompiledModel.CodeVariants.InlineVariantWithAZVCOff)) 
    %return
  %endif 

  %openfile tmpBuf
  %assign azvcBlocks = ::CompiledModel.CodeVariants.InlineVariantWithAZVCOff
  %assign azvcBlockLength = SIZE(azvcBlocks,1)
  %foreach idx = azvcBlockLength
     %if azvcBlockLength == 1
       %assign blockRec = azvcBlocks
     %else 
       %assign blockRec = azvcBlocks[idx]
     %endif
     %assign azvcList = blockRec.VariantControlList
     %assign numControls = blockRec.NumVariantControls
     %assign logic = ""
     %foreach idx = numControls
       %assign ctrl = azvcList[idx]
       %if !ISEMPTY(logic)
          %assign logic = logic + " + "
       %endif
       %assign logic = logic + "(" + "(" + ctrl + ") ? 1 : 0" ")"
     %endforeach 
     %if blockRec.AZVCOn
        #if %<logic> > 1
        #error Block '%<blockRec.BlockName>' should not have more than one active variant choice
        #endif
     %else
        #if %<logic> != 1
        #error Exactly one variant for '%<blockRec.BlockName>' should be active
        #endif
     %endif

  %endforeach
  %closefile tmpBuf
  %return tmpBuf
%endfunction 
     
%% Function: SLibDeclarePreprocessorConstraints ================================
%% Abstract:
%%   Create the #error corresponding to code variant constraints
%%
%function SLibDeclarePreprocessorConstraints() void
  %if (!::CompiledModel.HasCodeVariants) || ...
       (::CompiledModel.CodeVariants.NumCodeVariantGroups == 0)
    %return 
  %endif
  
  %openfile tmpBuf
  %assign numVariants = ::CompiledModel.CodeVariants.NumCodeVariantGroups
  %createrecord VariantsMap {}
  %assign numSimulinkVariantObjects = ::CompiledModel.CodeVariants.NumSimulinkVariantObjects
  %foreach nIdx = numSimulinkVariantObjects
      %assign varObjName = ::CompiledModel.CodeVariants.SimulinkVariantObject[nIdx].Name
      %if ::CompiledModel.CodeVariants.SimulinkVariantObject[nIdx].IsImported
          %% For R2013b, IsImported is true only for Autosar VPPs. It needs to be fixed
          %% in future versions.
         %addtorecord VariantsMap %<varObjName> ""
      %endif
  %endforeach
  
  %foreach cIdx = numVariants
    %assign logic = ""
    %assign isDefault = ""
    %assign hasRtwBlocks = 0
    %assign variant = ::CompiledModel.CodeVariants.CodeVariantGroup[cIdx]
    %assign nonExpandedGrSrc = variant.NonExpandedGrSrc
    %assign numExpandedBlocks = variant.NumExpandedBlocks
    %foreach mIdx = numExpandedBlocks
      %assign expandedBlockIdx = variant.ExpandedBlock[mIdx].FirstInstanceSrcIndex
      %assign expandedBlock = ...
        ::CompiledModel.System[expandedBlockIdx[0]].Block[expandedBlockIdx[1]]
      %switch expandedBlock.Type
          %case "SubSystem"
            %assign condition = expandedBlock.LocalPreprocessorCondition
            %assign temp_def = expandedBlock.IsDefaultVariant
            %if ::CompiledModel.System[expandedBlock.CallSiteInfo.SystemIdx].NumTotalBlocks != 0
		%assign hasRtwBlocks = 1
            %endif
            %if !ISEMPTY(temp_def)
              %assign isDefault = temp_def
              %continue
            %endif
            %break
          %case "ModelReference"
            %assign condition = SLibMdlRefLocalPreprocessorCondition(expandedBlock)
            %assign isdefaultv = SLibMdlRefIsDefaultVariant(expandedBlock)
	    %% for modelref choice, we always have initialize method being called from the referenced model
            %% so assigning the hasRtwBlocks to '1', ideally we should have some information in .rtw file from
            %% paramSettings, but the information pertaining to the 'numBlocks' is not present there. 
            %assign hasRtwBlocks = 1
            %if !ISEMPTY(isdefaultv)
              %assign isDefault = isdefaultv
              %continue
            %endif
            %break
          %default
            %assign condition = "0"
            %% unexpected block type
            %assert 1
            %break
        %endswitch
      %if mIdx > 0
        %if !ISEMPTY(logic)
          %assign logic = logic + " + "
        %endif
      %endif

      %if ISFIELD(VariantsMap, condition)
         %assign logic = logic + "(" + "(" + "Rte_SysCon_" + condition + ") ? 1 : 0" + ")"
      %else
         %assign logic = logic + "(" + "(" + condition + ") ? 1 : 0" ")"
      %endif
    %endforeach
    %if hasRtwBlocks != 0
      %if ISEMPTY(isDefault)
        /* Exactly one variant for '%<SLibGrBlockName(nonExpandedGrSrc)>' should be active */
        #if %<logic> != 1
        #error Exactly one variant for '%<SLibGrBlockName(nonExpandedGrSrc)>' should be active
        #endif
      %else
        /* Exactly one variant for '%<SLibGrBlockName(nonExpandedGrSrc)>' should be active */
        #if %<logic> > 1
        #error Block '%<SLibGrBlockName(nonExpandedGrSrc)>' should not have more than one active variant choice
        #endif   
      %endif
   %endif 
  %endforeach
  
  %closefile tmpBuf
  %return tmpBuf
%endfunction

%% Function: SLibParamIsVariantControlParamInVariantCondition ===============
%% Abstract:
%%   Checks if the given parameter is used in a variant condition
%%   that appears as a preprocessor condition in the generated code.
%function SLibParamIsVariantControlParamInVariantCondition(dataRec) void
  %return (SLibIsParameterType(dataRec) && dataRec.IsVariantControlPrmInCondExpr)
%endfunction

%% Function: SLibParamIsVariantControlParamInDimensionsExpression ===========
%% Abstract:
%%   Checks if the given parameter is used in a dimension expression
%%   that is preserved in the generated code.
%function SLibParamIsVariantControlParamInDimensionsExpression(dataRec) void
  %return (SLibIsParameterType(dataRec) && dataRec.IsVariantControlPrmInDimsExpr)
%endfunction

%% Function: SLibParamIsVariantControlParam ==================================
%% Abstract:
%%   Checks if the given parameter is used as a variant control variable.
%function SLibParamIsVariantControlParam(dataRec) void
  %return ((dataRec.RecordType == "ModelParameter") && ...
           (SLibParamIsVariantControlParamInVariantCondition(dataRec) || ...
            SLibParamIsVariantControlParamInDimensionsExpression(dataRec)))
%endfunction

%% Function: SLibGetCodeVariantDataForReport ================================
%% Abstract:
%%   returns a data structure that will be passed to
%%   private/genCodeVariantReport to produce the Code Variants section of
%%   the code generation report. The data structure is a copy of the
%%   CodeVariants structure in the .RTW file with additional information added:
%%     1. the variant condition and subsystem or referenced model is added to
%%        the ExpandedBlock record of each CodeVariantGroup record.
%%     2. the block name and block path of the original (non-expanded) model
%%        block are added to each CodeVariantGroup record
%%     3. the block name and block path of each model block that uses a
%%        Simulink.Variant object is added to each SimulinkVariantObject
%%        record
%function SLibGetCodeVariantDataForReport() void
  %if ::CompiledModel.HasCodeVariants

    %assign cvData = ::CompiledModel.CodeVariants
    
    %% augment each expanded block's information with the condition
    %% that selects it and the model it references. Also replace
    %% the original block's index with the block's name
    %assign numVariantGroups = cvData.NumCodeVariantGroups
    %foreach vgIdx = numVariantGroups
      %assign nonExpandedGrSrc = cvData.CodeVariantGroup[vgIdx].NonExpandedGrSrc
      %assign numExpandedBlocks = cvData.CodeVariantGroup[vgIdx].NumExpandedBlocks
      %foreach ebIdx = numExpandedBlocks
        %assign expandedBlockIdx = ...
          cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx].FirstInstanceSrcIndex
        %assign expandedBlock = ...
          ::CompiledModel.System[expandedBlockIdx[0]].Block[expandedBlockIdx[1]]
        %switch expandedBlock.Type
          %case "SubSystem"
            %assign condition = expandedBlock.LocalPreprocessorCondition
            %% If we have default variant, we need to set the condition to the default
            %% variant keyword, this is needed for code variants report generation
            %if ISEMPTY(condition)
              %if !ISEMPTY(expandedBlock.IsDefaultVariant)
                 %assign condition = expandedBlock.IsDefaultVariant
               %endif
            %endif   
            %break
          %case "ModelReference"
            %assign condition = SLibMdlRefLocalPreprocessorCondition(expandedBlock)
            %% If we have default variant, we need to set the condition to the default
            %% variant keyword, this is needed for code variants report generation
            %if ISEMPTY(condition)
              %assign isdefaultv = SLibMdlRefIsDefaultVariant(expandedBlock)
              %if !ISEMPTY(isdefaultv)
                %assign condition = isdefaultv
              %endif
            %endif   
            %addtorecord cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx] ...
              ReferencedModel expandedBlock.ParamSettings.ReferencedModelName
            %break
          %default
            %assign condition = "0"
            %% unexpected block type
            %assert 1
            %break
        %endswitch
        %addtorecord cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx] ...
           ChoiceBlockName LibGetBlockName(expandedBlock)
        %addtorecord cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx] ...
           ChoiceBlockPath LibGetBlockPath(expandedBlock)
        %addtorecord cvData.CodeVariantGroup[vgIdx].ExpandedBlock[ebIdx] ...
          VariantCondition condition
      %endforeach
      %% append the name of the block to the record
      %addtorecord cvData.CodeVariantGroup[vgIdx] ...
        NonExpandedBlockName SLibGrBlockName(nonExpandedGrSrc)
      %addtorecord cvData.CodeVariantGroup[vgIdx] ...
        NonExpandedBlockPath SLibGrBlockPath(nonExpandedGrSrc)
    %endforeach

    %% augment each Simulink.Variant object with the names and paths of
    %% the blocks that use the variant
    %assign numVariantObjects = cvData.NumSimulinkVariantObjects
    %foreach voIdx = numVariantObjects
      %% create two vectors sized by the number of rows in the
      %% ReferencedBy matrix, which is the number of referencing blocks
      %assign sizeOfReferencedByMatrix = ...
        SIZE(cvData.SimulinkVariantObject[voIdx].ReferencedBy)
      %assign numBlocks = sizeOfReferencedByMatrix[0]
      %if numBlocks > 0
        %assign blockNames = Vector(%<numBlocks>) [0:%<numBlocks-1>]
        %assign blockPaths = Vector(%<numBlocks>) [0:%<numBlocks-1>]
        
        %% put the names and paths of the referenced blocks in the vectors
        %foreach bIdx = numBlocks
          %assign refBlkGrSrc = ...
            cvData.SimulinkVariantObject[voIdx].ReferencedBy[bIdx]
          %assign blockNames[bIdx] = SLibGrBlockName(refBlkGrSrc)
          %assign blockPaths[bIdx] = SLibGrBlockPath(refBlkGrSrc)
        %endforeach
        
        %% append the vectors to the SimulinkVariantObject record
        %addtorecord cvData.SimulinkVariantObject[voIdx] ...
          ReferencedByBlockNames blockNames
        %addtorecord cvData.SimulinkVariantObject[voIdx] ...
          ReferencedByBlockPaths blockPaths
      %endif
    %endforeach
    
    %return cvData
  %else
    %return
  %endif
%endfunction

%% Function: LibCacheSystemIncludes ============================================
%% Abstract:
%%   Goes through each system, and caches the include of any child
%%   systems that will be parented by the system.
%%   Called in *wide.tlc.
%%
%function LibCacheSystemIncludes(sysIdx) void
  %% Cache necessary includes
  %assign system = System[sysIdx]
  %if (system.FileNameOwnerIdx == sysIdx)
    %openfile sysheader
    %foreach idx = SIZE(system.IncludedChildSystemIdx,1)
      %assign inChildSysIdx = system.IncludedChildSystemIdx[idx]
      %assign inChildSys = ::CompiledModel.System[inChildSysIdx]
      %assign inChildSysFileName = inChildSys.SystemFileName
      %if !LibSystemIsReusedLibraryFcn(System[sysIdx])
        %<GetHideChildDefineSymbol("ifndef")>\
      %endif
      %if LibIsGlobalServer(inChildSys)
        %% If the filename is server (not compact) then we that means
        %% we have generated a private file which also needs to
        %% be included
        %if inChildSysFileName == inChildSys.Identifier
          #include "%<inChildSys.Identifier>_private.h"
        %% We always need to include the server.h
        %endif
        #include "%<inChildSys.Identifier>.h"
      %elseif(inChildSysFileName != system.SystemFileName)
        #include "%<inChildSysFileName>.h"
      %endif
      %if !LibSystemIsReusedLibraryFcn(System[sysIdx])
        %<GetHideChildDefineSymbol("endif")>\
      %endif
    %endforeach
    %assign numMdlRefBlks = system.NumIncludedModelReference
    %foreach rowIdx = numMdlRefBlks
      %% a row matrix containing [sysIdx, bIdx]
      %assign mdlRefInfo = system.IncludedModelReference[rowIdx] 
      %assign mSysIdx = mdlRefInfo.SysIdx
      %assign bIdx    = mdlRefInfo.BlockIdx
      %assign blk     = ::CompiledModel.System[mSysIdx].Block[bIdx]
      %assert 0 == blk.DeletedInIR
      %assign blockInterface = GetModelrefInterface(blk)
      %assign name           = blockInterface.FileName
      %assign instancesWithConditions = mdlRefInfo.InstancesWithConditions
      %assign condition = ""
      %if !ISEMPTY(instancesWithConditions)
        %assign numInstances = SIZE(instancesWithConditions, 0)
        %foreach instIdx = numInstances
          %assign mSysIdx2 = instancesWithConditions[instIdx][0]
          %assign bIdx2    = instancesWithConditions[instIdx][1]
          %assign blk2     = System[mSysIdx2].Block[bIdx2]
          %if instIdx > 0
            %assign condition = condition + " || "
          %endif
          %assign condition = condition + ...
            "(" + SLibMdlRefSystemPreprocessorCondition(blk2) + ")"
        %endforeach
        #if %<condition>
      %endif
      %<GetHideChildDefineSymbol("ifndef")>\
      %if ( blockInterface.IsScalableBuild && ...
        !blockInterface.AncestorAllocatesCoderDataGroups && ...
        !blk.MdlRefIsCPPClassGenMode)
        #define %<blockInterface.HideChildDefineSymbol>
      %endif
      %if blockInterface.AncestorAllocatesCoderDataGroups || ...
        !( blk.MdlRefIsCPPClassGenMode && ...
             (blockInterface.IsScalableBuild || ConfigSet.UseOperatorNewForModelRefRegistration) )
        #include "%<name>.h"
      %endif
      %<GetHideChildDefineSymbol("endif")>\
      %if !ISEMPTY(condition)
        #endif /* %<condition> */
      %endif
    %endforeach
    %closefile sysheader
    %<LibAddToSystemField(system, "SystemIncludes", sysheader)>
  %endif
%endfunction %% LibCacheSystemIncludes

%% Function: LibCacheUtilityIncludes ============================================
%% Abstract:
%%   Goes through each system, and caches the include of any utilities
%%   that will be parented by the system.
%%   Called in *wide.tlc.
%%
%function LibCacheUtilityIncludes(sysIdx) void
  %% Cache necessary includes
  %assign system = System[sysIdx]
  %if (system.FileNameOwnerIdx == sysIdx)
    %openfile utilheader
    %assign rtwModule = RTWCGModules.RTWCGModule[system.CGIRModuleIdx]
    %assign headers = rtwModule.FcnHeaders
    %assign numHeaders = SIZE(headers, 0)
    %foreach idx = numHeaders
      %assign headerIdx = headers[idx][0]
      %assign incFileName = ::CompiledModel.RTWCGStrings[headerIdx]
      %assign moduleFileTypeIdx = headers[idx][1]
      %<FcnAppendSystemFcnHeaders(system, incFileName, moduleFileTypeIdx)>
    %endforeach
    %closefile utilheader
  %endif
%endfunction %% LibCacheSystemIncludes

%% Function: LibCacheSharedTypeIncludes ============================================
%% Abstract:
%%  For a particular system, only if it's an RLS, cache the includes for
%%  the shared data types it uses.
%%
%function LibCacheSharedTypeIncludes(sysIdx) void
  %% Cache necessary includes
  %assign system = System[sysIdx]
  %openfile sysheader
    %if LibSystemIsReusedLibraryFcn(system)
    #include "%<SLibCoderTypesFilename()>"
  %if system.DumpZCInclude
    #include "%<SLibCoderZerocrossingTypesFilename()>"
  %endif
  %endif
  %if SLibUsedMultiwordTypes()
    %assign multiwordFileName = SLibCoderMultiwordTypesFilename()
    %if LibSystemIsReusedLibraryFcn(system)
      %assign rtwCtx = ::CompiledModel.RTWContext
      %assign isMultiword = SLibIsHostBasedSimulationTarget() ? ...
        TLC_TRUE : ...
        FEVAL("rtwprivate", "retrieveMultiWordUtilitiesAndFunctions", "%<LocalSharedCodeManagerFile>", rtwCtx, system.SystemFileName)
      %if isMultiword
        #include "%<multiwordFileName>"
      %endif
    %else
      #include "%<multiwordFileName>"
    %endif
  %endif
  %if SLibUsedModelReferenceTypes() && ...
    ::tMdlRefTimingBridgeAccessed && ...
    (LibSystemIsRoot(system) || ...
    IsModelReferenceBaseSys(system))
    #include "%<SLibCoderModelReferenceTypesFilename()>"
  %endif
  %if LibSystemIsReusedLibraryFcn(system) || LibIsGlobalServer(system)
    %if ISFIELD(system, "IncludedSharedDataTypes")
       %foreach idx = SIZE(system.IncludedSharedDataTypes,1)
          #include %<system.IncludedSharedDataTypes[idx]>
       %endforeach
    %endif 
  %endif
  %closefile sysheader
  %<LibAddToSystemField(system, "SharedTypeIncludes", sysheader)>
%endfunction %% LibCacheSharedTypeIncludes

%% Function: LibDumpSystemIncludes =============================================
%% Abstract:
%%   Dumps headers(C)/specifications(Ada) of the systems non-inlined 
%%   children systems.  
%%
%function LibDumpSystemIncludes(system) void
  %assign systemIncludes = LibGetSystemField(system, "SystemIncludes")
  %if !WHITE_SPACE(systemIncludes)
    %openfile sysIncludeBuffer
    
    /* Child system includes */
    %<systemIncludes>
    %closefile sysIncludeBuffer
    %return sysIncludeBuffer
  %else
    %return ""
  %endif
%endfunction %% LibDumpSystemIncludes

%function LibCacheSharedDataIncludes(sysIdx) void
  %% Cache necessary includes
  %assign system = System[sysIdx]
  %if LibSystemIsReusedLibraryFcn(system)
    %openfile sysheader
    
    %if ISFIELD(system, "SystemSharedDataIncludes")
       %foreach idx = SIZE(system.SystemSharedDataIncludes,1)
          %assign sharedDataHeader = system.SystemSharedDataIncludes[idx]
          #include %<sharedDataHeader>
       %endforeach
    %endif 
    %closefile sysheader
    %<LibAddToSystemField(system, "SystemSharedDataIncludes", sysheader)>
  %endif
%endfunction

%function LibDumpSharedDataIncludes(system) void
  %assign sharedDataIncludes = LibGetSystemField(system, "SystemSharedDataIncludes")
  %if !WHITE_SPACE(sharedDataIncludes)
    %openfile sharedDataIncludeBuffer
    
    /* Shared Data Includes */
    %<sharedDataIncludes>
    
    %closefile sharedDataIncludeBuffer
    %return sharedDataIncludeBuffer
  %else
    %return ""
  %endif
%endfunction

%% Function: LibDumpSharedTypeIncludes =============================================
%% Abstract:
%%   Dumps headers of shared types used by a system.
%%
%function LibDumpSharedTypeIncludes(system) void
  %assign sharedTypeIncludes = LibGetSystemField(system, "SharedTypeIncludes")
  %if !WHITE_SPACE(sharedTypeIncludes)
    %openfile sharedTypeIncludeBuffer
    
    /* Shared type includes */
    %<sharedTypeIncludes>
    
    %closefile sharedTypeIncludeBuffer
    %return sharedTypeIncludeBuffer
  %else
    %return ""
  %endif
%endfunction %% LibDumpSharedTypeIncludes

%% Function: LibDumpSystemTypeDefs =============================================
%% Abstract:
%%   Dump systems type definitions.
%%
%function LibDumpSystemTypeDefs(system) void
  %assign systemTypeDefs = LibGetSystemField(system, "SystemTypeDefs")
  %if !WHITE_SPACE(systemTypeDefs)
    %openfile sysTypeDefBuffer
    
    /* Type definitions */
    %<systemTypeDefs>
    %closefile sysTypeDefBuffer
    %return sysTypeDefBuffer
  %else
    %return ""
  %endif
%endfunction


%% Function: LibDumpSystemFcnPrototype =========================================
%% Abstract:
%%   This function return the function prototype definition for a non-inlined
%%   system
%%
%function LibDumpSystemFcnPrototype(system) void
  %assign tmpFcnBuffer = ""
  %if !WHITE_SPACE(LibGetSystemField(system, "SystemFcnPrototype"))
    %openfile tmpFcnBuffer
    %if IsModelReferenceBaseSys(system)
      %<GetHideChildDefineSymbol("ifndef")>\
    %endif
    %<LibDumpSystemPrototype(system)>\
    %if IsModelReferenceBaseSys(system)
      %<GetHideChildDefineSymbol("endif")>\
    %endif
    %closefile tmpFcnBuffer
  %endif
  %return tmpFcnBuffer  
%endfunction %% LibDumpSystemFcnPrototype

%% Function: LibDumpSystemBanner ===============================================
%% Abstract:
%%   This function return the banner of a non-inlined system
%%
%function LibDumpSystemBanner(system) void
  %assign bannerBuf = ""
  %assign sysInfo = GetSystemNameForComments(system)
  %openfile bannerBuf
  /*
  * Code generation for system %<sysInfo>
  * For more details, see corresponding source file %<system.SystemFileName>.c 
  *
  */
  %closefile bannerBuf
  %return bannerBuf
%endfunction %% LibDumpSystemBanner

%% Function: SLibFcnPrototypeToRec ================================================
%% Abstract:
%%   Convert function declaration strings to a fcuntion record 
%%   fcnRec { Name, Params, Returns}
%%   It will be %undef at the call site
%%
%function SLibFcnPrototypeToRec(fcnDecl)
  %assign fcnRec = FEVAL("rtwprivate", "rtw_getFcnRecFromDecl", fcnDecl)
  %return fcnRec
%endfunction %% SLibFcnPrototypeToRec
  
%% Function: SLibDumpFunctionBanner ===============================================
%% Abstract:
%%   This function return the banner of a generated function
%%   Input fcnRec is a struct with at least following fields:
%%      Name: function Name
%%      Returns: function return type
%%      Params: function parameters
%%      Type: function time, e.g. Output, Update, OutputUpdate
%%
%function SLibDumpFunctionBanner(fcnRec) void
  %assign cs = ::CompiledModel.ConfigSet
  %% Do not generate any comments if GenerateComments is off 
  %if !cs.GenerateComments
    %return SLibGetNamespace(fcnRec.Name)
  %endif
  %assign ModelName = LibGetModelName()
  %assign IsSharedUtility = GenUtilsSrcInSharedLocation && ...
    ISEQUAL(fcnRec.Category, "utility")
  
  %assign BlockDescription = ""
  %assign BlockDescriptionContent = ""
  %if ISFIELD(fcnRec, "BlockDescription")
    %assign BlockDescription = fcnRec.BlockDescription
    %if !ISEMPTY(BlockDescription)
      %assign BlockDescriptionContent = FEVAL("rtwprivate", ...
        "rtw_format_banner", "getBlockDescriptionContent", BlockDescription)
    %endif
  %endif
  %%
  %% Generate a default format banner if either
  %%   1. Non ERT target; or 
  %%   2. there is no function_banner_template.tlc for member functions
  %%   3. there is no function_banner_template_sharedutility.tlc for shared utility
  %%
  %if IsSharedUtility
    %if GenerateDefaultFcnBannerSharedUtil == 0
      %% Initialize GenerateDefaultFcnBannerSharedUtil cache
      %if !SLibIsERTTarget() || !FILE_EXISTS("function_banner_template_sharedutility.tlc")
        %assign ::GenerateDefaultFcnBannerSharedUtil = 1
      %else
        %assign ::GenerateDefaultFcnBannerSharedUtil = 2
      %endif
    %endif 
  %else
    %if GenerateDefaultFcnBanner == 0
      %% Initialize GenerateDefaultFcnBanner cache
      %if !SLibIsERTTarget() || !FILE_EXISTS("function_banner_template.tlc")
        %assign ::GenerateDefaultFcnBanner = 1
      %else
        %assign ::GenerateDefaultFcnBanner = 2
      %endif
    %endif
  %endif  
  
  %if (!IsSharedUtility && GenerateDefaultFcnBanner == 1) || ...
    (IsSharedUtility && GenerateDefaultFcnBannerSharedUtil == 1)
    %assign FunctionDescription = FEVAL("rtwprivate", "rtw_format_banner", "formatFcnDescription",...
      fcnRec.Abstract, 0, 0)
    %assign bannerBuf = FunctionDescription + "\n" + BlockDescription
    %assign bannerBuf = FEVAL("rtwprivate", "rtw_format_banner", "formatBanner", ...
      bannerBuf, "classic", 0)

    %assign nameSpaceDecl = SLibGetNamespace(fcnRec.Name)
    %assign bannerBuf = nameSpaceDecl + bannerBuf
        
    %return bannerBuf
  %endif  

  %%
  %% Generatec customized function banner
  %%
  %if ISFIELD(fcnRec, "GeneratedFor")
    %assign GeneratedFor = "%<fcnRec.GeneratedFor>"
  %else
    %assign GeneratedFor = ""
    %if ISEQUAL(fcnRec.Category, "model")
      %% note: subsystem build may report wrong <root> as a temp model is created.
      %assign GeneratedFor = "'<Root>'"
    %endif
  %endif
   
  %if TYPE(fcnRec.Params) == "Vector" && SIZE(fcnRec.Params, 1) > 1
    %assign fcnParams = ""
    %foreach idx = SIZE(fcnRec.Params, 1)
      %assign fcnParams = "%<fcnParams>%<fcnRec.Params[idx]>"
    %endforeach
    %assign fcnRec.Params = "%<fcnParams>"
  %endif
  %assign rawArguments = fcnRec.Params
  %assign rawFcnDescription = fcnRec.Abstract
  %assign rawReturnType = fcnRec.Returns
  %assign FunctionName = fcnRec.Name
  %% CPP constructor and desctructor have no return type
  %if ISEQUAL(fcnRec.Category, "cpp") && ISFIELD(fcnRec, "Type") && ...
    (ISEQUAL(fcnRec.Type, "C++ constructor") || ISEQUAL(fcnRec.Type, "C++ destructor"))    
    %assign isCppStructor = TLC_TRUE
  %else
    %assign isCppStructor = TLC_FALSE
  %endif
  %assign GeneratedBy = fcnRec.GeneratedBy  
  %if IsSharedUtility
    %include "function_banner_template_sharedutility.tlc"
  %else
    %include "function_banner_template.tlc"
  %endif
  
  %assign nameSpaceDecl = SLibGetNamespace(fcnRec.Name)
  %assign bannerBuf = nameSpaceDecl + bannerBuf
      
  %return bannerBuf  
%endfunction %% SLibDumpFunctionBanner

%function SLibGetNamespace(fName) void
  %assign nameSpaceDecl = ""
  %assign className = ""
  %if GenerateClassInterface
    %assign classConfObj = FcnGetRTWCPPStepPrototypeRecord()
    %assign className = classConfObj.ModelClassName
  %endif
   
  %%all the system functions come in with a fName without classname prefix even if it is a member function
  %%they are process in commonbodlib.tlc (line 2102)
  %%so if the fName here has a classname prefix, it is memember functions in model.cpp
  %if className != ""   
    %if !ISEMPTY(FEVAL("strfind", fName, "%<className>::")) && ...
      (System[NumSystems-1].SystemNamespaceFlag == 0) && ...
      EXISTS(::NamespaceName) && (::NamespaceName != "")
      %assign nameSpaceDecl = "namespace %<::NamespaceName>" + "\n"+ "{" + "\n"
      %assign System[NumSystems-1].SystemNamespaceFlag = 1
    %endif
  %endif    
  
  %return nameSpaceDecl
%endfunction

%% Function: LibDumpSystemHeader ===============================================
%% Abstract: 
%%   Dump required details in the Systems header file. (does not include 
%%   "root").
%%     - #include for children systems
%%     - Functionprototype for the system
%%   This function is called from srthdr.tlc
%%
%%   NOTE: 
%% 	   We have included the main system header file here, this has to be 
%% 	   removed once we have split the vectors (Parameters, BIO, etc) and 
%% 	   put them in corresponding system header file.
%%
%function LibDumpSystemHeader(system) void
  %if system.FileNameOwnerIdx == system.SystemIdx
    %assign fileName  = SLibGetSystemHeaderFileName(system)
    %% Subsystem prototypes
    %openfile fcnBuff
    %<LibDumpSystemFcnPrototype(system)>
    %closefile fcnBuff
    %assign rootSysFileName = GetRootSystemFileName()
    
    %assert(system.SystemFileName != rootSysFileName)
    
    %assign duplicate = LibAddToModelHeaders(fileName)
    %% Dump comments, only the first time
    %assign bannerBuf = LibDumpSystemBanner(system)
    %<LibRegCommonIncludes(system.SystemIdx)>
    %assign includeBuf = SLibDumpCommonIncludes(system)
    %<SLibCacheSystemCodeToFile("sys_hdr_ban", system, bannerBuf)>
    %if IsModelReferenceBaseSys(system) && IsModelRefScalableBuild()
      %if LibIsSystemField(system, "MRSystemFcnPrototype")
        %% Make sure the system has some non-empty functions which need a
        %% prototype. Registration (mr_mdl_initialize) function and RegMdlInfo
        %% functions are handled separately and not included in this buffer.
        %assign mrFcnBuff = LibGetSystemField(system, "MRSystemFcnPrototype")
        %if !WHITE_SPACE(mrFcnBuff) && !GenerateClassInterface
          %<SLibCacheSystemCodeToFile("sys_fcn_prototype", ...
            system, mrFcnBuff)>
        %endif
      %endif
    %endif
    %if !(IsModelReferenceBaseSys(system) && GenerateClassInterface)
      %<SLibCacheSystemCodeToFile("sys_fcn_decl", system, fcnBuff)>
    %endif
    %%if !WHITE_SPACE(includeBuf)
      %<SLibCacheSystemCodeToFile("sys_hdr_incl", system, includeBuf)>
    %%endif
    %% Include the types header file
    %if !LibSystemIsReusedLibraryFcn(system) && !LibIsGlobalServer(system)
      %assign mdlTypesHdrFileName = SLibGetFileNameForCode("mdl_types_hdr")
      %if !WHITE_SPACE(mdlTypesHdrFileName)
        %openfile typesIncludeBuf
        #include "%<mdlTypesHdrFileName>.h"  
        %closefile typesIncludeBuf
        %<SLibCacheSystemCodeToFile("sys_hdr_incl", system, typesIncludeBuf)>
      %endif
    %endif   
    %<SLibCacheSystemCodeToFile("sys_hdr_incl", system, LibDumpSharedTypeIncludes(system))>
    %<SLibCacheSystemCodeToFile("sys_hdr_incl", system, LibDumpSystemIncludes(system))>
    
    %% Intrinsic types
    %% Primitive types
    %<SLibCacheSystemCodeToFile("sys_primitive_typedef", system, ...
      SLibDeclarePrimitiveTypedefs())>
  %endif
%endfunction %%  LibDumpSystemHeader
  
%% Function: LibDeclareCompoundDataTypes =======================================
%% Abstract:
%%   Reserved for compound data types.
%%
%function LibDeclareCompoundDataTypes() void
  %return ""
%endfunction


%% Function: LibDeclareMemoryAllocationMacros ==================================
%% Abstract:
%%   Place in model.h the following macros.
%%
%function LibDeclareMemoryAllocationMacros() void
  %assign nulldef = SLibGetNullDefinitionFromTfl()
  %openfile tmpFcnBuf
  %%
  %% rt_VALIDATE_MEMORY can only be used in the registration function.
  %%
  %if CodeFormat != "S-Function"
  #if !defined(rt_VALIDATE_MEMORY)
  #define rt_VALIDATE_MEMORY(S, ptr) \
  %else
  #if !defined(ss_VALIDATE_MEMORY)
  #define ss_VALIDATE_MEMORY(S, ptr) \  
  %endif
  if(!(ptr)) {%<"\\">
  %<RTMSetErrStat("RT_MEMORY_ALLOCATION_ERROR")>;%<"\\">
  %<"}">
  #endif
  
  #if !defined(rt_FREE)
  #if !defined(_WIN32)
  #define rt_FREE(ptr) \
  if((ptr) != %<nulldef>) {%<"\\">
  free((ptr));%<"\\">
  (ptr) = %<nulldef>;%<"\\">
  %<"}">
  #else
  /* Visual and other windows compilers declare free without const */
  #define rt_FREE(ptr) \
  if((ptr) != %<nulldef>) {%<"\\">
  free((void *)(ptr));%<"\\">
  (ptr) = %<nulldef>;%<"\\">
  %<"}">
  #endif
  #endif
  
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction



%% Function: LibCheckForValidMTaskDefine =======================================
%% Abstract:
%%   Add C directives to verify that the MULTITASKING define is correct for
%%   the way the code was generated. Prior to version 3.0 (R11), the
%%   MULTITASKING define was under user control. As of version 3.0, the
%%   define now is controlled by Simulink based upon the Solver Mode
%%   fixed step setting.
%% 
%function LibCheckForValidMTaskDefine() void
  %openfile tmpFcnBuf
  %if ::CompiledModel.SolverType == "FixedStep"
    %if ::CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
      %assign str = "Model (%<::CompiledModel.Name>) was built \\\n" ...
	"in MultiTasking solver mode, however the MULTITASKING define \\\n" ...
	"is not present. Please verify that your template makefile is \\\n" ...
	"configured correctly."
      
      #if !defined(MULTITASKING) && !defined(NRT)
      #  error %<str>
      #endif
    %else
      %assign str = "Model (%<::CompiledModel.Name>) was built in \\\n" ...
	"SingleTasking solver mode, however the MULTITASKING define is " ...
	"\\\npresent. If you have multitasking (e.g. -DMT or " ...
	"-DMULTITASKING) \\\ndefined on the Code Generation page of Simulation " ...
	"parameter dialog, please \\\nremove it and on the Solver page, " ...
	"select solver mode \\\nMultiTasking. If the Simulation parameter " ...
	"dialog is configured \\\ncorrectly, please verify that your " ...
	"template makefile is \\\nconfigured correctly."
      
      #if defined(MULTITASKING)
      #  error %<str>
      #endif
    %endif
  %else
    %assign str = "Models using the variable step solvers cannot define " ...
      "MULTITASKING"
    
    #if defined(MULTITASKING)
    #  error %<str>
    #endif
  %endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction %% LibCheckForValidMTaskDefine


%function LibDeclareSystemRequirements() void
  %openfile tmpFcnBuf

  %if ISFIELD(::CompiledModel, "Requirements")
      /*-
       * Requirements for '<Root>': %<Name>
      %if ISFIELD(::CompiledModel.Requirements, "Requirements")
          %<::CompiledModel.Requirements.Requirements>
      %endif
      %if ISFIELD(::CompiledModel.Requirements, "InheritedRequirements")
          %<::CompiledModel.Requirements.InheritedRequirements>
      %endif
      */
  %endif

  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: LibDeclareSystemHierarchy =========================================
%% Abstract:
%%   Create the system hierarchy comment.
%%
%function LibDeclareSystemHierarchy() void
  %openfile tmpFcnBuf
  
  %% see if it is a right-click (subsystem) build.
  %assign parentName = ""
  %assign srcSubsysName = ""
  %if ISFIELD(::CompiledModel, "SubsystemPathForRightClickBuild")
    %assign parentName = ::CompiledModel.SubsystemPathForRightClickBuild
    %assign srcSubsysName = ::CompiledModel.SubsystemNameForRightClickBuild
  %endif
  /*-
   * The generated code includes comments that allow you to trace directly 
   * back to the appropriate location in the model.  The basic format
   * is <system>/block_name, where system is the system number (uniquely
   * assigned by Simulink) and block_name is the name of the block.
   *
  %if ISEMPTY(parentName)
   * Use the MATLAB hilite_system command to trace the generated code back
   * to the model.  For example,
   *
   * hilite_system('<S3>')    - opens system 3
   * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3
  %else
    %%
    %% Subsystem build
    %%
    %assign srcSubsys = parentName + "/" + srcSubsysName
   * Note that this particular code originates from a subsystem build,
   * and has its own system numbers different from the parent model.
   * Refer to the system hierarchy for this subsystem below, and use the
   * MATLAB hilite_system command to trace the generated code back
   * to the parent model.  For example,
   *
   * hilite_system('%<srcSubsys>')    - opens subsystem %<srcSubsys>
   * hilite_system('%<srcSubsys>/Kp') - opens and selects block Kp
  %endif
   *
   * Here is the system hierarchy for this model
   *
  %if ISEMPTY(parentName)
    * '<Root>' : '%<Name>'
  %else
    * '<Root>' : '%<parentName>'
  %endif
  %foreach sysIdx = NumSubsystems
    %assign id   = sysIdx+1
    %if ISEMPTY(parentName)
      %assign path = LibMangledPathName(Subsystem[sysIdx].Name)
    %else
      %% Subsystem build: Skip hidden subsystems in the temporary model.
      %assign sysName = SYSNAME(Subsystem[sysIdx].Name)
      %if ISEQUAL(sysName[0], "Root") && !ISEQUAL(sysName[1], srcSubsysName)
        %continue
      %endif
      %assign path = SLibMangledSubsystemPathName(parentName,...
                                                  Subsystem[sysIdx].Name)
    %endif
    %if id < 10
      * '<S%<id>>'   : '%<path>'
    %elseif id < 100
      * '<S%<id>>'  : '%<path>'
    %else
      * '<S%<id>>' : '%<path>'
    %endif
  %endforeach
   */
   %closefile tmpFcnBuf
   %return tmpFcnBuf
%endfunction


%% Function: LibDeclareReducedBlocks ===========================================
%% Abstract:
%%   Create the reduced blocks comment.
%%
%function LibDeclareReducedBlocks() void
  %if (!ShowEliminatedStatements)
    %return
  %endif
  
  %openfile tmpFcnBuf
  %with ReducedBlocks
  %if NumReducedBlocks > 0

    /*-
     * These blocks were eliminated from the model due to optimizations:
     *
    %foreach bIdx = NumReducedBlocks
      %assign b = Block[bIdx]
     * Block '%<b.Name>' : %<b.OptimizationInfo>
    %endforeach
     */
  %endif
  %endwith
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction


%% Function: LibDumpGroundExterns ==============================================
%% Abstract:
%%   Declare external references to ground variables
%%
%function LibDumpGroundExterns() void
  %openfile tmpFcnBuf
  %with DataTypes
    %assign qualifiers = SLibGetGroundQualifiers()          
    %foreach dtIdx = NumDataTypes
      %assign dt = DataType[dtIdx]      
      %% real ground
      %if dt.GroundReqInMemory
        %openfile declaration
        %if SLibAutosarCompilerAbstractionRequired()
          %<SLibAutosarCompilerAbstractionForDataDecl(TLC_TRUE, dt.Name, TLC_FALSE, TLC_FALSE, dt.GroundName, "DataGlobal")>;\
        %else
          %<qualifiers> %<dt.Name> %<dt.GroundName>;\
        %endif
	/* %<dt.Name> ground */
        %closefile declaration
        %<SLibApplyMemSecToDataDecl(declaration, ...
            "MemSecDataConstants", dt.GroundName)>\
      %endif
      %% complex ground
      %if dt.ComplexGroundReqInMemory
        %assign groundName = dt.ComplexGroundName
        %assign complexName = SLibGetContainerSLTypeComplexName(dt)
        %openfile declaration
	%<qualifiers> %<complexName> %<groundName>;\
	/* %<dt.Name> complex ground */
        %closefile declaration
        %<SLibApplyMemSecToDataDecl(declaration, ...
            "MemSecDataConstants", groundName)>\
      %endif
    %endforeach
  %endwith
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: LibDumpGroundDeclarations =========================================
%% Abstract:
%%   Declares global ground variables.
%%   Arguments:
%%     declareAsStatic: declare ground local or global for 1 and 0,
%%                      respectively.  That is, use "static" keyword if
%%                      declareAsStatic == 1.
%%
%function LibDumpGroundDeclarations(declareAsStatic) void
  %assign keyword = declareAsStatic ? "static" : ""
  %openfile tmpFcnBuffer
  %with DataTypes
    %assign qualifiers = SLibGetGroundQualifiers()    
    %foreach dtIdx = NumDataTypes
      %assign dt = DataType[dtIdx]    
      %% real ground
      %if dt.GroundReqInMemory
        %if !ISFIELD(dt, "GroundAlreadyDefined")
	  %assign name = dt.GroundName

          %openfile definition
          %if SLibAutosarCompilerAbstractionRequired()
            %<keyword> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_TRUE, dt.Name, TLC_FALSE, TLC_FALSE, name, "DataGlobal")> = %<LibGetGroundInitFromId(dtIdx)>;\
          %else
            %<keyword> %<qualifiers> %<dt.Name> %<name> = %<LibGetGroundInitFromId(dtIdx)>;\
          %endif
          /* %<dt.Name> ground */\
          %closefile definition
          %<SLibApplyMemSecToDataDefn(definition, ...
            "MemSecDataConstants", name)>\
          %% Guard against multiple definitions
          %addtorecord dt GroundAlreadyDefined TLC_TRUE
        %endif
      %endif
      %% complex ground
      %if dt.ComplexGroundReqInMemory
        %if !ISFIELD(dt, "CmplxGroundAlreadyDefined")
          %assign groundName = dt.ComplexGroundName
          %if ISFIELD(dt, "ContainerSLTypeIdx")
            %assign containerTypeIdx = dt.ContainerSLTypeIdx
            %assign complexName = LibGetDataTypeComplexNameFromId(containerTypeIdx)
          %else
            %assign complexName = dt.ComplexName
          %endif
          %openfile definition
          %if SLibAutosarCompilerAbstractionRequired()
            %<keyword> %<SLibAutosarCompilerAbstractionForDataDecl(TLC_TRUE, complexName, TLC_FALSE, TLC_FALSE, groundName, "DataGlobal")> = ...
              {%<dt.GroundValue>, %<dt.GroundValue>};\
          %else
            %<keyword> %<qualifiers> %<complexName> %<groundName> = ...
              {%<dt.GroundValue>, %<dt.GroundValue>};\
          %endif
          /* %<dt.Name> complex ground */\
          %closefile definition
          %<SLibApplyMemSecToDataDefn(definition, ...
            "MemSecDataConstants", groundName)>\
          %% Guard against multiple definitions
          %addtorecord dt CmplxGroundAlreadyDefined TLC_TRUE 
        %endif
      %endif
    %endforeach
  %endwith
  %closefile tmpFcnBuffer
  %if !WHITE_SPACE(tmpFcnBuffer)
    %return ("\n" + tmpFcnBuffer)
  %else
    %return ""
  %endif
%endfunction


%% Function: FcnCommonHeaderInfo ==============================================
%% Abstract:
%%   Output the comment header for generated code.
%%
%function FcnCommonHeaderInfo() void
  %openfile tmpFcnBuf
%if FEVAL("eval","~isempty(emit(coder.internal.watermark))") 
  %<FEVAL("eval","emit(coder.internal.watermark,'* ')")> 
  * 
%endif
  * Code generation for model "%<::CompiledModel.Name>".
  *
  * Model version              : %<ModelVersion>
  * Simulink Coder version : %<Version>
%if GenerateFullHeader
  * %<CorCPPForBuildLogsandComments()> source code generated on : %<TLC_TIME>
  %endif
%if ISFIELD(::CompiledModel, "CompiledWarningMsg")
  * Warning Messages           : %<CompiledWarningMsg>
%endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: SLibCodeGenSettings ===============================================
%% Abstract:
%%   Output comment on code generation configuration
%%
%function SLibCodeGenSettings() void
  %if !GenerateFullHeader || !IncludeCodeGenSettings
    %return ""
  %endif
  %openfile tmpFcnBuf

Target selection: %<ConfigSet.SystemTargetFile>
  %if !SLibIsERTTarget()
Note: GRT includes extra infrastructure and instrumentation for prototyping
  %endif
Embedded hardware selection: %<ConfigSet.ProdHWDeviceType>
  %if !%<ConfigSet.ProdEqTarget>
    %assign emulationHWComment = SLibEmulationHWComment()
    %if !ISEMPTY(emulationHWComment)
Emulation hardware selection: %<emulationHWComment>
    %endif
  %endif
  %% Include objective priorities in the comments
  %if ISEMPTY(ConfigCheckComments)
    %assign ::ConfigCheckComments = FEVAL(...
      "coder.internal.genConfigCheckReportComments", LibGetModelName())
  %endif
%<ConfigCheckComments>
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction

%% Function: SLibCommonHeaderInfo ==============================================
%% Abstract:
%%   Output the comment header for generated code.
%%
%function SLibCommonHeaderInfo() void
  %assign tmpbuf = FEVAL("rtwprivate", "rtw_format_banner", "insert_comment_prefix", SLibCodeGenSettings())
  %return FcnCommonHeaderInfo() + tmpbuf
%endfunction

%% DocFunction{Code Configuration Functions}: LibCommonHeaderInfo ====================
%% Abstract:
%%   Output the comment header for generated code.
%%
%function LibCommonHeaderInfo() void
  %return SLibCommonHeaderInfo()
%endfunction

%% Function: SLibCommonUtilHeaderInfo() ========================================
%% Abstract:
%%   Output comment on code generation configuration if it is not in shared
%%   directory.
%%
%function SLibCommonUtilHeaderInfo() void
  %assign str = FcnCommonHeaderInfo()
  %if !GenUtilsSrcInSharedLocation
    %assign tmpbuf = FEVAL("rtwprivate", "rtw_format_banner", "insert_comment_prefix", SLibCodeGenSettings())
    %assign str = str + tmpbuf
  %endif
  %return str
%endfunction

%% Function: SLibSystemBanner ==================================================
%% Abstract:
%%   Output the banner for a generated system
%%
%function SLibSystemBanner(system) void
  %assign sysInfo = GetSystemNameForComments(system)

  %openfile tmpFcnBuf
  * Code generation for system %<sysInfo>
  *
  * Model                      : %<::CompiledModel.Name>
  * Model version              : %<ModelVersion>
  * Simulink Coder version : %<Version>
%if GenerateFullHeader
  * %<CorCPPForBuildLogsandComments()> source code generated on : %<TLC_TIME>
  %endif
  %closefile tmpFcnBuf
  %return tmpFcnBuf
%endfunction %% SLibSystemBanner


%% Function: SLibGetSystemOutputFileBaseName ===================================
%% Abstract:
%%    return base file name.
%function SLibGetSystemOutputFileBaseName(system) void
  %if (system.Type == "root")
    %return LibGetMdlSrcBaseName()
  %else
    %if (CodeFormat == "S-Function") && ...
      (system.SystemFileName == LibGetModelName())
      %return LibGetMdlSrcBaseName()
    %else
      %return system.SystemFileName
    %endif
  %endif
%endfunction

%% Function: SLibGetSystemOutputFileName =======================================
%%
%% Abstract:
%%    Convert a "base" filename to an appropriate output filename depending on
%%    the language for which we are generating code.
%%
%function SLibGetSystemOutputFileName(system) void
  %assign baseFileName = system.SystemFileName
  %assign baseFile     = baseFileName + "." + ::LangFileExt
  %return(baseFile)
%endfunction %% SLibGetSystemOutputFileName

%% Function: SLibGetSystemHeaderFileName =======================================
%%
%% Abstract:
%%    Convert a "base" filename to an appropriate header filename depending on
%%    the language for which we are generating code.
%%
%function SLibGetSystemHeaderFileName(system) void
  %assign baseFileName = system.SystemFileName
  %return("%<baseFileName>.h")
%endfunction %% SLibGetSystemHeaderFileName


%% Function: LibAddToModelHeaders ==============================================
%% Abstract:
%%      Add a file name to the list of headers needed to build this model
%%      Returns 1 if the filename passed in was a duplicate (i.e. it was
%%      already in the headers list) and 0 if it was not a duplicate.
%%
%function LibAddToModelHeaders(newFile) void
  %assign duplicate = 0
  %% scan for duplicates
  %if ::CompiledModel.NumHeaders > 0
    %foreach idx = ::CompiledModel.NumHeaders
      %if (::CompiledModel.Headers[idx] == "%<newFile>")
	%assign duplicate = 1
	%break
      %endif
    %endforeach
    %if (!duplicate)
      %assign ::CompiledModel.Headers = ::CompiledModel.Headers + "%<newFile>"
      %assign ::CompiledModel.NumHeaders = ::CompiledModel.NumHeaders + 1
    %endif
  %else
    %assign ::CompiledModel.Headers    = ::CompiledModel.Headers + "%<newFile>"
    %assign ::CompiledModel.NumHeaders = 1
  %endif
  %return (duplicate)
%endfunction %% LibAddToModelHeaders

%% Function: SLibIncludeRTWGeneratedChildSysExportFile =========================
%% Abstract:
%%   Include child s-function export files to model export file.
%%
%function SLibIncludeRTWGeneratedChildSysExportFile() void
  %if ISFIELD(::CompiledModel, "RTWGeneratedChildSfcnExportFiles")
    %openfile includesBuf
    %assign expFiles = ::CompiledModel.RTWGeneratedChildSfcnExportFiles
    %<expFiles>          
    %if CodeFormat == "S-Function"
      %assign tmpName = Accelerator ? "simulink_only_sfcn" : Name
      #undef S_FUNCTION_NAME
      
      #define S_FUNCTION_NAME %<tmpName>
    %endif
    %closefile includesBuf
    %<SLibCacheCodeToFile("mdl_src_incl", includesBuf)>
  %endif
%endfunction %% SLibIncludeRTWGeneratedChildSysExportFile

%% Function: SLibDumpStructDefWithAlignment =========================
%% Abstract:
%%   Dump the defition of a struct type with alignment directive, if 
%% applicable.
%%
%function SLibDumpStructDefWithAlignment(idTag, id, align, memBuf) void
  %if ISEMPTY(id)
    %assert !(ISEMPTY(idTag) || WHITE_SPACE(idTag))
    %assign typedef = ""
  %else
    %assign typedef = "typedef"
  %endif
  
  %openfile structdef
  
  %assign aSyntax = "" 
  %if structDAFlag.supported && align > 0
    %assign aSyntax = SLibGetAlignmentSyntax(::CompiledModel.Name, id, "", ...
                                             align, "DATA_ALIGNMENT_WHOLE_STRUCT")
  %endif
  
  %if !ISEMPTY(aSyntax) %% start of struct definition
    %if structDAFlag.position == "DATA_ALIGNMENT_PREDIRECTIVE"
      %<typedef> %<aSyntax> struct %<idTag>\
    %elseif structDAFlag.position == "DATA_ALIGNMENT_PRECEDING_STATEMENT"
      %<aSyntax>
      %<typedef> struct %<idTag>\
    %else
      %<typedef> struct %<idTag>\
    %endif
  %else
     %<typedef> struct %<idTag>\
  %endif
  %if !WHITE_SPACE(memBuf)
  {
  %<memBuf>            %% struct memebers
  }\
  %endif
  %if !ISEMPTY(aSyntax) 
     %if structDAFlag.position == "DATA_ALIGNMENT_POSTDIRECTIVE" 
        %<id> %<aSyntax>;
     %elseif structDAFlag.position == "DATA_ALIGNMENT_FOLLOWING_STATEMENT"
        %<id>;
        %<aSyntax>
     %else 
        %<id>;
     %endif
  %else
    %<id>;
  %endif              %% end of struct definition
  
  %closefile structdef
  
  %return structdef
%endfunction

%assign ::UseParamIdentifierForSymbolicDim = TLC_FALSE

%% Function: SLibScalarCSCP ====================================================
%% Abstract:
%%   Return the identifier (symbol) for a scalar parameter (aParamIdx) with 
%%   custom storage class. The global switch ::UseParamIdentifierForSymbolicDim
%%   is used to optionally return the original workspace parameter identifier.
%%
%function SLibScalarCSCP(aParamIdx) void
  %if ::UseParamIdentifierForSymbolicDim
    %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[aParamIdx]
    %return LibGetRecordIdentifier(mdlParam)
  %else
    %% CSC scalar parameters should not be casted when used as symbolic dimension
    %assign preventCastForMacroAccess = TLC_TRUE
    %return SLibCGIR_CSCP(aParamIdx, preventCastForMacroAccess, 1, "", -1, "", 0)
  %endif
%endfunction

%% Function: SLibGenerateConstraint ============================================
%% Abstract:
%%   Generates an individual constraint (aConstraint) including comments and
%%   error message.
%%
%function SLibGenerateConstraint(aConstraint, aOp, aInvOp, aNatOp) Output
  %assign lhs = %<"\"" + aConstraint.lhs + "\"">
  %assign rhs = %<"\"" + aConstraint.rhs + "\"">
  %if aConstraint.NumGraphicalRefs > 0
    /* Constraint '%<lhs> %<aOp> %<rhs>' registered by:
    %foreach blkIdx = aConstraint.NumGraphicalRefs
      * %<SLibGrBlockCommentName(aConstraint.GraphicalRef[blkIdx])>
    %endforeach
    */
  %endif
  #if %<lhs> %<aInvOp> %<rhs>
  # error "The preprocessor definition '%<lhs>' must be %<aNatOp> '%<rhs>'"
  #endif
%endfunction

%% Function: SLibGenerateDivisionConstraint ====================================
%% Abstract:
%%   Generates an individual constraint (aConstraint) including comments and
%%   error message.
%%
%function SLibGenerateDivisionConstraint(aConstraint) Output
  %assign lhs = %<"\"" + aConstraint.lhs + "\"">
  %assign rhs = %<"\"" + aConstraint.rhs + "\"">  
  #if (%<rhs> == 0) || ((%<lhs> % %<rhs>) != 0)
  # error "The preprocessor definition '%<rhs>' must not be equal to zero and \
the division of '%<lhs>' by '%<rhs>' must not have a remainder."
  #endif
%endfunction

%% Function: SLibGenerateModuloConstraint ====================================
%% Abstract:
%%   Generates an individual constraint (aConstraint) including comments and
%%   error message.
%%
%function SLibGenerateModuloConstraint(aConstraint) Output
  %assign rhs = %<"\"" + aConstraint.rhs + "\"">
  #if (%<rhs> == 0)
  # error "The preprocessor definition '%<rhs>' must not be equal to zero, \
since it is used as the right hand side of a modulo operation."
  #endif
%endfunction

%% Function: SLibCachSymbolicDimensionConstraints ==============================
%% Abstract:
%%   Adds symbolic dimensions preprocessor constraints to model_types.h
%%
%function SLibCachSymbolicDimensionConstraints() void
  %with ::CompiledModel.SymbolicDimsConstraints
    %assign symbolicDimsConstraintsBuff = ""
    %openfile symbolicDimsConstraintsBuff
    %if 0 < NumModuloSymbolicDims
      
      /*
       * Constraints for modulo operations in dimension variants
       */
      %foreach cstrIdx = NumModuloSymbolicDims
        %assign divC = ModuloSymbolicDims[cstrIdx]
        %<SLibGenerateModuloConstraint(divC)>
      %endforeach          
    %endif
    %if 0 < NumDivisionSymbolicDims
      
      /*
       * Constraints for division operations in dimension variants
       */
      %foreach cstrIdx = NumDivisionSymbolicDims
        %assign divC = DivisionSymbolicDims[cstrIdx]
        %<SLibGenerateDivisionConstraint(divC)>
      %endforeach          
    %endif
    %if 0 < NumEquivalentSymbolicDims || 0 < NumGreaterThanSymbolicDims
      
      /*
       * Registered constraints for dimension variants
       */
      %foreach cstrIdx = NumEquivalentSymbolicDims
        %assign eqC = EquivalentSymbolicDims[cstrIdx]
        %<SLibGenerateConstraint(eqC,"==","!=","equal to")>
      %endforeach
      %foreach cstrIdx = NumGreaterThanSymbolicDims
        %assign gtC = GreaterThanSymbolicDims[cstrIdx]
        %<SLibGenerateConstraint(gtC,">","<=","greater than")>
      %endforeach
    %endif
    %closefile symbolicDimsConstraintsBuff
    %if !WHITE_SPACE(symbolicDimsConstraintsBuff)
      %<SLibCacheCodeToFile("data_simulink_variant_define", symbolicDimsConstraintsBuff)>
    %endif
  %endwith
%endfunction  

%endif %% _COMMONHDRLIB_

%% [EOF] commonhdrlib.tlc
