%% ============================================================================
%%
%% Abstract:
%%   This system file contains helper functions to create an
%%   S-Function wrapper for any target.
%%
%% Copyright 1994-2017 The MathWorks, Inc.
%%

%include "ertmdlreftiming.tlc"
%include "sfcnlib.tlc"
%include "ertfcnprotocontrol.tlc"

%% Function GetStorageClassEnumFromStr ========================================
%% Abstract:

%%      Get enum str from string dumped in .rtw file
%%
%function GetStorageClassEnumFromStr(sc)
  %assign retStr= "SS_RTW_STORAGE_AUTO"
  %switch sc
    %case "Auto"
      %assign retStr = "SS_RTW_STORAGE_AUTO"
      %break
    %case "ExportedGlobal"
      %assign retStr = "SS_RTW_STORAGE_EXPORTED_GLOBAL"
      %break
    %case "ImportedExtern"
      %assign retStr = "SS_RTW_STORAGE_IMPORTED_EXTERN"
      %break
    %case "ImportedExternPointer"
      %assign retStr = "SS_RTW_STORAGE_IMPORTED_EXTERN_POINTER"
      %break
    %case "Custom"
      %assign retStr = "SS_RTW_STORAGE_CUSTOM"
      %break
    %default
      %<LibReportFatalError("Unexpected storage class")>
  %endswitch
  %return retStr
%endfunction %% GetStorageClassEnumFromStr


%% Function AppendRTWStorageClassInfo =========================================
%% Abstract:
%%   Append info related to Storage class to the infoRec.
%%   port can be an input port or output port record.
%%
%function AppendRTWStorageClassInfo(infoRec, port)
  %assign id      = port.PropagatedRTWIdentifier
  %assign label   = port.PropagatedSignalLabel
  %assign stClass = port.PropagatedStorageClass
  %assign stType  = port.PropagatedStorageTypeQualifier
  %assign resSig  = port.ResolvedToSignalObject
  %assign t       = port.TestPoint

  %assign ssStClass = GetStorageClassEnumFromStr(stClass)
  %if t == "no"
    %assign tval = "0"
  %else
    %assign tval = "1"
  %endif

  %if id !=  ""
    %assign infoRec.HasIdentifier = TLC_TRUE
  %endif

  %if label !=  ""
    %assign infoRec.HasSignalLabel = TLC_TRUE
  %endif
  
  %if ssStClass != "Auto"
    %assign infoRec.HasStorageClass = TLC_TRUE
  %endif

  %if stType != ""
    %assign infoRec.HasTypeQualifier = TLC_TRUE
  %endif

  %if resSig == "embedded"
    %assign resSig = "1"
    %assign infoRec.HasResolved = TLC_TRUE
  %elseif resSig == "external"
    %assign resSig = "2"
    %assign infoRec.HasResolved = TLC_TRUE
  %else
    %assign resSig = "0"
  %endif
    
  %if tval != "0"
    %assign infoRec.HasTestPoint = TLC_TRUE
  %endif

  %assign comma = infoRec.comma
  %assign infoRec.RTWIdentifier = infoRec.RTWIdentifier + comma + "\"" + id + "\""
  %assign infoRec.SignalLabel = infoRec.SignalLabel + comma + "\"" + label + "\""
  %assign infoRec.StorageClass  = infoRec.StorageClass  + comma +        ssStClass
  %assign infoRec.StorageClassStr = infoRec.StorageClassStr + comma + stClass
  %assign infoRec.StorageTypeQualifier = infoRec.StorageTypeQualifier+ comma + "\"" + stType + "\""
  %assign infoRec.Resolved = infoRec.Resolved + comma + resSig
  %assign infoRec.TestPoint =     infoRec.TestPoint     + comma +        tval
  %assign infoRec.comma = ", "

  %return infoRec
%endfunction %% AppendRTWStorageClassInfo


%% Function GetModelrefPortRTWStorageInfo =====================================
%% Abstract:
%%     Create a record and return info related to Signal storage class
%%
%function GetModelrefPortRTWStorageInfo()
  %createrecord infoRec { \
    RTWIdentifier        ""; \
    SignalLabel          ""; \
    StorageClass         ""; \
    StorageClassStr      ""; \
    StorageTypeQualifier ""; \
    Resolved             ""; \
    TestPoint            ""; \
    HasIdentifier        TLC_FALSE;  \
    HasSignalLabel       TLC_FALSE;  \
    HasStorageClass      TLC_FALSE;  \
    HasTypeQualifier     TLC_FALSE;  \
    HasResolved          TLC_FALSE;  \
    HasTestPoint         TLC_FALSE;  \
    comma                ""          \
  }

  %with ExternalInputs
    %if NumExternalInputs > 0
      %foreach idx = NumExternalInputs
	%assign infoRec = AppendRTWStorageClassInfo(infoRec,ExternalInput[idx])
      %endforeach
    %endif
  %endwith

  %with ExternalOutputs
    %if NumExternalOutputs > 0
      %foreach idx = NumExternalOutputs
	%assign extOut  = ExternalOutput[idx]
	%assign infoRec = AppendRTWStorageClassInfo(infoRec,ExternalOutput[idx])
      %endforeach
    %endif
  %endwith

  %return infoRec
%endfunction %%GetModelrefPortRTWStorageInfo


%% Function MdlRefHasConstantOutput =========================================
%% Abstract:
%%     Return true if there are any output ports with a constant sample time
%%
%function MdlRefHasConstantOutput()
  
  %return (::CompiledModel.HasConstantOutput == "yes")
%endfunction %%MdlRefHasConstantOutput

%% Function MdlRefHasParameterRateOutput =========================================
%% Abstract:
%%     Return true if there are any output ports with a parameter sample time
%%
%function MdlRefHasParameterRateOutput()
  
  %return (::CompiledModel.HasParameterRateOutput == "yes")
%endfunction %%MdlRefHasParameterRateOutput

%% Function MdlRefHasInternalParameterRate ======================================
%% Abstract:
%%     Return true if there is any internal usage of a parameter sample time
%%
%function MdlRefHasInternalParameterRate()
  %return (::CompiledModel.HasInternalParameterRate == "yes")
%endfunction


%% Function MdlRefHasParameterRate ===========================================
%% Abstract:
%%     Return true if there is any usage of a parameter sample time
%%
%function MdlRefHasParameterRate()
  %return MdlRefHasInternalParameterRate() || MdlRefHasParameterRateOutput()
%endfunction


%% Function  MdlRefIsConstSampleBlock=========================================
%% Abstract:
%%       Return true if all block sample times are constant.
%function MdlRefIsConstSampleBlock()
  
  %return (::CompiledModel.IsModelConstant == "yes")
%endfunction %%MdlRefIsConstSampleBlock

%% Function  ===================================================================
%function MdlRefIsFcnCallBlock()
  %return (::CompiledModel.HasRootTriggerPort == "yes") && ...
    (::CompiledModel.RootTriggerType == "function-call")
%endfunction

%% Function  ===================================================================
%function MdlRefIsTriggerBlock()
  %return (::CompiledModel.HasRootTriggerPort == "yes") && ...
    (::CompiledModel.RootTriggerType != "function-call")
%endfunction

%% Function  ===================================================================
%function MdlRefIsAPERTriggeredBlock()
  %return (::CompiledModel.IsAPERRootTriggeredSystem == "yes")
%endfunction

%% Function  ===================================================================
%function MdlRefDisallowSampleTimeInheritance()
  %return (::CompiledModel.ModelRefTsInheritance == ...
    "DISALLOW_SAMPLE_TIME_INHERITANCE")
%endfunction

%function HasRootEnablePort()
  %return (::CompiledModel.HasRootEnablePort == "yes")
%endfunction

%% =============================================================================
%%
%function MdlRefIsVarStepMultiRate() void
  %return ( IsModelReferenceForASimstructBasedTarget() && ...
            SolverType == "VariableStep" && ...
	    LibIsContinuous(0) && NumSampleTimes > 1)
%endfunction

%% Function: DumpTimeConditioningCode =========================================
%% Abstract:
%%
%function DumpTimeConditioningCode() Output
  %if !SLibSingleTasking()
    {
      int_T localTid = 0;
      %foreach idx = NumSynchronousSampleTimes
	if (ssIsSampleHit(S, %<idx>, %<::CompiledModel.GlobalScope.tTID> )) {
	  %if Tid01Eq && ISEQUAL(idx,1)
	    localTid = 0;
	  %else
	    localTid = %<idx>;
	  %endif
	}
      %endforeach
      %<::CompiledModel.GlobalScope.tTID> = localTid;
    }
  %endif
%endfunction %% DumpTimeConditioningCode


%% Function: GenerateSFunctionOutputSignalDefinition ==========================
%% Abstract:
%%   This function generates the S-Function output signal definition for the
%%   mdlOutputs function.
%%
%% Syntax:
%%   GenerateSFunctionOutputSignalDefinition(prefix)
%%
%% Arguments:
%%   prefix - signal name prefix
%%
%% Returns:
%%   real_T *<prefix>_0 = ssGetOutputPortSignal(S, 0);
%%
%function GenerateSFunctionOutputSignalDefinition(prefix) Output
  %foreach idx = ExternalOutputs.NumExternalOutputs
    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx       = extOut.Block[0]
    %assign blkIdx       = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %with System[sysIdx]
    %with outportBlock
      %assign dataType  = LibBlockInputSignalDataTypeName(0, "")
      %<dataType> *%<prefix>%<idx> = ssGetOutputPortSignal(S, %<idx>);
    %endwith %% outportBlock
    %endwith %% System[sysIdx]
  %endforeach
%endfunction %% GenerateSFunctionOutputSignalDefinition

%% Function: GenerateConstOutputSignalConditioning ============================
%% Abstract:
%%   This function generates the necessary code to update outputs with conatant
%%   sample time.
%%
%function GenerateConstOutputSignalConditioning(rolllimit) Output
  %assign prefix       = "constY"

  %% Declare const outputs
  %foreach idx = ExternalOutputs.NumExternalOutputs
    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx       = extOut.Block[0]
    %assign blkIdx       = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %assign tid          = System[sysIdx].Block[blkIdx].TID
    %assign baseSysIdx   = NumSystems - 2

    %assert(sysIdx == NumSystems - 1)

    %if (TYPE(tid) == "Identifier" && tid == "constant")
      %with System[baseSysIdx]
	%with outportBlock
	  %assign dataType  = LibBlockInputSignalDataTypeName(0,"")
	  %<dataType> *%<prefix>%<idx> = (%<dataType> *) ...
	    ssGetOutputPortSignal(S, %<idx>);
	%endwith %% outportBlock
      %endwith %% System[sysIdx]
    %endif
  %endforeach

  %% Initialize const output
  %foreach idx = ExternalOutputs.NumExternalOutputs
    %assign extOut       = ExternalOutputs.ExternalOutput[idx]
    %assign sysIdx       = extOut.Block[0]
    %assign blkIdx       = extOut.Block[1]
    %assign outportBlock = System[sysIdx].Block[blkIdx]
    %assign tid          = System[sysIdx].Block[blkIdx].TID
    %assign prefix       = "constY"

    %assert(sysIdx == NumSystems - 1)

    %if (TYPE(tid) == "Identifier" && tid == "constant")
      %with System[baseSysIdx]
	%with outportBlock
	  %assign portWidth = LibBlockInputSignalWidth(0)
	  %if portWidth == 1
	    %<prefix>%<idx>[0] = \
	    %<LibBlockInputSignal(0, "", "", 0)>;
	  %elseif portWidth < rolllimit
	    %foreach sigIdx = portWidth
	      %<prefix>%<idx>[%<sigIdx>] = \
	      %<LibBlockInputSignal(0, "", "", sigIdx)>;
	    %endforeach
	  %else %% portWidth > rolllimit
	    {
	      int i = 0;
	      for(i = 0; i < %<portWidth>; i++) {
		%<prefix>%<idx>[i] =  \
		%<LibBlockInputSignal(0, "i", "", 0)>;
	      }
	    }
	  %endif
	%endwith %% outportBlock
      %endwith %% System[sysIdx]
    %endif
  %endforeach
%endfunction %% GenerateConstOutputSignalConditioning

%% Function:  GetConstBIOExternBuf ============================================
%% Abstract:
%%
%function GetConstBIOExternBuf()
  %openfile extCBIOExtern
  %if !LibConstBlockIOInstanceIsEmpty()
    %assign qualifiers = SLibGetConstBlockIOQualifiers()
    extern %<qualifiers> %<FcnSysVarGroupType(System[NumSystems-2],"ConstBlockIO")>  %<::tConstBlockIOStruct>;
  %endif
  %closefile extCBIOExtern
  %return extCBIOExtern
%endfunction %% GetConstBIOExternBuf


%% Function:  GetConstPrmExternBuf ============================================
%% Abstract:
%%
%function GetConstPrmExternBuf()
  %openfile extCPrmExtern
  %if !SLibPrmBufferIsEmpty("Const", "Typedef")
    %assign qualifiers = SLibGetConstParamQualifiers()    
    /* Constant parameters (auto storage) */
    extern %<qualifiers> %<::tConstParamType> %<::tConstParamStruct>;
  %endif
  %closefile extCPrmExtern
  %return extCPrmExtern
%endfunction %% GetConstPrmExternBuf


%% Function:  GetConstPrmWithInitExternBuf =====================================
%% Abstract:
%%
%function GetConstPrmWithInitExternBuf()
  %openfile extCPrmExtern
  %if !SLibPrmBufferIsEmpty("ConstWithInit", "Typedef")
    %assign qualifiers = SLibGetConstParamWithInitQualifiers()
    
    /* Constant parameters with dynamic initialization (auto storage) */
    extern %<qualifiers> %<::tConstParamWithInitType> %<::tConstParamWithInitStruct>;
  %endif
  %closefile extCPrmExtern
  %return extCPrmExtern
%endfunction %% GetConstPrmWithInitExternBuf


%% Function: SLibWriteModelrefSFunctionMethods =================================
%% Abstract:
%%  Write out the model reference S-Function methods to a file.
%% TODO: Migrate the content of this function then clean it up. 
%function SLibWriteModelrefSFunctionMethods() void
  %assign sFunctionName = GetModelrefSFunctionName(Name)
  %assign opFile = SLibAddModelFile("SystemBody","Simulink", sFunctionName)
  %<SLibSetModelFileAttribute(opFile, "Group", "interface")>
  
  %assign cBIOExtBuf = GetConstBIOExternBuf()
  %<SLibCacheCodeToFile("mdlsfcn_extern_data_defn", cBIOExtBuf)>

  %% Generate code for each of the sfcn methods
  %openfile fcnsBuf
  %<WriteModelrefSFunctionVarDimsSetDimsMethods("SetDims")>
  %<WriteModelrefSFunctionVarDimsSetDimsMethods("FinalizeDims")>  
  %closefile fcnsBuf
  
  %<SLibCacheCodeToFile("mdlsfcn_fcn_defn", fcnsBuf)>
%endfunction

%% Function: ModelrefBlockNeedsDwork ===========================================
%% Abstract:
%function ModelrefBlockNeedsDwork() void
  %if NumSimulinkFunctions > 0
    %foreach groupIdx = NumSimulinkFunctions
      %with SimulinkFunction[groupIdx]
        %if (IsMultiInstance == "yes")
          %return TLC_TRUE
        %endif
      %endwith
    %endforeach
  %endif
  %if IsModelRefScalableBuild()
    %return TLC_FALSE
  %else
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %if (baseSystem.HasBlockIOArg || baseSystem.HasDWorkArg ...
      || !EmptyRealTimeObject || baseSystem.HasZCEventArg)
      %return TLC_TRUE
    %else
      %return TLC_FALSE
    %endif
  %endif
%endfunction %%ModelrefBlockNeedsDwork

%% Function: SLibDeclareModelReferenceVars =====================================
%% Abstract:
%%   For the given system, declare the global variables that are used.
%%   The function may be passed a string to prepend the declaration (such as 
%%   "extern")
%%
%function SLibDeclareModelReferenceVars(system, genMdlRefDWork, isModelRefScalableBuild, extern) void
  %openfile tmpbuf
  %if !genMdlRefDWork && isModelRefScalableBuild
    %if system.HasBlockIOArg
      /* Block signals (auto storage) */
      %<SLibDeclareStandaloneVarType(system, [], "BlockIO", extern)>
    %endif
    %if system.HasDWorkArg
      /* Block states (auto storage) */
      %<SLibDeclareStandaloneVarType(system, [], "DWork", extern)>
    %endif
    %if system.HasZCEventArg
      /* Previous zero-crossings (trigger) states */
      %<SLibDeclareStandaloneVarType(system, [], "ZCEvent", extern)>
    %endif
  %endif
  %% Emit declarations/definitions for all exported coder data groups, except 
  %% InSelf and InParent for multi-instance mdlref
  %createrecord groupFilter { \
      Static TLC_TRUE \
      Dynamic TLC_TRUE \
      Standalone TLC_TRUE \
      AccessThroughSelf (!genMdlRefDWork && isModelRefScalableBuild) \
      Exported TLC_TRUE \
      Imported TLC_FALSE \
      ModelData TLC_FALSE \
  }
  %<SLibDeclareCoderDataGroupInstances(system,extern,groupFilter)>
  %closefile tmpbuf
  %return tmpbuf
%endfunction  %% SLibDeclareStandaloneVars

%% Function: SLibGenerateSFcnDWork =============================================
%% Abstract:
%%  Generate dwork structure for the reference model
%%
%function SLibModelReferenceGenerateDWork() void
  %assert IsModelReferenceTarget()
  %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
  %assign genMdlRefDWork = ...
    ( !IsModelRefScalableBuild() || ::CompiledModel.GenSingleInstanceMdlRefDWork ) && ...
    !::CompiledModel.ModelRefSimpInterface

  %openfile dwBuf
  %if genMdlRefDWork && baseSystem.HasBlockIOArg && !SLibIsSelfInPluggableInterface()
    %<FcnSysVarGroupType(baseSystem,"BlockIO")> rtb;
  %endif
  %if genMdlRefDWork && baseSystem.HasDWorkArg && !SLibIsSelfInPluggableInterface()
    %<FcnSysVarGroupType(baseSystem,"DWork")> rtdw;
  %endif
  %if !EmptyRealTimeObject && !CompiledModel.ModelRefSimpInterface
    %<::tSimStructType> rtm;
  %endif
  %if genMdlRefDWork && baseSystem.HasZCEventArg
    %<FcnSysVarGroupType(baseSystem,"ZCEvent")> rtzce;
  %endif
  %closefile dwBuf
  
  %if !EmptyRealTimeObject && CompiledModel.ModelRefSimpInterface && !CompiledModel.OkToMultiInstanceModelref
    %%% If using simplfied interface, and in Modelref single-instance case, we still need to define the singleton RTM variable.
    %assign allocatedVarName = SLibGetSimStructAllocatedVarName()
    %assign refVarName = SLibGetSimStructReferenceVarName()
    %assign def = "%<::tSimStructType> %<allocatedVarName>;\n"
    %assign rtmDef = SLibGetQualifiedRTMType() + " *const %<refVarName> = &%<allocatedVarName>;"
    %assign def = def + rtmDef
    %openfile dWorkDefn
      %<SLibApplyMemSecToDataDefn(def, "MemSecDataInternal", "")>\
    %closefile dWorkDefn
    %<SLibCacheCodeToFile("data_DWork_defn", dWorkDefn)>
    %undef dWorkDefn
  %endif

  %if !WHITE_SPACE(dwBuf)
    %assign skipMdlRefDWorkTypedef = SLibIsSelfInPluggableInterface() && !IsModelReferenceSimTarget()
    %if !skipMdlRefDWorkTypedef
      %openfile dworkBuf
      %<GetHideChildDefineSymbol("ifndef")>\
      typedef struct {
        %<dwBuf>\

      } %<FcnGetSFcnDWorkType(baseSystem)>;
      %<GetHideChildDefineSymbol("endif")>\
      %closefile dworkBuf
      %<SLibCacheCodeToFile("data_DWork_typedef", dworkBuf)>
    %endif

    %if IsModelRefScalableBuild()
      %openfile dWorkDecl
      %<GetHideChildDefineSymbol("ifndef")>\
      extern %<FcnGetSFcnDWorkType(baseSystem)> %<FcnGetSFcnDWorkIdentifier(baseSystem)>;
      %<GetHideChildDefineSymbol("endif")>\
      %closefile dWorkDecl
      %<SLibCacheCodeToFile("data_DWork_decl", dWorkDecl)>
      
      %assert !GenerateClassInterface
      
      %assign def = "%<FcnGetSFcnDWorkType(baseSystem)> %<FcnGetSFcnDWorkIdentifier(baseSystem)>;"
      %openfile dWorkDefn
      %<SLibApplyMemSecToDataDefn(def, "MemSecDataInternal", "%<FcnGetSFcnDWorkIdentifier(baseSystem)>")>\
      %closefile dWorkDefn
      %<SLibCacheCodeToFile("data_DWork_defn", dWorkDefn)>
    %endif
  %endif
  %assign mdlRefVars = ...
     SLibDeclareModelReferenceVars(baseSystem, genMdlRefDWork, IsModelRefScalableBuild(), "extern")
  %if !WHITE_SPACE(mdlRefVars)
    %openfile dWorkDecl
    %<GetHideChildDefineSymbol("ifndef")>\
    %<mdlRefVars>
    %<GetHideChildDefineSymbol("endif")>\
    %closefile dWorkDecl
    %<SLibCacheCodeToFile("data_DWork_decl", dWorkDecl)>
    %<SLibCacheCodeToFile("data_DWork_defn", ...
      SLibDeclareModelReferenceVars(baseSystem, genMdlRefDWork, IsModelRefScalableBuild(), ""))>
  %endif
%endfunction

%function FcnGetSFcnDWorkIdentifier(system) void
  %if !IsModelReferenceSimTarget() && SLibIsSelfInPluggableInterface() && system.SystemIdx == GetBaseSystemIdx()
    %return "%<::CompiledModel.GlobalScope.tRTM>"
  %else
    %return "%<system.Interface.tsysMdlrefDWork>"
  %endif
%endfunction

%function FcnGetSFcnDWorkType(system) void
  %if !IsModelReferenceSimTarget() && SLibIsSelfInPluggableInterface() && system.SystemIdx == GetBaseSystemIdx()
    %return "%<tSimStructType>"
  %else
    %return "%<system.Interface.tsysMdlrefDWorkType>"
  %endif
%endfunction

%function FcnGetSFcnDWorkRTM() void
  %assert IsModelReferenceSimTarget() && SLibGetUseRTMcgType()
  %assign modelDW = FcnGetSFcnDWorkIdentifier(::CompiledModel.System[baseSystemIdx])
  %return modelDW + ".rtm"
%endfunction

%% Function: LibGetFcnInfo ====================================================
%% Abstract:
%%    Return fcnInfo record of the system.
%function LibGetFcnInfo(system, fcnType, tid) void
  %% Output may have been combined with update
  %if fcnType == "Output" && !ISFIELD(system,"OutputFcn") &&  ...
      !(ISFIELD(system,"OutputCalledInUpdate") &&  ...
      system.OutputCalledInUpdate == "yes")
    %assign fcnType = "OutputUpdate"
  %endif
  %if LibIsSingleRateSystem(system) && ...
    LibSystemIsReusedFcn(system) && ...
    !SLibNonInlinedModelWideEventTID(tid)
    %assign tid = FcnGetSubsystemCodeBufTID(system)
  %endif
  %if (SLibSystemFcnPeriodicRateGrouping(system, fcnType) || ...
    (LibAsynchronousTriggeredTID(tid)  && ...
    (fcnType == "Output" || fcnType == "Update" || ...
    fcnType == "OutputUpdate")))
      %assign tid = "TID%<tid>"
  %else
    %assign tid = ""
  %endif
  %assign fieldname = fcnType + "%<tid>FcnInfo"
  %if LibIsSystemField(system, fieldname)
    %assign fcnInfo = LibGetSystemField(system, fieldname)
  %else
    %assign fcnInfo = ""
  %endif
  %return fcnInfo
%endfunction

%% Function:  CreateModelrefSFunctionForTopSystem =================================
%% Abstract:
%%    Create ModelrefSFunction record for the hidden subsystem
%function CreateModelrefSFunctionForTopSystem() void

  %assert IsModelReferenceTarget()
  %% If we are generating an S-function, add cached variables for
  %% all the s-fcn entry points to the record ModelrefSFunction
  %assert ::CompiledModel.NumSystems > 1

  %addtorecord ::CompiledModel.System[NumSystems-2] ModelrefSFunction { ...
    CachedFcnCallInputBuffers ""; ...
    CachedInitializeSizesDeclarations ""; ...
    CachedInitializeSizesBody ""; ...
    CachedInitializeSampleTimesDeclarations ""; ...
    CachedInitializeSampleTimesBody ""; ...
    CachedInitializeConditionsDeclarations ""; ...
    CachedInitializeConditionsBody ""; ...
    CachedSystemInitializeDeclarations ""; ...
    CachedSystemInitializeBody ""; ...
    CachedSystemResetDeclarations ""; ...
    CachedSystemResetBody ""; ...
    CachedSetWorkWidthsDeclarations ""; ...
    CachedSetWorkWidthsBody ""; ...
    CachedProcessParametersDeclarations ""; ...
    CachedProcessParametersBody ""; ...
    CachedStartDeclarations ""; ...
    CachedStartBody ""; ...
    CachedEnableDeclarations ""; ...
    CachedEnableBody ""; ...
    CachedDisableDeclarations ""; ...
    CachedDisableBody ""; ...
    CachedOutputsDeclarations ""; ...
    CachedOutputsBody ""; ...
    CachedUpdateDeclarations ""; ...
    CachedUpdateBody ""; ...
    CachedZeroCrossingsDeclarations ""; ...
    CachedZeroCrossingsBody ""; ...
    CachedDerivativesDeclarations ""; ...
    CachedDerivativesBody ""; ...
    CachedProjectionDeclarations ""; ...
    CachedProjectionBody ""; ...
    CachedForcingFunctionDeclarations ""; ...
    CachedForcingFunctionBody ""; ...
    CachedMassMatrixDeclarations ""; ...
    CachedMassMatrixBody ""; ...
    CachedTerminateDeclarations ""; ...
    CachedTerminateBody ""...
  }
%endfunction


%% Function:  AppendZeroToString ===============================================
%% Abstract:
%%      Append the inStr with zero
%function AppendZeroToString(inStr, comma, num) void
  %foreach i = num
    %assign inStr =  "%<inStr>%<comma>0"
    %assign comma = ", "
  %endforeach
  %return inStr
%endfunction

%% Function FcnAppendToBlockInterface =========================================
%% Abstract:
%%    Helper function for FcnAppendToBlockInterface.
%function SLibGetModelRefFcnNames(thisSystem, blockFcn, fcnCallTaskName, ...
  currentTID, isPeriodicRateGrouping)
  
  %if ISEMPTY(fcnCallTaskName)
    %assign tlcFcn = ""
    %assign tlcFcnName = ""
    %assign sysFcnName = ""
    %if blockFcn == "Registration"
      %assert ISEMPTY(fcnCallTaskName)
      %assign sysFcnName = "%<blockFcn>Fcn"
      %if ::GenerateClassInterface
        %assign fcnName = "%<::CPPClassName>::initialize"
      %else
        %assign fcnName = GetModelRefRegistrationFcnName()
      %endif
      %assign tlcFcnName = []
    %else
      %assign fcnRecord = LibGetFcnInfo(thisSystem, blockFcn, currentTID)
      %assert (TYPE(fcnRecord) == "Scope")
      %assign fcnName = fcnRecord.Name
    
      %switch (blockFcn)
        %case "Output"
        %case "OutputUpdate"
          %assign tlcFcn = "Outputs"
          %break
        %case "SetupRuntimeResources"
          %assign tlcFcn = "SetupRuntimeResources"
          %break
        %case "Initialize"
          %assign tlcFcn = "InitializeConditions"
          %break
        %case "SystemInitialize"
          %assign tlcFcn = "SystemInitialize"
          %break
        %case "SystemReset"
          %assign tlcFcn = "SystemReset"
          %break
        %case "Derivative"
          %assign tlcFcn = "Derivatives"
          %break
        %case "ZeroCrossing"
          %assign tlcFcn = "ZeroCrossings"
          %break 
        %case "CleanupRuntimeResources"
          %assign tlcFcn = "CleanupRuntimeResources"
          %break
        %default
          %assign tlcFcn = blockFcn
          %break
      %endswitch
    
      %if !isPeriodicRateGrouping && ...
        !(SLibIsExportFcnDiagram() && SLibSystemFcnIsRateGroupType(blockFcn) && !ISEQUAL(currentTID,"")) && ...
        !LibSystemFcnIsEmpty(thisSystem, blockFcn)
        %assign sysFcnName = blockFcn + "Fcn"
        %assign tlcFcnName = tlcFcn + "_Function"
      %elseif !LibSystemFcnIsEmptyForTID(thisSystem, blockFcn)
        %assign sysFcnName = blockFcn + "TID%<thisSystem.CurrentTID>Fcn"
        %assign tlcFcnName = tlcFcn + "_FunctionTID%<thisSystem.CurrentTID>"
      %endif
    %endif
  %else
    %% For Fcn-call inputs, override the sysFcnName with the entry point 
    %% task name.
    %assign sysFcnName = fcnCallTaskName
    %assign fcnName = fcnCallTaskName
    %assign tlcFcnName = []
  %endif
  
  %assign retRec = ["%<sysFcnName>", "%<tlcFcnName>", "%<fcnName>"]
  %return retRec  
%endfunction

%% Function: SLibGetModelRefRootInputIdx =======================================
%% Abstract:
%%   Returns the root input port for a canonical input index
%%
%function SLibGetModelRefRootInputIdx(sysIdx, canInputIdx)
  %assign thisSystem = ::CompiledModel.System[sysIdx]
  %assign ci = thisSystem.Interface.CanonicalInputArgDef[canInputIdx].SignalSrc
  %assign idNum = IDNUM(ci[0])
  %assert (idNum[0] == "U" || idNum[0] == "M")
  %assign rootInputPortIdx = idNum[1]
  %return rootInputPortIdx
%endfunction %% SLibGetModelRefRootInputIdx

%% Function: SLibGetModelRefRootOutputIdx ======================================
%% Abstract:
%%   Returns the root input port for a canonical input index
%%
%function SLibGetModelRefRootOutputIdx(sysIdx, canOutputIdx)
  %assign thisSystem = ::CompiledModel.System[sysIdx]
  %return thisSystem.Interface.CanonicalOutputArgDef[canOutputIdx].RootOutputIdx
%endfunction %% SLibGetModelRefRootOutputIdx

%% Function: CreateModelReferenceFcnRec ========================================
%% Abstract:
%%    Helper function for FcnAppendToBlockInterface
%function CreateModelReferenceFcnRec(sysIdx, blockFcn, sysFcnName, tid, blkInterface, useSysFcnName) void
  %assign thisSystem = ::CompiledModel.System[sysIdx]
  %assign modIdx = thisSystem.CGIRModuleIdx
  %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
  %assign hasSimplifiedInterface = thisModule.SimplifiedInterface
  %assign thisSystem.CurrentTID = tid
  %assign currentTID     = tid
  
  %assign isPeriodicRateGrouping = SLibSystemFcnPeriodicRateGrouping(thisSystem, blockFcn) || ...
    (SLibSystemFcnIsRateGroupType(blockFcn) && SLibIsModelRefAsyncTID(tid))
  
  %assign isWritable = !ISEMPTY(blkInterface)
  
  %if isWritable && !ISFIELD(blkInterface, "NumBlockFcns")
    %addtorecord blkInterface NumBlockFcns 0
  %endif
  
  %if(useSysFcnName)
    %assign keyFcnName = sysFcnName
  %else
    %assign keyFcnName = blockFcn
  %endif

  
  %% LibSystemFcnIsEmpty has side affect. (When output is passed,
  %% it may check for OutputUpdate!)
  %assign isRateGroupedAsync = RateGroupedAsyncFcns && FcnSysModuleIsRateGrouping(thisSystem,blockFcn)
  %if blockFcn != "Registration" && ...
    (!SLibIsModelRefAsyncTID(tid) || SLibNonInlinedModelWideEventTID(tid)) && ...
    !useSysFcnName && ...
    (!ISFIELD(thisSystem,"%<keyFcnName>Fcn") || ...
    ((SLibIsExportFcnDiagram() || isRateGroupedAsync) && LibSystemFcnIsEmptyForTID(thisSystem, keyFcnName)) || ...
    LibSystemFcnIsEmpty(thisSystem, keyFcnName))
    %createrecord retRec { \
    SysFcnName ""; \
    FcnRec     ""\
    }  
    %return retRec
  %endif
  
  %assign fcnNames = SLibGetModelRefFcnNames(thisSystem, blockFcn, ...
    sysFcnName, currentTID, isPeriodicRateGrouping)  

  %assign sysFcnName = fcnNames[0]
  %assign tlcFcnName = fcnNames[1]
  %assign fcnName = fcnNames[2]

  %% For Async code gen, we always track argument based on func names, keyFcnName.
  %% For all other rates, we track argument based on func type, which is blockFcn.
  %% The 2nd option is the rate grouping code path.
  %if SLibExplicitTaskingTID(tid) && ...
    (!SLibIsModelRefAsyncTID(tid) || SLibIsExportFcnDiagram() || RateGroupedAsyncFcns)
      %assign ::BlockFcn = blockFcn
  %else
    %assign ::BlockFcn = keyFcnName
  %endif

  %with thisSystem.Interface
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical input argument
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign  comma = ""
    %assign  inStr = ""
    %assign  inCounter = 0
    %assign  numInputs = ExternalInputs.NumExternalInputs
    %foreach argIdx = NumCanonicalInputArgDefs
      %assign idx = SLibGetModelRefRootInputIdx(sysIdx, argIdx)
      
      %% fill 0 for unused inputs
      %assign numZeroToAdd = idx - inCounter
      %if  numZeroToAdd > 0
	%assign inStr = AppendZeroToString(inStr, comma, numZeroToAdd)
	%assign comma = ", "
      %endif
      %assign inCounter = idx
      
      %if FcnArgNeeded(CanonicalInputArgDef[argIdx],currentTID,isPeriodicRateGrouping)
	%if CanonicalInputArgDef[argIdx].DeclareAsPointer == "yes"
	  %assign inStr = "%<inStr>%<comma>2"
	%else
	  %assign inStr = "%<inStr>%<comma>1"
	%endif
      %else
	%assign inStr = "%<inStr>%<comma>0"
      %endif
      %assign comma = ", "
      %assign inCounter = inCounter + 1
    %endforeach

    %assign numZeroToAdd = numInputs - inCounter
    %if  numZeroToAdd > 0
      %assign inStr = AppendZeroToString(inStr, comma, numZeroToAdd)
      %assign comma = ", "
    %endif
    %assign inCounter = numInputs
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical dimsize dwork argument for input
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign inDWStr = GetBlockInputCanDimSizeDWInterface(sysIdx, blockFcn, tid)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical output argument
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign comma  = ""
    %assign outStr = ""
    %assign outCounter = 0
    %assign  numOutputs = ExternalOutputs.NumExternalOutputs
    %foreach argIdx = NumCanonicalOutputArgDefs
      %assign idx = SLibGetModelRefRootOutputIdx(sysIdx, argIdx)

      %% fill 0 for unused outputs
      %assign numZeroToAdd = idx - outCounter
      %if  numZeroToAdd > 0
	%assign outStr = AppendZeroToString(outStr, comma, numZeroToAdd)
	%assign comma = ", "
      %endif
      %assign outCounter = idx

      %if FcnArgNeeded(CanonicalOutputArgDef[argIdx],currentTID,isPeriodicRateGrouping)
	%assign outStr = "%<outStr>%<comma>1"
      %else
	%assign outStr = "%<outStr>%<comma>0"
      %endif
      %assign comma = ", "
      %assign outCounter = outCounter + 1
    %endforeach

    %assign numZeroToAdd = numOutputs - outCounter
    %if  numZeroToAdd > 0
      %assign outStr = AppendZeroToString(outStr, comma, numZeroToAdd)
      %assign comma = ", "
    %endif
    %assign outCounter = numOutputs
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical dimsize dwork argument for output
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign outDWStr = GetBlockOutputCanDimSizeDWInterface(sysIdx, blockFcn, tid)
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Other flags
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Args: [oIdx, rIdx, TID, rtModel, BlockIo, DWork, CState, CStateDeriv, CStateDis, CStateAbsTol, ZC, ZCEvent]

    %% Note the following order is used in blocks/modelref.tlc.
    %% If you update this order, you must update the order in SLibCallModelBlockFunction in this file and
    %% FcnAddMdlRefFcnInterface in codeinfomdlreflib.tlc
    %% [oIdx, rIdx, TID, rtModel, BlockIo, DWork, CState, CStateDeriv, CStateDis, CStateAbsTol, ZC, ZCEvent]
    %assign args = ""
    %assign comma = ""

    %% oIdx and rIdx
    %if blockFcn == "SetDims"
      %assign val = 1
      %assign args = "%<args>%<comma>%<val>"
      %assign args = "%<args>%<comma>%<val>"
    %endif
    
    %% TID
    %if (SLibIsModelRefAsyncTID(tid))
      %% Because we know async is single instance, always return
      %% false for needs TID.  (LibSystemFcnNeedsTID returns needs
      %% TID for the model, which does need TID, but the async doesn't,
      %% which causes code that won't compile)
      %assign val = TLC_FALSE
    %else
      %assign val = LibSystemFcnNeedsTID(thisSystem, blockFcn)
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %assign comma = ", "
    %%rtModel
    %assign val = FcnArgNeeded(RTMArgDef,currentTID,isPeriodicRateGrouping) || hasSimplifiedInterface
    %if val && (IsModelRefScalableBuild() || GenerateClassInterface) 
      %assign val = 0
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %assign comma = ", "
    %% BlockIo argument
    %assign val = FcnArgNeeded(BlockIOArgDef,currentTID,isPeriodicRateGrouping)
    %if val && (IsModelRefScalableBuild() || GenerateClassInterface || hasSimplifiedInterface)
      %assign val = 0
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %% DWork argument
    %assign val = FcnArgNeeded(DWorkArgDef,currentTID,isPeriodicRateGrouping)
    %if val && (IsModelRefScalableBuild() || GenerateClassInterface || hasSimplifiedInterface)
      %assign val = 0
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %% Continuous States argument
    %assign val = FcnArgNeeded(ContStatesArgDef,currentTID,isPeriodicRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% Continuous States Derivative argument
    %assign val = FcnArgNeeded(ContStatesDerivativeArgDef,currentTID,isPeriodicRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% Continuous States Disabled argument
    %assign val = FcnArgNeeded(ContStatesDisabledArgDef,currentTID,isPeriodicRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% Continuous States Absolute Tolerance argument
    %assign val = FcnArgNeeded(ContStatesAbsoluteToleranceArgDef,currentTID,isPeriodicRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% Non Sampled Zero Crossing argument
    %assign val = FcnArgNeeded(ZCSVArgDef,currentTID,isPeriodicRateGrouping)
    %assert !(val && GenerateClassInterface)
    %assign args = "%<args>%<comma>%<val>"
    %% ZCEvent H-Valuct argument
    %assign val = FcnArgNeeded(ZCEventArgDef,currentTID,isPeriodicRateGrouping)
    %if val && (IsModelRefScalableBuild() || GenerateClassInterface || hasSimplifiedInterface)
      %assign val = 0
    %endif
    %assign args = "%<args>%<comma>%<val>"
    %%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical parameter argument
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign   comma  = ""
    %assign   prmStr = ""
    %assign  prmType = []
    %assign prmIsPtr = []
    %foreach argIdx = NumCanonicalPrmArgDefs
      %assign argDef = CanonicalPrmArgDef[argIdx]
      %if (argDef.OriginalDataTypeIdx != -1)
        %if FcnArgNeeded(argDef,currentTID,isPeriodicRateGrouping)
          %assign prmWidth = LibBlockParameterWidth(argDef)
          %assign prmStr = "%<prmStr>%<comma>%<prmWidth>"
        %else
          %% Not needed, so arbitrary "0" as a placeholder suffices.
          %assign prmStr = "%<prmStr>%<comma>0"
        %endif
        %assign  dtName = ...
          LibGetDataTypeNameFromId(LibGetRecordContainerDataTypeId(argDef))
        %assign prmType = prmType + dtName
        %assign comma = ", "
        %assign prmIsPtr = prmIsPtr + (argDef.DeclareAsPointer == "yes")
      %else
        %assert argDef.IsUsed == "no"
      %endif
    %endforeach
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Canonical dwork argument
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign comma  = ""
    %assign canDWStr = ""
    %foreach argIdx = NumCanonicalDWorkArgDefs
      %assign argDef = CanonicalDWorkArgDef[argIdx]
      %if FcnArgNeeded(argDef,currentTID,isPeriodicRateGrouping)
        %assign dwIdx    = argDef.FirstSignalSrc
        %assign dwRec    = ::CompiledModel.DWorks.DWork[dwIdx]
        %assign dwWidth  = SLibDWorkWidth(dwRec)
        %assign canDWStr = "%<canDWStr>%<comma>%<dwWidth>"
      %else
	%assign canDWStr = "%<canDWStr>%<comma>0"
      %endif
      %assign comma = ", "
    %endforeach
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Computed stack size
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %assign stackSize = 0
    %if blockFcn != "Registration" && ...
      (!SLibIsModelRefAsyncTID(tid) && !SLibExplicitTaskingTID(tid) || ...
      SLibNonInlinedModelWideEventTID(tid))
      %if !ISEMPTY(tlcFcnName)
        %assign rtwFcnConst = ...
          RTWCGModules.RTWCGModule[thisSystem.CGIRModuleIdx].RTWFcnConst
        %if ISFIELD(rtwFcnConst, tlcFcnName)
          %assign stackSize = rtwFcnConst.%<tlcFcnName>.StackSize
        %endif
      %endif
      %assign localTaskID = isPeriodicRateGrouping ? currentTID : -1
      %createrecord blockFcnRec {       \
        BlockFcnType "%<blockFcn>";       \
        RateGrouping %<isPeriodicRateGrouping>; \
        TaskID       %<localTaskID>;    \
        StackSize    %<stackSize>       \
      }
      %if isWritable
        %assign blkInterface.NumBlockFcns = blkInterface.NumBlockFcns + 1
        %addtorecord blkInterface BlockFcns %<blockFcnRec>
      %endif
    %endif
    
    %if SLibIsModelRefAsyncTID(tid) && ...
      !SLibNonInlinedModelWideEventTID(tid)
      %% For async, prmSTr, canDWStr, and args should all be empty.
      %% Assert that they are and defensively set them appropriately.
      %assert((args == "0, 0, 0, 0, 0, 0, 0, 0, 0, 0") || SLibIsExportFcnDiagram())
    %endif
    
    %assign numArgs = 0
    %assign argSourceVec  = []
    %assign associationVec = []
    %assign thisModule = ...
      ::CompiledModel.RTWCGModules.RTWCGModule[thisSystem.CGIRModuleIdx]
    
    %if ISFIELD(thisModule, "SystemFunctions") && ...
      ISFIELD(thisModule.SystemFunctions, fcnName)
      %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
      %assign thisFcn  = thisModule.Function[fcnIndex]
      %assert SIZE(thisFcn.ArgAccessed, 1) == thisFcn.NumArgs
      %assert SIZE(thisFcn.ArgSource, 1) == thisFcn.NumArgs
      %foreach argIdx = thisFcn.NumArgs        
        %if thisFcn.ArgAccessed[argIdx]
          %if ISFIELD(thisFcn, "Association")
            %assign association = thisFcn.Association[argIdx]
          %else
            %assign association = ""          
          %endif
          %assign argSource = thisFcn.ArgSource[argIdx]
          %assign idNum = SLibSafeIDNUM(thisFcn.ArgSource, argIdx)
          %assign argSrc = idNum[0]
          %assign argSrcIdx = idNum[1]
          %switch argSrc
            %case "I" %% canonical input
              %assign idx = SLibGetModelRefRootInputIdx(sysIdx, argSrcIdx)
              %assign argSource = "I%<idx>"
              %break
            %case "O" %% canonical output
              %assign idx = SLibGetModelRefRootOutputIdx(sysIdx, argSrcIdx)
              %assign argSource = "O%<idx>"
              %break
            %case "Y" %% root outport not being canonical output, occur in FPC only
              %assign argSource = "O%<argSrcIdx>"
              %break
            %case "D" %% canonical dwork
              %assign dimsIdNum = SLibSafeIDNUM(thisFcn.Association, argIdx)
              %assign dimsSrc = dimsIdNum[0]
              %assign dimsSrcIdx = dimsIdNum[1]
              %if "I" == dimsSrc
                %assign idx = SLibGetModelRefRootInputIdx(sysIdx, dimsSrcIdx)
                %assign association = "I%<idx>"
              %else
                %assert "O" == dimsSrc
                %assign idx = SLibGetModelRefRootOutputIdx(sysIdx, dimsSrcIdx)
                %assign association = "O%<idx>"
              %endif
              %break
            %case "P" %% canonical parameter
              %assert ISFIELD(thisFcn, "Association")
              %assert SIZE(thisFcn.Association, 1) == thisFcn.NumArgs
              %assert !ISEMPTY("%<association>")
              %assign argSource = association
              %break
            %case "RTM"
            %case "LB" %% block IO
            %case "LC" %% constat block IO
            %case "LW" %% dwork
            %case "LP"  %% parameter
            %case "LCP" %% constant parameter
            %case "LPI" %% const parameter with init
            %case "LX" %% continues states
            %case "LDX" %% derivatives
            %case "LXDI" %% continues state disabled
            %case "LXAT" %% continues state absolute tolerance
            %case "LZ" %% non-sampled zero crossings
            %case "LZE" %% zero crossing events
            %case "X" %% unknown argument
            %case "LCDG"
              %break
            %default
              %%START_ASSERT
              %assign errTxt = "Unhandled argument type '%<argSrc>'."
              %<LibBlockReportError([],errTxt)>
              %break
              %%END_ASSERT              
          %endswitch          
          %assign argSourceVec = argSourceVec + argSource
          %if ISFIELD(thisFcn, "Association")
            %assign associationVec = associationVec + association
          %endif
          %assign numArgs = numArgs + 1
        %endif
      %endforeach
    %endif
    
    %createrecord BlkFcnRec {     \
      FcnName      fcnName;       \
      ArgInfo      [%<args>];     \
      Outputs      [%<outStr>];   \
      OutDimSizeDW [%<outDWStr>]; \
      Inputs       [%<inStr>];    \
      InDimSizeDW  [%<inDWStr>];  \
      PrmArgs      [%<prmStr>];   \
      PrmTypes     prmType;       \
      PrmIsPointer prmIsPtr;      \
      DWArgs       [%<canDWStr>]; \
      NumArgs      numArgs;       \
      ArgSource    argSourceVec;  \
      Association  associationVec \
    }

    %assign ::BlockFcn = "Unknown"
  %endwith %% thisSystem.Interface

  %createrecord retRec { \
  SysFcnName "%<sysFcnName>"; \
  FcnRec     %<BlkFcnRec>\
  }  
  %return retRec
%endfunction


%% Function FcnAppendToBlockInterface =========================================
%% Abstract:
%%    The following order is used in FcnGetAdditionalArgs and
%%    FcnAddNeededParameter. We must use the same order:
%%           Tid
%%           oIdx,
%%           rIdx,
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           RTModel
%%           BlockIO
%%           ConstBlockIO (not needed. This is global for all instances)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           ContStatesAbsoluteTolerance
%%           NonsampledZC
%%           ZCEvent
%%           NumCanonicalPrm
%%           CanDWork (?)
%%
%function FcnAppendToBlockInterface(sysIdx, accessSysIdx, blockFcn, tid, blkInterface) void
  
  %assign fcnRec = CreateModelReferenceFcnRec(sysIdx, blockFcn, "", tid, blkInterface, TLC_FALSE)
  
  %assign fcnName = fcnRec.SysFcnName
  %assign BlkFcnRec = fcnRec.FcnRec
  
  %if fcnName != ""
    %addtorecord blkInterface %<fcnName> %<BlkFcnRec>
  %endif

%endfunction %%FcnAppendToBlockInterface

%% Function: FcnCacheMRRegFcnLocalVars ======================================
%% Abstract:
%%   This function adds the needed local variables to the registration function 
%%   body e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref 
%%   scalable build. e.g.
%%   
%%      void mr_ModelName_intialize(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%%
%function FcnCacheMRRegFcnLocalVars(thisSystem) void
  
  %assign thisSystem.CurrentTID = ""
  %assign currentTID     = ""
  %assign isPeriodicRateGrouping = SLibSystemFcnPeriodicRateGrouping(thisSystem, "Registration")

  %assign ::BlockFcn = "Registration"
  
  %with thisSystem.Interface
    %% Args: [TID, rtModel, BlockIo, DWork, CState, CStateDriv, CStateDis, ZC, ZCEvent]
    %%rtModel
    %assign val = FcnArgNeeded(RTMArgDef,currentTID,isPeriodicRateGrouping)
    %if val && IsModelRefScalableBuild() && !SLibIsSelfInPluggableInterface()
      %openfile localRTMVar
      %assign rtmAccess = ".rtm"
      %<SLibGetQualifiedRTMType()> *const %<::tSimStruct> = &(%<FcnGetSFcnDWorkIdentifier(thisSystem)>%<rtmAccess>);
      %closefile localRTMVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localRTMVar)>
    %endif
    %% CoderDataGroups
    %if !CompiledModel.SuppressSelf
      %openfile coderDataGroupVar
      %foreach gIdx = ::CompiledModel.NumCoderDataGroups
        %assign group = ::CompiledModel.CoderDataGroup[gIdx]
        %if SLibIsGroupSelfCoderGroup(group)
          %continue
        %endif
        %assign groupToken = "CoderDataGroup" + group.Name
        %assign argDef = %<groupToken + "ArgDef">
        %if FcnArgNeeded(argDef,currentTID,isPeriodicRateGrouping)
          %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, groupToken, 0)
          %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
          %assign varGroupType = FcnSysVarGroupType(thisSystem, groupToken)
          %assign varName = varGroup.LocalName
          %assign typeQualifier = SLibTypeQualifierForGroup(group)
          %if SLibAccessGroupThroughSelf(group)
            %<typeQualifier> %<varGroupType> *%<varName> = %<SLibGetCoderDataGroupPointerFromRTM(group, 1)>;
          %else
            %<typeQualifier> %<varGroupType> *%<varName> = &%<SLibCoderDataGroupInstance(group)>;
          %endif
        %endif
      %endforeach
      %closefile coderDataGroupVar
      %if !ISEMPTY(coderDataGroupVar)
        %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", coderDataGroupVar)>
      %endif
    %endif
    %% Continuous States argument
    %assign val = FcnArgNeeded(ContStatesArgDef,currentTID,isPeriodicRateGrouping)
    %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStates")
      %<varGroupType> *localX = (%<varGroupType> *) localX_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif
    %% Continuous States Derivative argument
    %assign val = FcnArgNeeded(ContStatesDerivativeArgDef,currentTID,isPeriodicRateGrouping)
    %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDerivative")
      %<varGroupType> *localXdot = (%<varGroupType> *) localXdot_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif
    %% Continuous States Disabled argument
    %assign val = FcnArgNeeded(ContStatesDisabledArgDef,currentTID,isPeriodicRateGrouping)
    %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesDisabled")
      %<varGroupType> *localXdis = (%<varGroupType> *) localXdis_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif
    %% Continuous States Absolute Rolerance argument
    %assign val = FcnArgNeeded(ContStatesAbsoluteToleranceArgDef,currentTID,isPeriodicRateGrouping)
    %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ContStatesAbsoluteTolerance")
      %<varGroupType> *localXAbsTol = (%<varGroupType> *) localXAbsTol_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif    
    %% Non Sampled Zero Crossing argument
    %assign val = FcnArgNeeded(ZCSVArgDef,currentTID,isPeriodicRateGrouping)
    %if (val && IsModelRefScalableBuild()) && !::CompiledModel.ModelRefSimpInterface
      %openfile localCStateVar
      %assign varGroupType = FcnSysVarGroupType(thisSystem,"ZCSV")
      %<varGroupType> *localZCSV = (%<varGroupType> *) localZCSV_;
      %closefile localCStateVar
      %<FcnCacheModelRefLocalVars(thisSystem, "Registration", "", localCStateVar)>
    %endif
    %assign ::BlockFcn = "Unknown"
  %endwith %% System[sysIdx].Interface

%endfunction %%FcnCacheMRRegFcnLocalVars

%% Function: FcnCacheModelRefFcnLocalVars ======================================
%% Abstract:
%%   This function adds the needed local variables to the function body.
%%   e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref 
%%   scalable build. e.g.
%%   
%%      void mr_ModelName(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%%
%function FcnCacheModelRefLocalVars(system, function, tid, localVars) void
  %assign cacheName = "MR" + function + "%<tid>" + "LocalVars"
  %if !LibIsSystemField(system, cacheName)
    %<LibAddToSystem(system, cacheName, localVars)>
  %else
    %<LibAddToSystemField(system, cacheName, localVars)>
  %endif
%endfunction

%% Function: SLibResetModelRefFcnLocalVars ====================================
%% Abstract:
%%   This function resets the list of needed local variables for the function body.
%function SLibResetModelRefLocalVars(system, function, tid) void
  %assign cacheName = "MR" + function + "%<tid>" + "LocalVars"
  %if LibIsSystemField(system, cacheName)
    %<LibSetSystemField(system, cacheName, "")>
  %endif
%endfunction

%% Function: FcnDumpModelRefFcnLocalVars ======================================
%% Abstract:
%%   This function adds the needed local variables to the function body.
%%   e.g. "localB, localDW, localX ..."
%%   The additional local variables are needed if we are doing a model ref 
%%   scalable build. e.g.
%%   
%%      void mr_ModelName(const int32_T *rtu_0, int32_T *rty_0)
%%      {
%%           rtB_mr_myecdemo   *localB = &(mr_myecdemo_DW.rtb);
%%           rtDW_mr_myecdemo *localDW = &(mr_myecdemo_DW.rtdw);
%%           ....
%%
%function FcnDumpMRLocalVars(system, function, tid) void

  %if !IsModelReferenceBaseSys(system)
    %return ""
  %endif
  
  %if ::GenerateClassInterface
    %return ""
  %endif
  
  %% For functions that don't use rate-grouping, make sure we clear out the TID
  %if !SLibSystemFcnIsRateGroupType(function)
    %assign tid = ""
  %endif

  %assign cacheName = "MR" + function + "%<tid>" + "LocalVars"
  %if LibIsSystemField(system, cacheName)
    %assign cacheVal = LibGetSystemField(system, cacheName)
    %if !WHITE_SPACE(cacheVal)
      %return cacheVal
    %endif
  %endif
  %return ""
%endfunction


%% Function: SLibModelReferenceAppendInputsOutputs ============================
%% Abstract:
%%   Used for the model reference SIM target to define the arguments to
%%   a function, or call that function from the S-Function.
%%
%function SLibModelReferenceAppendInputsOutputs(blockFcn, ...
  fcnName, isPeriodicRateGrouping, currentTID, recArgs) void
  %assign origBlockFcn = ::BlockFcn
  %assign ::BlockFcn = blockFcn
  %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
  %assign modIdx = baseSystem.CGIRModuleIdx
  %assign thisModule = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]
  
  %with baseSystem.Interface
    %%
    %% The following TLC code is used to prune the CGIR function call
    %% arguments and transfer the CGIR argument tracking 
    %% information to the legacy TLC tracking infrastructure.
    %%
    %assign skipCanInput = ...
      Vector(%<NumCanonicalInputArgDefs>) [0@%<NumCanonicalInputArgDefs>]
    %assign skipInputDims = ...
      Vector(%<NumCanonicalInputArgDefs>) [0@%<NumCanonicalInputArgDefs>]
    %assign skipCanOutput = ...
      Vector(%<NumCanonicalOutputArgDefs>) [0@%<NumCanonicalOutputArgDefs>]
    %assign skipOutputDims = ...
      Vector(%<NumCanonicalOutputArgDefs>) [0@%<NumCanonicalOutputArgDefs>]
    %assign skipCanDWork = ...
      Vector(%<NumCanonicalDWorkArgDefs>) [0@%<NumCanonicalDWorkArgDefs>]
    %assign skipCanParam = ...
      Vector(%<NumCanonicalPrmArgDefs>) [0@%<NumCanonicalPrmArgDefs>]
      
    %if !ISEMPTY(fcnName) && ISFIELD(thisModule, "SystemFunctions") && ...      
      ISFIELD(thisModule.SystemFunctions, fcnName)
      %assign fcnIndex = GETFIELD(thisModule.SystemFunctions, fcnName)
      %assign thisFcn  = thisModule.Function[fcnIndex]
      %assign irParams = FEVAL("regexprep", thisFcn.ProtoType, ...
        "^[^\(]*\(", "")
      %if !ISEMPTY(cgirParams) && !WHITE_SPACE(cgirParams)
        %assign recArgs = recArgs + irParams
      %endif
      %foreach argIdx=thisFcn.NumArgs
        %if thisFcn.ArgAccessed[argIdx]
          %assign idNum = SLibSafeIDNUM(thisFcn.ArgSource, argIdx)
          %assign argSrc = idNum[0]
          %assign argSrcIdx = idNum[1]
          %switch argSrc
            %case "I"
              %assign skipCanInput[argSrcIdx] = 1
              %break
            %case "O"
              %assign skipCanOutput[argSrcIdx] = 1
              %break
            %case "D"
              %assert ISFIELD(thisFcn, "Association")
              %assert SIZE(thisFcn.Association, 1) == thisFcn.NumArgs
              %assign dimsIdNum = SLibSafeIDNUM(thisFcn.Association, argIdx)
              %assign dimsSrc = dimsIdNum[0]
              %assign dimsSrcIdx = dimsIdNum[1]
              %assert "I" == dimsSrc || "O" == dimsSrc
              %if "I" == dimsSrc
                %assign skipInputDims[dimsSrcIdx] = 1
              %else
                %assign skipOutputDims[dimsSrcIdx] = 1
              %endif
              %assign skipCanDWork[argSrcIdx] = 1
              %break
            %case "P"
              %assign skipCanParam[argSrcIdx] = 1
              %break
            %case "RTM"
            %case "X"
              %break
            %default
              %%START_ASSERT
              %assign errTxt = "Unhandled argument type '%<argSrc>'."
              %<LibBlockReportError([],errTxt)>
              %break
              %%END_ASSERT              
          %endswitch
        %endif
      %endforeach
    %endif
        
    %foreach argIdx = NumCanonicalInputArgDefs
      %if !skipCanInput[argIdx] && ...
        FcnArgNeeded(CanonicalInputArgDef[argIdx], currentTID,isPeriodicRateGrouping)
        %assign ci        = CanonicalInputArgDef[argIdx]
        %assign identi    = LibGetRecordIdentifier(ci)
        %assign dataType  = SLibGetRecordDataTypeName(ci, "")
        %assign optWidth  = LibOptionalVectorWidth(LibGetRecordWidth(ci))
        %assign optStar   = (LibGetRecordWidth(ci) == 1 && ...
          !(IsModelReferenceRTWTarget() && !FcnPassCanonicalInputByPtr(ci))) ? " *" : " "
        %assign dataType  = "const %<dataType> "
        %if SLibGetCanIOIsVarDims(ci)
          %assign   argDef  = dataType + identi + "[]"
        %else
          %assign   argDef  = dataType + optStar + identi + optWidth
        %endif
        %assign recArgs   = recArgs + argDef
      %endif
      %if !skipInputDims[argIdx]
        %assign recArgs = ...
          AppendModelReferenceRegFcnInputCanDimSizeDWArgs(argIdx, ...
          currentTID, isPeriodicRateGrouping, recArgs)
      %endif
    %endforeach

    %foreach argIdx = NumCanonicalOutputArgDefs
      %if !skipCanOutput[argIdx] && ...
        FcnArgNeeded(CanonicalOutputArgDef[argIdx], currentTID,isPeriodicRateGrouping)
        %assign       co = CanonicalOutputArgDef[argIdx]
        %assign   identi = LibGetRecordIdentifier(co)
        %assign dataType = SLibGetRecordDataTypeName(co, "")
        %assign  optStar = LibGetRecordWidth(co) == 1 ? " *" : " "
        %assign optWidth = LibOptionalVectorWidth(LibGetRecordWidth(co))
        %if SLibGetCanIOIsVarDims(co)
          %assign   argDef = dataType + " " + identi + "[]"
        %else
          %assign   argDef = dataType + optStar + identi + optWidth
        %endif
        %assign recArgs  = recArgs + argDef
      %endif
      %if !skipOutputDims[argIdx]
        %assign recArgs = ...
          AppendModelReferenceRegFcnOutputCanDimSizeDWArgs(argIdx, ...
          currentTID, isPeriodicRateGrouping, recArgs)
      %endif
    %endforeach

    
    %foreach argIdx = NumCanonicalPrmArgDefs
      %if !skipCanParam[argIdx] && ...
        FcnArgNeeded(CanonicalPrmArgDef[argIdx], currentTID,isPeriodicRateGrouping)
        %assign       prm = CanonicalPrmArgDef[argIdx]
        %assign    identi = LibGetRecordIdentifier(prm)
        %assign  dataType = SLibGetRecordDataTypeName(prm, "")
        %assign     width = LibBlockParameterWidth(prm)
        %assign  optWidth = LibOptionalVectorWidth(width)
        %assign declAsPtr = prm.DeclareAsPointer == "yes"          
        %assign  optConst = ((width > 1) || declAsPtr) ? "const " : ""
        %assign  dataType = "%<optConst>%<dataType> "
        %assign   optStar = declAsPtr ? " *" : " "
        %assign    argDef = dataType + optStar + identi + optWidth
        %assign   recArgs = recArgs + argDef
      %endif
    %endforeach

  %endwith

  %assign ::BlockFcn = origBlockFcn
  %return recArgs
  
%endfunction
  
  

%% Function: SLibModelReferenceRegFcnArgs ===================================
%% Abstract:
%%   Generate model fcn arg list.
%%
%% The following order should be maintianied for ref args. See GetFunctionStr()
%%           TID
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           SimStruct
%%           rtModel
%%           BlockIO
%%           ConstBlockIO (?)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           NonsampledZC
%%           ZCEvent
%%           MassMatrix
%%           NumCanonicalPrm
%%           CanDWork (?)
%%           C-API required arguments (optional)
%%             o sysRan        (mdlrefsim target required)
%%             o sysTID        (mdlrefsim target required)
%%             o MMI           (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o block Path    (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o child Idx     (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o Cont State Idx(mdlrefsim required, rtwtarget if RTWCAPI==true)
%%
%function SLibModelReferenceRegFcnArgs() void
  %assign recArgs = []
  %assign rootSystem        = System[NumSystems-1]
  %assign baseSystem        = System[NumSystems-2]
  %assign isPeriodicRateGrouping    = SLibIsMultiRateAndPeriodicRateGrouping(rootSystem)

  %assert IsModelReferenceTarget()
  
  %assign ::BlockFcn = "Registration"

  %if !IsModelReferenceForASimstructBasedTarget()
    %% ModelInitializeIsEmpty is computed in ertreg.tlc
    %% Why do we need this?  Who calls it with 0?
    %if SLibGetNeedFirstTime()
      %assign recArgs = recArgs + "boolean_T %<SLibFirstTime()>"
    %endif

    %if !SuppressErrorStatus
      %assign recArgs = recArgs + "const char_T **rt_errorStatus"
    %endif

    %if RTMStopReqAccessed() || ::CompiledModel.ModelBlocksUseStopReq
      %assign recArgs = recArgs + "boolean_T *rt_stopRequested"
    %endif

    %if LibIsContinuous(0) || SLibModelHierarchyContainsNoninlinedSfcn()
      %assign recArgs = recArgs + "RTWSolverInfo *rt_solverInfo"
    %endif
    
    %if SLibModelHierarchyContainsNoninlinedSfcn()
      %assign recArgs = recArgs + "RTWSfcnInfo *rt_sfcnInfo"
    %endif
  
  %endif
  
  %% Add the canonical inputs/outputs to the interface
  %assign recArgs = SLibModelReferenceAppendInputsOutputs(...
    "Registration", "", isPeriodicRateGrouping, rootSystem.CurrentTID, recArgs)
  
  %if IsModelReferenceForASimstructBasedTarget() 
    %assign recArgs = recArgs + "%<tMdlRefSfcnSType> %<tMdlRefSfcnS>"
    
    %if RTMIsVarStepSolver() && HasNonContSigFeedingOutport()
      %assign recArgs = recArgs + "ssNonContDerivSigFeedingOutports **mr_nonContOutputArray"
    %endif
  %endif %% !IsModelReferenceForASimstructBasedTarget()
  
  %% Add information to generate the correct model block's 
  %% initialize function signature
  %if ISFIELD(::CompiledModel, "NumDataTransfers") && ::CompiledModel.NumDataTransfers > 0
    %assign recArgs = recArgs + "const uint32_T *gblDataTransferIds"
  %endif
  
  %% Pass the timing info to the registration function, we only
  %% do this for non simstruct based targets.
  %if !IsModelReferenceForASimstructBasedTarget() && ...
    ::tMdlRefTimingBridgeAccessed
    %assert SLibIsERTCodeFormat()
    %assign recArgs = recArgs + "const rtTimingBridge *timingBridge"
  %endif

  %if !IsModelReferenceForASimstructBasedTarget() && ...
    SLibModelHasVariableDiscrete()
    %assert SLibIsERTCodeFormat()
    %assign recArgs = recArgs + "rtVDRMdlRefTiming *VDRMdlRefTimingPtr"
  %endif
  
  %% Only loop over the sample times if the model reference
  %% block will not become constant/triggered.
  %if ::tMdlRefNeedTIDArgs
    %if !MdlRefIsConstSampleBlock() || MdlRefHasParameterRate()
      %foreach idx = SLibGetNumTIDsForGlobalTIDMap()
        %assign recArgs = recArgs + "int_T mdlref_TID%<idx>"
      %endforeach
    %else
      %assign recArgs = recArgs + "int_T mdlref_TID0"
    %endif
  
    %if SLibModelNeedsTriggerTIDArg()
      %assign recArgs = recArgs + "int_T mdlref_TriggerTID"
    %endif
  %endif
  %assign selfAccess = ::CompiledModel.ModelRefSimpInterface || SLibGetDoesSelfExist()
  %with baseSystem.Interface
    %if !IsModelRefScalableBuild()
      %if FcnArgNeeded(RTMArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping) || selfAccess
        %assign rtmArg = SLibGetQualifiedRTMType() + " *const %<::tSimStruct>"
        %assign recArgs = recArgs + rtmArg
      %endif
      %if FcnArgNeeded(BlockIOArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping) && !selfAccess
        %assign blockIOCallee = "localB"
        %assign blockIOType = FcnSysVarGroupType(System[NumSystems-2],"BlockIO")
        %assign recArgs = recArgs + "%<blockIOType> *%<blockIOCallee>"
      %endif
      %if FcnArgNeeded(DWorkArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping) && !selfAccess
        %assign dworkCallee = "localDW"
        %assign dworkType = FcnSysVarGroupType(System[NumSystems-2],"DWork")
        %assign recArgs = recArgs + "%<dworkType> *%<dworkCallee>"
      %endif
    %endif %% scalable
    %if FcnArgNeeded(ContStatesArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping)
      %assign contState = IsModelRefScalableBuild() ? ...
        "localX_" : "localX"
      %assign contStateType = IsModelRefScalableBuild() ? ...
        "real_T" : FcnSysVarGroupType(System[NumSystems-2],"ContStates")
      %assign recArgs = recArgs + "%<contStateType> *%<contState>"
    %endif
    %if FcnArgNeeded(ContStatesDerivativeArgDef, ...
      rootSystem.CurrentTID,isPeriodicRateGrouping)
      %assign contDerivState = IsModelRefScalableBuild() ? ...
        "localdX_" :"localdX"
      %assign contDerivStateType = IsModelRefScalableBuild() ? ...
        "real_T" : FcnSysVarGroupType(System[NumSystems-2],"ContStatesDerivative")
      %assign recArgs = recArgs + "%<contDerivStateType> *%<contDerivState>"
    %endif
    %if !IsModelRefScalableBuild()
      %if FcnArgNeeded(ZCEventArgDef,rootSystem.CurrentTID,isPeriodicRateGrouping)
        %assign prevZCCallee = "localZCE"
        %assign prevZCEvType = FcnSysVarGroupType(System[NumSystems-2],"ZCEvent")
        %assign recArgs = recArgs + "%<prevZCEvType> *%<prevZCCallee>"
      %endif
    %endif
    
    %if (::CompiledModel.ModelIsLinearlyImplicit == "yes")
      %assign prevMMCallee = "localMM"
      %assign prevMMType = "real_T"
      %assign recArgs = recArgs + "%<prevMMType> *%<prevMMCallee>"
    %endif
      
  %endwith
  
  %%
  %% Pass in the initial context system and tid
  %%
  %if IsModelReferenceSimTarget()
    %assign recArgs = recArgs + "void *sysRanPtr"
    %assign recArgs = recArgs + "int contextTid"
  %endif
  
  %%
  %if (RTWCAPI == 1) && !GenerateClassInterface
    %assign recArgs = recArgs + "rtwCAPI_ModelMappingInfo *rt_ParentMMI"
    %assign recArgs = recArgs + "const char_T *rt_ChildPath"
    %assign recArgs = recArgs + "int_T rt_ChildMMIIdx"
    %assign recArgs = recArgs + "int_T rt_CSTATEIdx"
  %endif
  
  %assign ::BlockFcn = "Unknown"

  %if ISEMPTY(recArgs)
    %return "void"
  %endif
  
  %return SLibSerializeFcnArgs(recArgs)
%endfunction %%SLibModelReferenceRegFcnArgs


%% Function: FcnGetNoncontMangledName ==========================================
%% Abstract:
%%  Get the mangled name for the array of noncontinuous signals.
%function FcnGetNoncontMangledName(name, systemIdx, blockIdx, instIdx) void
  %assign instance = instIdx < 0 ? 0 : instIdx
  %return "%<name>_%<systemIdx>_%<blockIdx>_%<instance>"
%endfunction

%% Function: FcnCheckForConstConsistency ======================================
%% Abstract:
%%    Check whether the model being called passes the signal as a non-const
%%    pointer, yet this signal is a const arg to this model's step function.
%%    block, argIdx, portIdx, and FPC all pertain to the submodel being called.
%function FcnCheckForConstConsistency(sysIdx, block, argIdx, portIdx, FPC) void
  %% See if the signal is passed to the child model by pointer or reference, 
  %% without a const qualifier; if not, exit.
  %if FPC.ArgSpecData[argIdx].Category != "Pointer" && ...
      FPC.ArgSpecData[argIdx].Category != "Reference"
    %return TLC_TRUE
  %endif
  %assign hasConstQualifier = TLC_FALSE
  %switch FPC.ArgSpecData[argIdx].Qualifier
    %case "none"
      %break
    %case "const"
    %case "const *"
    %case "const * const"
    %case "const &"
      %assign hasConstQualifier = TLC_TRUE
      %break
    %default
      %assign errTxt = "Unhandled qualifier"
      %<LibReportFatalError(errTxt)>
      %break
  %endswitch
  %if hasConstQualifier
    %return TLC_TRUE
  %endif
    
  %% If we get to this point, the child model passes the input by pointer or ref
  %% without a const qualifier.  Now see if the parent model or reusable
  %% subsystem declares the input with a const qualifier
  
  %assign portObj  = FcnGetInputPortRecord(portIdx)
  %% We only have to check element 0 because if the input to the mdlref block
  %% is discontiguous, we insert a hidden buffer, and then the signal can't be
  %% const.  We only can get const if the input arg is specified as const by FPC
  %% and passed directly into the mdlref block.
  %assign sigRecAndMapInfo = ...
    SLibGetSourceRecordAndMapInfo(portObj, 0, TLC_TRUE, TLC_TRUE)
  
  %% See if the signal is coming from the root inport in the parent model; if not,
  %% no worry: it is not const.
  %if sigRecAndMapInfo.mapSrc == "U"
    %if ( SLibFcnProtoCtrlActive() && ...
          (::CompiledModel.RTWFcnClass.Object.Class != "FcnDefault") ) || ...
        GenerateClassInterface
     %assign sigRec = sigRecAndMapInfo.sigRec
    
     %% Trouble if the root input is passed as const
     %if FcnPassExternalInputAsConst(sigRec)
       %return TLC_FALSE
     %else
       %return TLC_TRUE
     %endif

    %% Just a "vanilla" root input; no problem.
    %else
      %return TLC_TRUE
    %endif

  %% If a canonical input
  %elseif sigRecAndMapInfo.mapSrc == "u"
    %assign sigRec = sigRecAndMapInfo.sigRec
    
    %% Default interface model reference build interface has const from IR
    %if GenerateClassInterface && IsModelReferenceTarget() && ...
      (::CompiledModel.RTWFcnCPPClass.Object.Class == "ModelCPPDefaultClass")
      %return TLC_FALSE
    %endif

    %% Trouble if the canonical input is passed as const
    %if FcnPassCanonicalInputAsConst(sysIdx, sigRec)
      %return TLC_FALSE
    %else
      %return TLC_TRUE
    %endif
  %elseif sigRecAndMapInfo.mapSrc == "C"
    %%%% The source is a constant
    %return TLC_FALSE
  %else
    %return TLC_TRUE

  %endif

%endfunction

%function SLibAttachIRTEventArgs(args)
  %foreach tid = NumSampleTimes
    %if SLibInitResetTermEventTID(tid)
      %assign args = args + STRING(tid)
    %endif
  %endforeach
  %return args
%endfunction

%function SLibAttachTimingArgsForCPPEncap(block, blockInterface, inArgs)
  %assert SLibIsCPPEncapMdlRefBuild() || ...
          (GenerateClassInterface && block.MdlRefIsCPPClassGenMode)
  
  %assign args = inArgs
  
  %if !IsModelReferenceForASimstructBasedTarget()
    %if blockInterface.NeedsGlobalTimingEngine
      %if IsModelReferenceTarget()
        %assign args = args + "%<SLibGetGlobalTimingBridge()>"
      %else
        %assign args = args + "&%<SLibGetGlobalTimingBridge()>"
      %endif
    %endif
  %endif
  
  %% If the block is completely constant, then just 
  %% pass 0 as the TID.  If it is inherited, pass the 
  %% TID that this instance is running at.  This will 
  %% help with data logging.
  %if blockInterface.NeedsTIDArgs
    %assign ::tMdlRefNeedTIDArgs = TLC_TRUE
    %assign blockTid = block.TID
    %if TYPE(blockTid) == "Vector"
      %assign nonModelWideEventTids = []
      %assign numTids = SIZE(blockTid)[1]
      %foreach idx = numTids
        %if !SLibModelWideEventTID(blockTid[idx])
          %assign nonModelWideEventTids = nonModelWideEventTids + blockTid[idx]
        %endif
      %endforeach
      %if SIZE(nonModelWideEventTids)[1] == 1
        %assign blockTid = nonModelWideEventTids[0]
      %endif
    %endif
    %if TYPE(blockTid) != "Identifier"
      %if LibAsynchronousTriggeredTID(blockTid)
        %% if it is in async fcn-call subsystem, 
        %% pass -1
        %assign args = args + "-1"
      %else
        %% constant is handled in the loop
        %foreach idx = NumSynchronousSampleTimes
          %assign childTID = MapParentTID2ChildTID(block, idx)
          %if childTID != -1
            %if IsModelReferenceTarget()
              %assign args = args + "%<FcnGetMdlRefGlobalTIDMap("")>[%<idx>]"
            %else
              %assign args = args + "%<idx>"
            %endif
          %endif
        %endforeach
        %% Add parameter rate if used by model block, since that rate is not
        %% represented in the ChildTidToParentTidMap
        %if blockInterface.HasInternalParameterRate || ...
            blockInterface.HasParameterRateOutput
          %assign args = args + STRING(SLibTidOfParameterChangeEvent())
        %endif
        
        %% Add irt event rate if used by model block
        %assign args = SLibAttachIRTEventArgs(args) 
      %endif
    %else
      %% There is only one TID in the model and it
      %% is constant/triggered, pass 0 if it is constant
      %% and pass -1 if it is triggered.
      %if ISEQUAL(blockTid, "triggered")
        %assign args = args + "-1"
      %else
        %assign args = args + "0"
      %endif
    %endif
    
    %if GetModelRefFcnCallTriggerTIDIsReq(block)
      %if SLibModelNeedsTriggerTIDArg()
        %assign args = args + "%<FcnGetMdlRefTriggerTIDMap("")>"
      %else
        %assert ISEQUAL(blockTid, "triggered") || ...
          LibAsynchronousTriggeredTID(blockTid)
        %if LibAsynchronousTriggeredTID(blockTid)
          %assign args = args + "%<blockTid>"
        %else
          %assign trigTid = block.TriggerTID[0]
          %if IsModelReferenceTarget()
            %assign args = args + "%<FcnGetMdlRefGlobalTIDMap("")>[%<trigTid>]"
          %else
            %assign args = args + "%<trigTid>"
          %endif
        %endif
      %endif
    %endif
  %endif

  %return args
  
%endfunction %%SLibAttachTimingArgsForCPPEncap

%% Function: SLibGetModelBlockInput ============================================
%% Abstract:
%%   Return the input for a model reference block and port index
%%
%function SLibGetModelBlockInput(sysIdx, block, sysFcnName, mdlRefIdx, portIdx, ...
  canInputInfo, FPC, argIdx) void
  %assign arg = []
  %if sysFcnName == "RegistrationFcn"
    %assign baseSystem = ::CompiledModel.System[GetBaseSystemIdx()]
    %assign thisModelBlock = ::CompiledModel.ModelBlock[mdlRefIdx]  
    %assign dataPort = thisModelBlock.DataInputPort[portIdx]        
    %assign id = IDNUM(dataPort.SignalSrc[0])
    %switch id[0]
      %case "y"
        %assign canOut = baseSystem.Interface.CanonicalOutputArgDef[id[1]]
        %assign arg = LibGetRecordIdentifier(canOut)
        %<SLibAccessArgHelper(canOut,"","")>
        %if ISFIELD(dataPort, "BusSelElIdx")
          %assign arg = "(*%<arg>)%<dataPort.BusSelElIdx[0]>"
          %if dataPort.SignalOffset[0] == 0
            %assign arg = "&%<arg>"
          %endif
        %endif
        %if dataPort.SignalOffset[0] != 0
          %assign arg = "&(%<arg>[%<dataPort.SignalOffset[0]>])"
        %endif
        %break
      %case "u"
        %assign canIn = baseSystem.Interface.CanonicalInputArgDef[id[1]]
        %assign arg = LibGetRecordIdentifier(canIn)
        %<SLibAccessArgHelper(canIn,"","")>
        %if ISFIELD(dataPort, "BusSelElIdx")
          %assign arg = "(*%<arg>)%<dataPort.BusSelElIdx[0]>"
          %if dataPort.SignalOffset[0] == 0
            %assign arg = "&%<arg>"
          %endif
        %endif
        %if dataPort.SignalOffset[0] != 0
          %assign arg = "&(%<arg>[%<dataPort.SignalOffset[0]>])"
        %endif
        %break
      %default            
        %with thisModelBlock
          %assign arg = LibBlockInputSignalAddr(portIdx, "", "", 0)
          %break
        %endwith
    %endswitch
  %else
    %assign isMatrix = LibBlockInputSignalIsMatrix(portIdx)
    %if isMatrix || (canInputInfo[portIdx] == 2) ||  ...
      (!IsFPCIgnored(FPC) && ...
      (FPC.ArgSpecData[argIdx].Category == "Pointer" || ...
      FPC.ArgSpecData[argIdx].Category == "Reference"))
      %assign calleePassByRef = !IsFPCIgnored(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference"
      %if calleePassByRef
        %% To avoid code like *(&arr[0]). arr[0] is more desirable
        %assign arg = LibBlockInputSignal(portIdx, "", "", 0)
      %else
        %assign arg = LibBlockInputSignalAddr(portIdx, "", "", 0)
      %endif
      
      %assign dtypeName = LibBlockInputSignalDataTypeName(portIdx, "")

      %if calleePassByRef
        %% pass by reference (C++) case
        %if isMatrix
          %assign symbWidth = LibBlockInputSignalSymbolicWidth(portIdx)    
          %assign arg = "(" + dtypeName + "(&)" + "[" + symbWidth + "])" + arg
        %endif                
      %endif
      
      %if !IsFPCIgnored(FPC) && ...
        !FcnCheckForConstConsistency(sysIdx, block, argIdx, portIdx, FPC)
        %assign refModelName = block.ParamSettings.ReferencedModelName

        %assign argName = FPC.ArgSpecData[argIdx].ArgName
        %assign msgArgs = ["%<refModelName>", "%<block.Name>", "%<argName>", "%<argName>"]

        %if ::GenerateClassInterface && IsModelReferenceTarget() && ...
          (::CompiledModel.RTWFcnCPPClass.Object.Class == "ModelCPPDefaultClass")
          %<SLibReportErrorWithIdAndArgs(...
            "Simulink:modelReference:DefaultInterfaceConstInconsistency", ...
            msgArgs)>
        %endif

        %if ::GenCPP
          %if !IsFPCIgnored(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference"
            %if !isMatrix
              %%%% scalar signal
              %assign arg = "const_cast<" + dtypeName + "&>(" + arg + ")"
            %endif
          %else
            %assign arg = "const_cast<" + dtypeName + "*>(" + arg + ")"
          %endif
        %else
          %assign arg = "(" + dtypeName + "*)" + arg
        %endif
        
        %if !block.MdlRefIsCPPClassGenMode
          %<SLibReportWarningWithIdAndArgs(...
            "Simulink:modelReference:WarnAboutConstCastPrototypeFeature", ...
            msgArgs)>
        %else
          %<SLibReportWarningWithIdAndArgs(...
            "Simulink:modelReference:WarnAboutConstCastIOArgFeature", ...
            msgArgs)>
        %endif        
      %endif
      %<SLibInvokeTLCInterface(block, "Input", ...
        portIdx, 0, TLC_FALSE, "", "", 0, "")>
    %else
      %assign arg = LibBlockInputSignal(portIdx, "", "", 0)
    %endif
  %endif
  %return arg
%endfunction %% SLibGetModelBlockInput

%% Function: SLibGetModelBlockOutput ===========================================
%% Abstract:
%%   Return the output for a model reference block and port index
%%
%function SLibGetModelBlockOutput(sysFcnName, mdlRefIdx, portIdx, FPC, argIdx) void
  %assign passByPtr = ...
    IsFPCIgnored(FPC) || FPC.ArgSpecData[argIdx].Category == "Pointer"
  %assign passByRef = ...
    !IsFPCIgnored(FPC) && FPC.ArgSpecData[argIdx].Category == "Reference"
  %assign arg = [] 
  %if sysFcnName == "RegistrationFcn"
    %assign baseSystemIdx  = GetBaseSystemIdx()
    %assign baseSystem     = ::CompiledModel.System[baseSystemIdx]  
    %assign thisModelBlock = ::CompiledModel.ModelBlock[mdlRefIdx]  
    %assign dataPort       = thisModelBlock.DataOutputPort[portIdx]
    %assign id = IDNUM(dataPort.SignalSrc[0])
    %switch (id[0])
      %case "y"
        %assign canOut = baseSystem.Interface.CanonicalOutputArgDef[id[1]]
        %assign arg = LibGetRecordIdentifier(canOut)
        %<SLibAccessArgHelper(canOut,"","")>
        %assert !ISFIELD(dataPort, "BusSelElIdx")
        %if dataPort.SignalOffset[0] != 0
          %% must be passed as pointer arg to parent
          %assert canOut.PassByReturn == "no"
          %% if child takes as pointer
          %if passByPtr
            %assign arg = "&%<arg>[%<dataPort.SignalOffset[0]>]"
            %% if child passes as return
          %else
            %assign arg = "%<arg>[%<dataPort.SignalOffset[0]>]"
          %endif
        %endif
        %% if passed by return from parent
        %if canOut.PassByReturn == "yes"
          %% if child takes as pointer
          %if passByPtr
            %assign arg = "&(%<arg>)"
            %% if child passes as retur
          %else
            %% do nothing
          %endif
          %% else passed to parent as arg
        %else
          %% if child takes as pointer
          %if passByPtr
            %% do nothing
            %% if child passes as return
          %else
            %assign arg = "*%<arg>"
          %endif
        %endif
        %break
      %case "b"
        %assign bo = ::CompiledModel.BlockOutputs.GlobalBlockOutput[id[1]]
        %%
        %assign cross = System[bo.SigSrc[0]].CrossNoArgFcnBound
        %assign name  = SLibCG_GetVarGroupElementPath(bo.VarGroupIdx, ...
          baseSystemIdx, cross)
        %assign opW   = SLibGet1DArrayIndexer(LibGetRecordSymbolicWidth(bo), "", "", dataPort.SignalOffset[0])
        %assign arg   = "%<name>%<opW>"
        %if passByPtr
          %assign arg = "&(%<arg>)"
        %endif
        %break
      %case "E"
        %if passByPtr
          %assign arg = LibBlockOutputSignalAddr(portIdx, "", "", 0)
        %else
          %assign arg = LibBlockOutputSignal(portIdx, "", "", 0)
        %endif
        %break
    %endswitch
  %else
    %if passByPtr
      %assign arg = LibBlockOutputSignalAddr(portIdx, "", "", 0)
    %elseif passByRef
      %% C++ pass by reference
      %assign arg = LibBlockOutputSignal(portIdx, "", "", 0)
      %if LibBlockOutputSignalIsMatrix(portIdx)
        %assign dtypeName = LibBlockOutputSignalDataTypeName(portIdx, "")      
        %assign symbWidth = LibBlockOutputSignalSymbolicWidth(portIdx)      
        %assign arg = "(" + dtypeName + "(&)" + "[" + symbWidth + "])"  +  arg
      %endif
    %endif
  %endif
  %assert !ISEMPTY(arg) || (!passByPtr && !passByRef)
  %return arg
%endfunction %% SLibGetModelBlockOutput

%% Function: LibBlockParamNonVolatilePtrCast ======================================
%% Abstract:
%%   Get the cast that discards the volatility of a block parameter pointer.
%%
%function LibBlockParamNonVolatilePtrCast(param)
  %assign record = FcnBlockParameterIdxMemberStr(param)
  %assign paramIdx = record.param
  %assign cast = ""
  
  %% Only care volatile custom storage
  %if (paramIdx[0] != -1) && (!paramIdx[1])
    %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[paramIdx[0]]
    %assign storageClass = mdlParam.StorageClass
    %if storageClass == "Custom"
      %assign msDefn = SLibGetMemorySectionDefForData(mdlParam)
      %assign dtypeId = LibGetRecordDataTypeId(mdlParam)
      %assign cmplx = LibGetRecordIsComplex(mdlParam)
      %assign cast = LibGetNonVolatileCmplxPointerCast(msDefn, dtypeId, cmplx, "")
    %endif
  %endif
  %return cast
%endfunction %%LibBlockParamNonVolatilePtrCast

%% Function: LibBlockParameterAddrForModelBlock ================================
%% Abstract:
%%   Get Block Parameter Addresss for Model Block
%%
%function LibBlockParameterAddrForModelBlock(param, blkPrmIdx) 
  %assign prmSize = SLibGetSizeOfValueFromParamRec(param)
  %assign nRows   = prmSize[0]
  %assign nCols   = prmSize[1]
  %assign memberStr = ""

  %if nRows > 1
    %assign errTxt = "Number of rows greater than 1.  Must " ...
      "access parameter %<param.Name> using LibBlockMatrixParameterAddr."
    %<LibBlockReportError([], errTxt)>
  %endif
  
  %assign sigIndexer   = SLibGet1DArrayIndexer(nCols, "", "", 0)
  %assign useIndex  = TLC_TRUE
  %if CanUseSimpleReferenceFormat(param, sigIndexer)
    %assign useIndex  = TLC_FALSE
  %endif
 
  %assign ident = SLibInvokeTLCInterface(SLibGetCurrentBlock(), ...
      "BlkParam", 0, blkPrmIdx, TLC_FALSE, "", "", "", "")
  %assign cast = LibBlockParamNonVolatilePtrCast(param)
  
  %assign parsingEnabled = !ISEMPTY(ident)
  %if !parsingEnabled
    %return LibBlockParameterAddr(param, "", "", 0)
  %endif
  %if useIndex
    %return "%<cast>&%<ident>%<sigIndexer>"
  %else
    %return cast + ident
  %endif
 %endfunction  

%% Function: LibBlockParameterForModelBlock
%% Abstract:
%%   Get block parameter for a model block with parameter index
%%   Note: this function is adapted from LibBlockParameter
%%
%function LibBlockParameterForModelBlock(param, blkPrmIdx)
  %% Determine the parameter's true size
  %assign prmSize = SLibGetSizeOfValueFromParamRec(param)
  %assign nRows   = prmSize[0]
  %assign nCols   = prmSize[1]
  %assign width   = nRows * nCols

  %if SLibGetTypeOfValueFromParamRec(param) == "Matrix"
    %% exit if the parameter is a true matrix,
    %% i.e., has more than one row or columns.
    %if nRows > 1
      %assign errTxt = "Must access parameter %<param.Name> using "...
        "LibBlockMatrixParameter."
      %<LibBlockReportError([], errTxt)>
    %endif
  %endif
  %with ::CompiledModel
    %assign accSysIdx = BlockIdx[0]
    %assign parentSys = System[accSysIdx]
    %if LibSystemIsRoot(parentSys)
      %assign callSite = [%<accSysIdx>, 0, %<accSysIdx>, %<BlockIdx[2]>]
    %else
      %assign callSite = parentSys.CallSites[0]
    %endif
  %endwith
  
  %assign str = SLibInvokeTLCInterface(SLibGetCurrentBlock(), ...
      "BlkParam", 0, blkPrmIdx, TLC_FALSE, "", "", "", "")

  %assign tlcIFv2Enabled = !ISEMPTY(str)
     
  %if tlcIFv2Enabled
    %return SLibProcessSafeExpression(Name, ...
      (param.NeedParenthesis ? "(%<str>)" : str), 0)
  %else
    %return LibBlockParameter(param, "", "", 0)
  %endif
%endfunction 

%% Function: LibBlockParameterForMdlRef ========================================
%% Abstract:
%%   Return the parameter for a model reference block and parameter index
%%
%function SLibGetModelBlockParameter(aBlock, aPrmIdx, aArgInfo, ...
  argType, isPointer) void
  %assign blkParam = aBlock.Parameter[aPrmIdx]
  %if isPointer
    %assign cast = ""
    %assign blkParamType = ...
      LibGetDataTypeNameFromId(LibGetRecordContainerDataTypeId(blkParam))
    %if argType != blkParamType
      %assign cast = "(" + argType + "*)"
    %endif
    %return cast + LibBlockParameterAddrForModelBlock(blkParam, aPrmIdx)
  %elseif aArgInfo == 1 
    %return LibBlockParameterForModelBlock(blkParam, aPrmIdx)
  %else
    %return LibBlockParameterAddrForModelBlock(blkParam, aPrmIdx)
  %endif
%endfunction

%% Function: SLibGetModelBlockVarGroupPath =====================================
%% Abstract:
%%
%function SLibGetModelBlockVarGroupPath(aBaseSystemIdx, aBlock, aInstanceIdx) void
  %assign thisSystem = ::CompiledModel.System[aBlock.BlockIdx[0]]
  %assign category = FcnGetModelBlockDWorkCategory(aBlock)
  %if category == "Self"
    %assign thisSystem = ::CompiledModel.System[baseSystemIdx]
    %assign varGroupIdx = thisSystem.SelfVarGroupIndex
  %else
    %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, category, aInstanceIdx)
  %endif

  %assign cross = thisSystem.CrossNoArgFcnBound
  %assign varGroupPath = SLibCGIRVarGroupPath(varGroupIdx, aBaseSystemIdx, cross)
  %return varGroupPath
%endfunction %% SLibGetModelBlockVarGroupPath
  
%% Function: SLibGetModelBlockVarGroupRoot( =====================================
%% Abstract:
%%
%function SLibGetModelBlockVarGroupRoot(aBlock) void
  %assign thisSystem = ::CompiledModel.System[GetBaseSystemIdx()]
  %assign category = FcnGetModelBlockDWorkCategory(aBlock)
  %if category == "Self"
    %assign thisSystem = ::CompiledModel.System[baseSystemIdx]
    %assign varGroupIdx = thisSystem.SelfVarGroupIndex
  %else
    %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, category, 0)
  %endif

  %assign cross = thisSystem.CrossNoArgFcnBound
  %assign varGroupPath = SLibCGIRVarGroupPath(varGroupIdx, GetBaseSystemIdx(), cross)
  %return varGroupPath
%endfunction %% SLibGetModelBlockVarGroupPath
  
%% Function: SLibGetModelBlockStructDWorkArg ===================================
%% Abstract:
%%   Returns the dwork element of a model reference block, that contains
%%   its structured elements.
%%
%function SLibGetModelBlockStructDWorkArg (...
  aDWorkEl, aBaseSystemIdx, aBlock, aSysFcnType, aInstanceIdx) void
  %if !ISEMPTY(aDWorkEl)
    %return aDWorkEl
  %endif
  %assign blockInterface = GetModelrefInterface(aBlock)
  %assign isInstSpecific = (ISFIELD(aBlock, "ModelInstVarIndex") &&  aBlock.ModelInstVarIndex > -1)
  %assign rtmContainedInSelf = isInstSpecific || ...
    (blockInterface.rtmAllocateInParent)
  %assign baseSys = ::CompiledModel.System[GetBaseSystemIdx()]
  %if (::CompiledModel.RTWCGModules.RTWCGModule[baseSys.CGIRModuleIdx].SimplifiedInterface && ...
    blockInterface.usesSimplifiedInterface) || (GenerateClassInterface && SLibGetUseRTMcgType())
    %assign rtmField = SLibGetModelInstVariableAddressForSimplifiedInterface(aBlock,aInstanceIdx,TLC_FALSE)
    %if !WHITE_SPACE(rtmField)
      %return "(*" + rtmField + ")"
    %endif
  %endif
  %if rtmContainedInSelf && SLibGetSelfVarGroupIndex() > -1 && isInstSpecific
    %if aInstanceIdx > 1
      %assign selfVarGroupIdx = aBlock.ModelInstVarGroupIndex+aInstanceIdx
    %else
      %assign selfVarGroupIdx = SLibGetSelfVarGroupIndex()
    %endif
    %assign selfCGTypeIdx = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].CGTypeIdx
    %if selfCGTypeIdx < 0
      %assign group = ::CompiledModel.CoderDataGroup[SLibGetSelfCoderDataGroupIndex()]
      %return SLibCoderDataGroupElementInstance(group, aBlock.ModelInstVarIndex)
    %endif
    %assign fldName = ::CompiledModel.CGTypes.CGType[selfCGTypeIdx].Members.Member[aBlock.ModelInstVarIndex].Name
    %if selfVarGroupIdx != SLibGetSelfVarGroupIndex()
      %% here we are not at the root level
      %return ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].LocalName + "->" + fldName
    %elseif IsModelReferenceTarget() && IsModelRefScalableBuild()
      %% here we are in a single instance model that contains multi instance child models
      %assign modelDW = FcnGetSFcnDWorkIdentifier(::CompiledModel.System[baseSystemIdx])
      %assign slfAccess = IsModelReferenceSimTarget() ? ".rtm." : "."
      %return modelDW + slfAccess + fldName
    %else
      %if SLibIsSelfStructured()
        %<SLibCG_AccessRTM()>
      %endif
      %assign modelRTM = ::tSimStruct
      %return modelRTM + "->" + fldName
    %endif
  %elseif blockInterface.rtmAllocateInParent && !SLibIsSelfInSimTarget()
    %return aBlock.Identifier
  %endif
  %assign dworkIdx = SLibGetStructDWorkIdxForModelRefBlk(aBlock)
  
  %if "RegistrationFcn" == aSysFcnType
    %assign varGroupPath = ...
      SLibGetModelBlockVarGroupPath(aBaseSystemIdx, aBlock, aInstanceIdx)
    %assign dwRec = ...
      ::CompiledModel.DWorks.DWork[aBlock.DWork[dworkIdx].FirstRootIdx]
    %return varGroupPath + LibGetRecordIdentifier(dwRec)
  %endif
  
  %return LibBlockDWork(aBlock.DWork[dworkIdx], "","","0")
%endfunction

%% FunctionSLibModelBlockContinuousStateAddr ====================================
%% Abstract:
%%   Return the base address of the continues states argument of a model block. 
%%
%function SLibModelBlockContinuousStateAddr(aBaseSystemIdx, aModelSystemIdx, ...
  aBlock, aSysFcnType, aInstanceIdx) void 
  %assign cs = ::CompiledModel.ContStates.ContState[aBlock.ContStates[1]]
  
  %if "RegistrationFcn" == aSysFcnType
    %assign thisSystem = ::CompiledModel.System[aBlock.BlockIdx[0]]
    %assign varGroupIdx = FcnSysVarGroupIndex(thisSystem, "ContStates", ...
      aInstanceIdx)
    %assign  cross = thisSystem.CrossNoArgFcnBound
    %assign sysIdx =  LibIsDeploymentDiagram() ? aModelSystemIdx : aBaseSystemIdx
    %assign varGroupPath = SLibCGIRVarGroupPath(varGroupIdx, sysIdx, cross)
    %assign intrf    = GetModelrefInterface(aBlock)
    %assign optWidth = (intrf.xOptWidth > 1) ? "[0]" : ""
    %return "&(" + varGroupPath + cs.Identifier + optWidth + ")"
  %endif
  
  %return SLibContinuousStateAddr(cs, aModelSystemIdx)
%endfunction %% SLibModelBlockContinuousStateAddr
  
%% Function: SLibGetMdlRefArgumentForTID
%% Abstract:
%%    For the given TID, get the argument to be passed into the call to
%%    a referenced model function
%%
%function SLibGetMdlRefArgumentForTID(idx)
  %if IsModelReferenceTarget()
    %% if the idx is constant tid, return it. see g1339414
    %if idx == -2
      %assign arg = "%<idx>"
    %else
      %assign arg = "mdlref_TID%<idx>"
    %endif
  %elseif IsSimstructBasedTarget() && LibAsynchronousTriggeredTID(idx)
    %assign arg = "0"
  %else
    %assign arg ="%<idx>"
  %endif

  %return arg
%endfunction

%% Function: SLibGetModelInstVariableAddressForSimplifiedInterface
%% Abstract:
%%   For ModelReference simplified interface, given a Model block
%%   return the pointer to the corresponding model variable access path
%function SLibGetModelInstVariableAddressForSimplifiedInterface(mBlock,aInstanceIdx,globalAccess) void
  %assert mBlock.Type == "ModelReference"
  %assign containedInVargroup = ISFIELD(mBlock, "ModelInstVarGroupIndex") && mBlock.ModelInstVarGroupIndex > -1 && ...
    !(GenerateClassInterface && mBlock.ModelInstVarGroupIndex == SLibGetSelfVarGroupIndex())

  %% Look for global self instance first
  %if SLibPassGlobalInstanceForBlocksSelf(mBlock) && !containedInVargroup
    %return SLibGetGlobalInstanceNameForBlocksSelf(mBlock)
  %endif

  %assign path = ""

  %% See if we can find a path via pointer in Self
  %if SLibIsBlockInstanceAccessedViaPointerInSelf(mBlock)
    %% An example of path here is "self->anotherGroup->inst1"
    %assign path = "(&" + SLibGetPathToInstanceFromSelf(mBlock) + ")"
  %endif

  %if !ISEMPTY(path)
    %return path
  %elseif ISFIELD(mBlock, "ModelInstVarIndex")
    %assign isClassField = (GenerateClassInterface && mBlock.ModelInstVarGroupIndex == SLibGetSelfVarGroupIndex())
    %assign rtmRecIndex = mBlock.ModelInstVarIndex
    %if isClassField && rtmRecIndex > -1
      %return "&" + mBlock.Identifier
    %elseif rtmRecIndex > -1
      %if mBlock.ModelInstVarGroupIndex == SLibGetSelfVarGroupIndex()
        %<SLibCG_AccessRTM()>
        %assign selfPath = getRTMFieldPointerFromCGType("STANDALONE",rtmRecIndex)
        %return "(" + selfPath  + ")"
      %else
        %assign selfVarGroupIdx = mBlock.ModelInstVarGroupIndex+aInstanceIdx
        %assign selfCGTypeIdx = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].CGTypeIdx
        %assign fldName = ::CompiledModel.CGTypes.CGType[selfCGTypeIdx].Members.Member[mBlock.ModelInstVarIndex].Name
        %if globalAccess
          %% we are accessing model instance via the topmost node of self
          %assign vgPath = SLibCGIRVarGroupPath(selfVarGroupIdx,GetBaseSystemIdx(),TLC_TRUE)
        %else
          %assign vgPath = ::CompiledModel.VarGroups.VarGroup[selfVarGroupIdx].LocalName + "->"
        %endif
        %assign selfPath = "&" + vgPath + fldName
        %return "(" + selfPath  + ")"
      %endif
    %endif
  %endif
  
  %return ""
%endfunction

%function SLibGetModelBlockRegistrationFunction(block,blkPath,blockInterface,instIdx,childIdx)
  %assert GenerateClassInterface && block.MdlRefIsCPPClassGenMode
  %assign mdlRefInstCPPVar = ...
    SLibGetCPPMdlRefObjName(System[BlockIdx[0]].SystemIdx,BlockIdx[2])
  %assign subsysRegFcnForCPPClassModelRefBlock = block.MdlRefIsCPPClassGenMode && ...
    !IsSystemReusableParentBaseSys(BlockIdx[0]) &&...
    (!IsModelRefScalableBuild() || GenerateClassInterface)

  %assign regFcn4MdlRefBlkCPPFromSubSys = subsysRegFcnForCPPClassModelRefBlock && ...
    ISFIELD(block,"CPPObjDWorkIdxInSubsys")

  %if regFcn4MdlRefBlkCPPFromSubSys
    %assign mdlRefInstCPPVar = ...
      SLibGetModelBlockVarGroupPath(baseSystemIdx, block, instIdx) ...
      + mdlRefInstCPPVar
  %elseif subsysRegFcnForCPPClassModelRefBlock && ...
    ISFIELD(block,"ModelInstVarGroupIndex") && ...
    block.ModelInstVarGroupIndex > -1
    %assign mdlRefInstCPPVar = ...
      SLibCGIRVarGroupPath(block.ModelInstVarGroupIndex,GetBaseSystemIdx(),TLC_FALSE) ...
      + mdlRefInstCPPVar
  %endif

  %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)
  %openfile tmp_file
  %%%% re-establish pointers for mdlref blocks in subsystems, if needed
  %if regFcn4MdlRefBlkCPPFromSubSys && ...
    CPPEncapNeedsLocalVars(TLC_FALSE) && ...
    !blockInterface.IsScalableBuild
    %assign restoreCode = SLibGetCPPEncapInitCopyCode(TLC_FALSE, TLC_FALSE)
    %<restoreCode>
  %endif

  %%%% this must be called early on
  %if blockInterface.RTMAccessed
    /* initialize real-time model for %<Type> Block: '%<Name>' */
    %<mdlRefInstCPPVar>%<dotOrArrow>initializeRTM();
  %endif
  %if blockInterface.NeedsErrorStatus
    /* Set error status pointer for %<Type> Block: '%<Name>' */
    %<mdlRefInstCPPVar>%<dotOrArrow>setErrorStatusPointer(%<RTMsGet(System[GetBaseSystemIdx()],"ErrorStatusPointer")>);
  %endif
  %% Setup the stop requested flag
  %if blockInterface.StopReqAccessed
    /* initialize stop requested flag */
    %<mdlRefInstCPPVar>%<dotOrArrow>setStopRequestPointer(%<RTMsGet(System[GetBaseSystemIdx()],"StopRequestedPtr")>);
  %endif
  %assign timingArgs = []

  %assign timingArgs = SLibAttachTimingArgsForCPPEncap(block,blockInterface,timingArgs)

  %if !ISEMPTY(timingArgs)
    %foreach idx = SIZE(timingArgs,1)
      %if idx == 0
        %assign fcnArgs = timingArgs[idx]
      %else
        %assign fcnArgs = fcnArgs + ", %<timingArgs[idx]>"
      %endif
    %endforeach
    %<mdlRefInstCPPVar>%<dotOrArrow>setupGlobalTimingEngine(%<fcnArgs>);
  %endif
  %if ISFIELD(blockInterface, "RegistrationFcn") && GenerateClassInterface
    %% Invoke C++ initialize before setting fields to non-zero values
    %<mdlRefInstCPPVar>%<dotOrArrow>initialize();
  %endif

  %assert block.ContStates[0] <= 0

  %if ISFIELD(blockInterface, "RegFcnNeedsCAPIArgs") && ...
    blockInterface.RegFcnNeedsCAPIArgs

    %if RTWCAPI == 1 && !block.ParamSettings.InsideForEachSS
      %assign arg1 = "&(%<RTMGet("DataMapInfo")>.mmi)"
      %assign fcnArgs = "%<arg1>," + "\"%<blkPath>\"," + ...
        "%<childIdx>," + "-1"
    %else
      %assign capiArgs = []
      %assign capiArgs = capiArgs + SLibGetNullDefinitionFromTfl()
      %assign capiArgs = capiArgs + SLibGetNullDefinitionFromTfl()
      %assign capiArgs = capiArgs + "0"
      %assign capiArgs = capiArgs + "-1"

      %foreach idx = SIZE(capiArgs,1)
        %if idx == 0
          %assign fcnArgs = capiArgs[idx]
        %else
          %assign fcnArgs = fcnArgs + ", %<capiArgs[idx]>"
        %endif
      %endforeach
    %endif %% RTWCAPI == 1

    %<mdlRefInstCPPVar>%<dotOrArrow>setupCAPIInfo(%<fcnArgs>);
  %endif %%RegFcnNeedsCAPIArgs
  %if ISFIELD(blockInterface, "RegistrationFcn") && !GenerateClassInterface
    %<mdlRefInstCPPVar>%<dotOrArrow>initialize();
  %endif
  %closefile tmp_file

  %return tmp_file
%endfunction

%% Function: SLibCallModelBlockFunction ========================================
%% Abstract:
%%   Contruct a string which is a call to some function in a referenced model.
%%
%function SLibCallModelBlockFunction(outAndRuleIdx, block, sysFcnName, ...
  blockInterface, fcnInfo, instIdx, tid, childIdx, blkPath)
  %% Initially assume there is no outport returned by value (set retArgPortIdx to -1)
  %assign retArgPortIdx = -1
  %assign fcnName = fcnInfo.FcnName
  %if block.MdlRefIsCPPClassGenMode
    %assign fcnName = FEVAL("regexprep", fcnName,"^[a-zA-Z0-9_]*::", "")
  %endif
  %assign args  = []
  %assign canInputInfo = fcnInfo.Inputs
  %assign canOutputInfo = fcnInfo.Outputs
  %assign canPrmArgInfo = fcnInfo.PrmArgs
  %assign baseSystemIdx = GetBaseSystemIdx()
  %assign blkSimpInterface = blockInterface.usesSimplifiedInterface
  %if TYPE(fcnInfo.PrmTypes) == "Vector"
    %assign prmTypes = fcnInfo.PrmTypes
  %else
    %assign prmTypes = []
    %assign prmTypes = prmTypes + fcnInfo.PrmTypes
  %endif
    
  %if TYPE(fcnInfo.PrmIsPointer) == "Vector"
    %assign prmIsPointer = fcnInfo.PrmIsPointer
  %else
    %assign prmIsPointer = []
    %assign prmIsPointer = prmIsPointer + fcnInfo.PrmIsPointer
  %endif
      
  %% If we aren't generating the registration function, then
  %% instanceIdx must be 0 since we don't use it.
  %assert (sysFcnName == "RegistrationFcn") || (instIdx == 0)

  %assign TIDIdx = 0
  %assign RTModelIdx = 1
  %assign BlockIOIdx = 2
  %assign DWorkIdx   = 3
  %assign ContStatesIdx = 4
  %assign ContStatesDerivativeIdx = 5
  %assign ContStatesDisabledIdx   = 6
  %assign ContStatesAbsoluteToleranceIdx   = 7
  %assign NonsampledZCIdx = 8
  %assign ZCEventIdx      = 9
  
  %% Variables for the sfcnInfo and timing bridge index of the components 
  %% in a deployment diagram
  %assign sfcnInfoIdx     = 0
  %assign timingBridgeIdx = 0
  
  %% figure out which model block we're looking at
  %assign mdlRefIdx   = -1
  %assign mSysIdx     = 0
  %foreach rowIdx = SIZE(::CompiledModel.ModelReferenceBlocks, 0)
    %assign mdlRefBlk = ::CompiledModel.ModelReferenceBlocks[rowIdx]
    %if ((BlockIdx[0] == mdlRefBlk[0]) && (BlockIdx[2] == mdlRefBlk[1]) && ...
         ((instIdx == mdlRefBlk[2]) ...
         || (LibIsDeploymentDiagram() && ...
         !SLibDeploymentDiagramIsMapped(mdlRefBlk[0]))))
      %assign mdlRefIdx  = rowIdx 
      %assign mdlRefInfo = ::CompiledModel.ModelReferenceBlocks[mdlRefIdx]
      %assign mSysIdx    = mdlRefInfo[0]
      %break
    %elseif SLibIsMappedSystemInDeploymentDiagram(mdlRefBlk[0])
        %assign blk          = System[mdlRefBlk[0]].Block[mdlRefBlk[1]]
        %assign blkInterface = GetModelrefInterface(blk)
        %if blkInterface.NeedsGlobalTimingEngine
          %assign timingBridgeIdx = timingBridgeIdx + 1
        %endif
        %if blkInterface.HasNonInlinedSfcn
          %assign sfcnInfoIdx = sfcnInfoIdx + 1
        %endif
      %endif
  %endforeach

  %if LibIsDeploymentDiagram() 
      %assign timingBridgeName = "%<SLibDeploymentGetTimingBridgeName()>[%<timingBridgeIdx>]"
  %endif
  
  %if (sysFcnName == "RegistrationFcn" && !IsSimstructBasedTarget())
    %if blockInterface.NeedsFirstTime
      %assign arg = "1"
      %assign args = args + "%<arg>"
    %endif
    
    %if blockInterface.NeedsErrorStatus
      %assign arg = "%<RTMGet("ErrorStatusPointer")>"
      %assign args = args + "%<arg>"
    %endif
    
    %if blockInterface.StopReqAccessed
      %if IsModelReferenceTarget()
	%assign arg = "rt_stopRequested"
      %else
        %assign arg = "%<RTMGet("StopRequestedPtr")>"
      %endif
      %assign args = args + "%<arg>"
    %endif
    
    %if TYPE(TID) == "Vector"
      %assign tid0 = TID[0]
    %else
      %assign tid0 = TID
    %endif
    %% For continuous time referenced models, pass the
    %% solverInfo to the submodel.  In the case of
    %% non-ERT top models, the solverInfo is a pointer
    %% in the rtModel, but for ERT it's not a pointer.
    %if (TYPE(tid0) == "Number" && LibIsContinuous(tid0)) || blockInterface.HasNonInlinedSfcn
      %if LibIsDeploymentDiagram() 
        %% find task idx to whom is mapped TID0 of system mSysIdx
        %assign rtmIdx = SLibDeploymentGetTaskIndexForComponent(mSysIdx, 0)
      %endif
      %if IsModelReferenceTarget()
        %assign arg = "rt_solverInfo"
      %elseif SLibIsERTCodeFormat()
        %if LibIsDeploymentDiagram()
          %if !ISEQUAL(rtmIdx, -1)
            %assign rtmName = "%<SLibDeploymentGetTasksRTMVarName()>[%<rtmIdx>]" 
            %assign arg = "&(%<SLibDeploymentRTMGet("RTWSolverInfo", rtmName)>)"
          %else
            %assign arg = "&(%<RTMGet("RTWSolverInfo")>)"
          %endif
        %else
          %if UsingMalloc
            %assign arg = "%<RTMGet("RTWSolverInfo")>"
          %else
            %assign arg = "&(%<RTMGet("RTWSolverInfo")>)"
          %endif
        %endif
      %elseif LibIsDeploymentDiagram()
        %if !ISEQUAL(rtmIdx, -1)
          %assign rtmName = "%<SLibDeploymentGetTasksRTMVarName()>[%<rtmIdx>]" 
          %assign arg = "%<SLibDeploymentRTMGet("RTWSolverInfo", rtmName)>"
        %else
          %assign arg = "%<RTMGet("RTWSolverInfo")>"
        %endif
      %else
        %assign arg = "%<RTMGet("RTWSolverInfo")>"
      %endif
      %assign args =  args + "%<arg>"
    %endif
    
    %if blockInterface.HasNonInlinedSfcn
      %if IsModelReferenceTarget()
        %assign arg = "rt_sfcnInfo"
      %elseif SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
        %assign arg = "(RTWSfcnInfo *)(%<SLibDeploymentGetTasksSfcnInfoVarName()>[%<sfcnInfoIdx>])"
      %else
        %assign arg = "(RTWSfcnInfo *)(%<RTMGet("RTWSfcnInfo")>)"
      %endif
      %assign args =  args + "%<arg>"
    %endif
  %endif
  %%
  %%
  %% TID
  %if fcnInfo.ArgInfo[TIDIdx] == 1
    %assert sysFcnName != "RegistrationFcn"
    %if ISEQUAL(tid,"")
      %assign arg = LibTID()
    %else
      %assign arg = %<tid>
    %endif
    %assign args = args + "%<arg>"
  %endif

  %if sysFcnName == "SetDimsFcn"
    %assign args = args + outAndRuleIdx[0]
    %assign args = args + outAndRuleIdx[1]
  %endif

  %assign FPC = []
  
  %% We do not honor the Function Prototype Control for a
  %% referenced model when generating code for:
  %%  * Model Reference SIM Target
  %%  * Top-level rapid-accelerator
  %if (sysFcnName == "OutputUpdateFcn") && ...
    !IsModelReferenceSimTarget() && ...
    !isRAccel
    %assign FPC = blockInterface.FPC
  %endif
  %if !ISEMPTY(FPC)
    %assign fcnName = FPC.FunctionName
  %endif

  %if GenerateClassInterface && block.MdlRefIsCPPClassGenMode
    %if sysFcnName == "RegistrationFcn"
      %assign fcnName = "initialize"
    %elseif sysFcnName == "InitializeFcn"
      %assign fcnName = "init"
    %elseif sysFcnName == "SystemInitializeFcn"
      %assign fcnName = "init"    
    %elseif sysFcnName == "SystemResetFcn"
      %assign fcnName = "reset"
    %elseif sysFcnName == "StartFcn"
      %assign fcnName = "start"
    %elseif sysFcnName == "TerminateFcn"
      %assign fcnName = "terminate"
    %elseif sysFcnName == "DisableFcn"
      %assign fcnName = "disable" 
    %elseif sysFcnName == "EnableFcn"
      %assign fcnName = "enable"
    %endif
    
    %assign mdlRefInstCPPVar = ...
      SLibGetCPPMdlRefObjName(System[BlockIdx[0]].SystemIdx,BlockIdx[2])
    
  %endif %% GenerateClassInterface && block.MdlRefIsCPPClassGenMode
  
  %assign NumInputs  = CAST("Number", blockInterface.NumInputs)
  %assign NumOutputs = CAST("Number", blockInterface.NumOutputs)
    
  %if IsFPCIgnored(FPC)
    %assign NumArgs = NumInputs + NumOutputs
  %else
    %assign NumArgs = SIZE(FPC.ArgSpecData,1)
  %endif
  
  %assign mdlBlkDWork = ""
  
  %%
  %% The following TLC code is used to prune the CGIR function call
  %% arguments and transfer the CGIR argument tracking 
  %% information to the legacy TLC trackig infrastructure.
  %%
  %assign numCanDWorks   = SIZE(fcnInfo.DWArgs, 1)
  %assign numPrmArgs     = SIZE(canPrmArgInfo,1)
  %assign skipCanInput   = Vector(%<NumInputs>)    [0@%<NumInputs>]
  %assign skipInputDims  = Vector(%<NumInputs>)    [0@%<NumInputs>]
  %assign skipCanOutput  = Vector(%<NumOutputs>)   [0@%<NumOutputs>]
  %assign skipOutputDims = Vector(%<NumOutputs>)   [0@%<NumOutputs>]
  %assign skipCanDWork   = Vector(%<numCanDWorks>) [0@%<numCanDWorks>]
  %assign skipCanParam   = Vector(%<numPrmArgs>)   [0@%<numPrmArgs>]
  %assign rtmContainedInSelf = (ISFIELD(block, "ModelInstVarIndex") &&  block.ModelInstVarIndex > -1) || ...
    (blockInterface.rtmAllocateInParent && ::isRAccel)
  %assign skipRTM = 0
  %assign skipLocalB = blockInterface.usesSimplifiedInterface || (blockInterface.rtmAllocateInParent)
  %assign skipLocalDW = blockInterface.usesSimplifiedInterface || (blockInterface.rtmAllocateInParent)
  %assign skipLocalX = 0
  %assign skipLocalXdot = 0
  %assign skipLocalXdis = 0
  %assign skipLocalXabstol = 0
  %assign skipLocalZCSV = 0
  %assign skipLocalZCE = 0

  %if IsFPCIgnored(FPC)
    %assign numFcnInfoArgs = CAST("Number", fcnInfo.NumArgs)
    %foreach argIdx = numFcnInfoArgs
      %assign idNum = SLibSafeIDNUM(fcnInfo.ArgSource, argIdx)
      %assign argSrc = idNum[0]
      %assign argSrcIdx = idNum[1]
      %switch argSrc
        %case "I" %% canonical input
          %assign arg = SLibGetModelBlockInput(mSysIdx, block, sysFcnName, ...
            mdlRefIdx, argSrcIdx, canInputInfo, FPC, argIdx)
          %assert !ISEMPTY(arg)
          %assign args = args + "%<arg>"
          %assign skipCanInput[argSrcIdx] = 1
          %break
        %case "O" %% canonical output
          %assign arg = SLibGetModelBlockOutput(sysFcnName,  mdlRefIdx, ...
            argSrcIdx, FPC, argIdx)
          %assert !ISEMPTY(arg)
          %assign args = args + "%<arg>"
          %assign skipCanOutput[argSrcIdx] = 1
          %break
        %case "D" %% canonical dwork
          %if blkSimpInterface
            %assign skipCanDWork[argSrcIdx] = 1
            %break
          %endif
          %assign dimsIdNum = SLibSafeIDNUM(fcnInfo.Association, argIdx)
          %assign dimsSrc = dimsIdNum[0]
          %assign dimsSrcIdx = dimsIdNum[1]
          %assert "I" == dimsSrc || "O" == dimsSrc
          %if "I" == dimsSrc
            %assign arg = SLibGetInputCanDimSizeDWForFunctionStr(block, ...
              dimsSrcIdx, fcnInfo, sysFcnName)
            %assert !ISEMPTY(arg)
            %assign args = args + "%<arg>"
            %assign skipInputDims[dimsSrcIdx] = 1
          %else
            %assign arg = SLibGetOutputCanDimSizeDWForFunctionStr(block, ...
              dimsSrcIdx, fcnInfo, sysFcnName)
            %assert !ISEMPTY(arg)
            %assign args = args + "%<arg>"
            %assign skipOutputDims[dimsSrcIdx] = 1
          %endif
          %assign skipCanDWork[argSrcIdx] = 1
          %break
        %case "P" %% canonical parameter
          %if blkSimpInterface
            %break
          %endif
          %assign argInfo = canPrmArgInfo[argSrcIdx]
          %assign prmType = prmTypes[argSrcIdx]
          %assign isPointer = (1 == prmIsPointer[argSrcIdx])
          %assert argInfo >= 1
          %assign numBlockParamArgs = block.ParamSettings.NumBlockParamArgs
          %assign arg = SLibGetModelBlockParameter(block, argSrcIdx+numBlockParamArgs, argInfo, ...
            prmType, isPointer)
          %assert !ISEMPTY(arg)
          %assign args = args + "%<arg>"
          %assign skipCanParam[argSrcIdx] = 1
          %break
        %case "RTM"
          %if blkSimpInterface || (blockInterface.rtmAllocateInParent && rtmContainedInSelf)
            %assign rtmAccess = SLibGetModelInstVariableAddressForSimplifiedInterface(block,instIdx,TLC_FALSE)
          %elseif SLibGetStructDWorkIdxForModelRefBlk(block) < 0 || (blockInterface.rtmAllocateInParent && !SLibIsSelfInSimTarget())
            %assign rtmAccess = "&" + block.Identifier
          %else
            %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
              baseSystemIdx, block, sysFcnName, instIdx)
            %assign rtmField = rtmContainedInSelf ? "" : ".rtm"
            %assign rtmAccess =  "&(%<mdlBlkDWork>%<rtmField>)"
          %endif
          %assign args = args + rtmAccess
          %assign skipRTM = 1
          %break
        %case "LB" %% block IO
          %if blkSimpInterface
            %assign skipLocalB = 1
            %break
          %endif
          %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
            baseSystemIdx, block, sysFcnName, instIdx)
          %assign rtmField = rtmContainedInSelf ? ".blockIO" : ".rtb"
          %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
          %assign skipLocalB = 1
          %break
        %case "LW" %% dwork
          %if blkSimpInterface
            %assign skipLocalDW = 1
            %break
          %endif
          %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
            baseSystemIdx, block, sysFcnName, instIdx)
          %assign rtmField = rtmContainedInSelf ? ".dwork" : ".rtdw"
          %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
          %assign skipLocalDW = 1
          %break
        %case "LX" %% continues states
          %assign arg = SLibModelBlockContinuousStateAddr(baseSystemIdx, ...
            mSysIdx, block, sysFcnName, instIdx)
          %assign args = args + "%<arg>"
          %assign skipLocalX = 1
          %break          
        %case "LDX" %% derivatives
          %assert (sysFcnName != "RegistrationFcn")
          %assign arg  = SLibContinuousStateDerivativeAddr(mSysIdx)
          %assign args = args + "%<arg>"
          %assign skipLocalXdot = 1
          %break          
        %case "LXDI" %% continues state disabled
          %assert (sysFcnName != "RegistrationFcn")
          %assign arg = SLibContStateDisabledAddr(mSysIdx)
          %assign args = args + "%<arg>"
          %assign skipLocalXdis = 1
          %break
        %case "LXAT" %% continues state absolute tolerance
          %assert (sysFcnName != "RegistrationFcn")
          %assign arg = SLibContStateAbsoluteToleranceAddr(mSysIdx)
          %assign args = args + "%<arg>"
          %assign skipLocalXabstol = 1
          %break
        %case "LZ" %% non-sampled zero crossings
          %assert (sysFcnName != "RegistrationFcn")
          %assign arg  = SLibNonsampledZCAddr()
          %assign args = args + "%<arg>"
          %assign skipLocalZCSV = 1
          %break 
        %case "LZE" %% zero crossing events
          %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
            baseSystemIdx, block, sysFcnName, instIdx)
          %assign args = args + "&(%<mdlBlkDWork>.rtzce)"
          %assign skipLocalZCE = 1
          %break
        %case "X" %% unknown agument type
          %break
        %case "LC" %% constat block IO
        %case "LP"  %% parameter
        %case "LCP" %% constant parameter
        %case "LPI" %% const parameter with init
        %default
          %%START_ASSERT
          %assign errTxt = "Unhandled argument type '%<argSrc>'."
          %<LibBlockReportError([],errTxt)>
          %break
          %%END_ASSERT              
      %endswitch
    %endforeach
  %endif

  %foreach argIdx = NumArgs
    %if IsFPCIgnored(FPC)
      %if argIdx < NumInputs
        %assign portIdx = argIdx
        %assign SLObjectType = "Inport"
      %else
        %assign portIdx = argIdx - NumInputs
        %assign SLObjectType = "Outport"
      %endif
    %else
      %assign portIdx = CAST("Number", FPC.ArgSpecData[argIdx].PortNum)
      %assign SLObjectType = FPC.ArgSpecData[argIdx].SLObjectType
    %endif
    
    %if SLObjectType == "Inport"      
      %% Consider adding the argument if it is not reusable.
      %if GetTheOtherReusableArgInFPC(FPC, argIdx) < 0
        %if !IsFPCIgnored(FPC) || ...
          (!skipCanInput[portIdx] && canInputInfo[portIdx] > 0)
          %assign arg = SLibGetModelBlockInput(mSysIdx, block, sysFcnName, mdlRefIdx, ...
            portIdx, canInputInfo, FPC, argIdx)
          %assert !ISEMPTY(arg)
          %assign args = args + "%<arg>"
        %endif
      %endif
      %if !skipInputDims[portIdx]
        %assign arg = SLibGetInputCanDimSizeDWForFunctionStr(block, portIdx, ...
          fcnInfo, sysFcnName)
        %if !ISEMPTY(arg)
          %assign args = args + "%<arg>"
        %endif
      %endif
    %else
      %if !IsFPCIgnored(FPC) || ...
        (!skipCanOutput[portIdx] && canOutputInfo[portIdx] == 1)
        %assign arg = SLibGetModelBlockOutput(sysFcnName,  mdlRefIdx, ...
          portIdx, FPC, argIdx)
        %if ISEMPTY(arg)
          %%
          %% If an output is not passed by pointer or ref, it is a return 
          %% argument, passed by value;
          %% save the portIdx; assert that it is unassigned to this point
          %%
          %assert retArgPortIdx == -1
          %assign retArgPortIdx = portIdx
        %else
          %assign args = args + "%<arg>"
        %endif
      %endif
      %if !skipOutputDims[portIdx]
        %assign arg = SLibGetOutputCanDimSizeDWForFunctionStr(block, ...
          portIdx, fcnInfo, sysFcnName)
        %if !ISEMPTY(arg)
          %assign args = args + "%<arg>"
        %endif
      %endif
    %endif
  %endforeach
  %%
  %% SimStruct and noncontinuous output array
  %if sysFcnName == "RegistrationFcn" && IsSimstructBasedTarget()
    %assign args = args + "%<tMdlRefSfcnS>"
    %if RTMIsVarStepSolver() && blockInterface.HasNonContOutput
      %assign name = block.ParamSettings.ReferencedModelName
      %assign mangleName = FcnGetNoncontMangledName(name, BlockIdx[0], ...
        BlockIdx[2], instIdx)
      %assign args = args + "mr_%<mangleName>nonContOutputArray"
    %endif
  %endif

  %% calling the model intialize with right arguments from 
  %% parent model initialize
  %if mdlRefIdx >= 0 && ISFIELD(::CompiledModel.ModelBlock[mdlRefIdx], "DataTransferIndexCount") && ::CompiledModel.ModelBlock[mdlRefIdx].DataTransferIndexCount > 0
    %assign startIdx = ...
      ::CompiledModel.ModelBlock[mdlRefIdx].DataTransferIndexStart
    %assign args = args + "&gblDataTransferIds[%<startIdx>]"
  %endif
    
  %% Pass the timing info to the registration function
  %% Note that we do not need to pass the timing bridge 
  %% for any simstruct based targets.  In this case the rtm 
  %% macros will automatically go through the parent 
  %% simstruct to get the timing bridge.  Note that this is
  %% called for both model reference targets, and models
  %% that contain model blocks.
  %if sysFcnName == "RegistrationFcn" && ...
    !SLibIsCPPEncapMdlRefBuild()
    %if !IsModelReferenceForASimstructBasedTarget() && ...
      SLibIsERTCodeFormat()
      %if blockInterface.NeedsGlobalTimingEngine
        %if IsModelReferenceTarget() 
          %assign args = args + "timingBridge"
        %elseif LibIsDeploymentDiagram()
          %assign args = args + "&%<timingBridgeName>"
        %else
          %assign args = args + "&%<SLibGetGlobalTimingBridge()>"
        %endif
      %endif
      %if blockInterface.NeedVDRMdlRefTiming
        %if IsModelReferenceTarget() 
          %assign args = args + "VDRMdlRefTimingPtr"
        %else
          %assign vdrTiming = RTMGet("VDRMdlRefTiming")
          %assign args = args + "&(%<vdrTiming>)"
        %endif
      %endif
    %endif

    %% If the block is completely constant, then just 
    %% pass 0 as the TID.  If it is inherited, pass the 
    %% TID that this instance is running at.  This will 
    %% help with data logging.
    %if blockInterface.NeedsTIDArgs
      %assign ::tMdlRefNeedTIDArgs = TLC_TRUE
      %assign blockTid = block.TID
      %if TYPE(blockTid) == "Vector"
        %assign nonModelWideEventTids = []
        %assign numTids = SIZE(blockTid)[1]
        %foreach idx = numTids
          %if !SLibParameterChangeEventTID(blockTid[idx])
            %assign nonModelWideEventTids = nonModelWideEventTids + blockTid[idx]
          %endif
        %endforeach
        %if SIZE(nonModelWideEventTids)[1] == 1
          %assign blockTid = nonModelWideEventTids[0]
        %endif
      %endif
      %if TYPE(blockTid) != "Identifier"
        %assign numTids = SIZE(blockTid)[1]
        %if ISFIELD(block.ParamSettings, "ChildTidToParentTidMap")
          %% Loop through TID map to find parent TID for each child TID. 
          %assign childTidToParentMap = block.ParamSettings.ChildTidToParentTidMap
          %assign numTids = SIZE(childTidToParentMap,1)/2
          %foreach tidIdx = numTids
            %assign parentTid = SLibGetMdlRefArgumentForTID(childTidToParentMap[numTids + tidIdx])
            %assign args = args + parentTid
          %endforeach
        %elseif (numTids == 1) && LibAsynchronousTriggeredTID(blockTid) && ...
          !ModelBlockHasAsyncInput(blockTid, block)
          %% if it is in async fcn-call subsystem, all blocks will access the base rate
          %assign args = args + "0"
          %% Add parameter rate if used by model block
          %if blockInterface.HasInternalParameterRate || ...
            blockInterface.HasParameterRateOutput
            %assign args = args + STRING(SLibTidOfParameterChangeEvent())
          %endif
          %% Add irt event rate if used by model block
          %assign args = SLibAttachIRTEventArgs(args)
        
        %else
          %% constant is handled in the loop
          %foreach idx = NumSynchronousSampleTimes + NumAsynchronousSampleTimes
            %assign parentTID = idx
            %assign childTID = MapParentTID2ChildTID(block, parentTID)
            %if childTID != -1
              %assign args = args + SLibGetMdlRefArgumentForTID(idx)
            %endif
          %endforeach
        %endif
      %else
        %% There is only one TID in the model and it
        %% is constant/triggered, pass 0 if it is constant.
        %if ISEQUAL(blockTid, "triggered")
          %if IsModelReferenceSimTarget()
            %% Because of model-wide events, it is possible for the TriggerTID to be an array,
            %% but the first TID is always the container TS.
            %assign args = args + "mdlref_TID%<block.TriggerTID[0]>"
          %else
            %assign args = args + "-1"
          %endif
          %if blockInterface.HasInternalParameterRate
            %assign args = args + STRING(SLibTidOfParameterChangeEvent())
          %endif
          %% Add irt event rate if used by model block
          %assign args = SLibAttachIRTEventArgs(args)
        %else
          %assign args = args + "0"
        %endif
      %endif
    
      %if GetModelRefFcnCallTriggerTIDIsReq(block)
        %if SLibModelNeedsTriggerTIDArg()
          %assign args = args + "mdlref_TriggerTID"
        %else
          %assert ISEQUAL(blockTid, "triggered") || ...
            LibAsynchronousTriggeredTID(blockTid[0])
          %if !ISEQUAL(blockTid, "triggered") && LibAsynchronousTriggeredTID(blockTid[0])
            %assign args = args + "%<blockTid[0]>"
          %else
            %assign trigTid = block.TriggerTID[0]
            %if IsModelReferenceTarget()
              %assign args = args + "mdlref_TID%<trigTid>"
            %else
              %assign args = args + "%<trigTid>"
            %endif
          %endif
        %endif
      %endif
    %endif
  %elseif sysFcnName == "RegistrationFcn" && SLibIsCPPEncapMdlRefBuild() && ...
                        !block.MdlRefIsCPPClassGenMode
    %% This case is the parent model is CPP Encap. 
    %% class, while the referenced
    %% model is CPP (Non-encap), and it is ModelReferenceRTWTarget. 
    %% We need to directly pass the 
    %% local global timing
    %% engine variable, which is already a pointer, to the 
    %% submodel_initialize function. The case of both parent/child 
    %% models being C++ encap. will be handled later by 
    %% setupGlobalTimingEngine 
    
    %assert IsModelReferenceRTWTarget()
    %assign args = SLibAttachTimingArgsForCPPEncap(block,blockInterface,args)
  
  %endif %% sysFcnName == "RegistrationFcn" && !SLibIsCPPEncapMdlRefBuild()

  %assign rtmContainedInSelf = ISFIELD(block, "ModelInstVarIndex") &&  block.ModelInstVarIndex > -1  || ...
    (blockInterface.rtmAllocateInParent && ::isRAccel)
  %%
  %% RTModel
  %if !skipRTM && fcnInfo.ArgInfo[RTModelIdx] == 1
    %if blkSimpInterface || (blockInterface.rtmAllocateInParent && !SLibIsSelfInSimTarget() && !isRAccel)
      %assign isRegFcn = sysFcnName == "RegistrationFcn"
      %assign rtmField = SLibGetModelInstVariableAddressForSimplifiedInterface(block,instIdx,isRegFcn)
      %if SIZE(args,1) > 0 && !isRegFcn
        %assign tmpArgs = []
        %assign tmpArgs = tmpArgs+rtmField
        %foreach idx = SIZE(args,1)
          %assign tmpArgs = tmpArgs + args[idx]
        %endforeach
        %assign args = tmpArgs
      %else
        %assign args = args + rtmField
      %endif
    %elseif SLibGetStructDWorkIdxForModelRefBlk(block) < 0 || (blockInterface.rtmAllocateInParent && !SLibIsSelfInSimTarget())
      %assign rtmArg = "&" + block.Identifier
      %assign args = args + rtmArg
    %else
      %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
          baseSystemIdx, block, sysFcnName, instIdx)
      %assign rtmField = rtmContainedInSelf ? "" : ".rtm"
      %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
    %endif
  %endif
  %%
  %% BlockIO
  %if !skipLocalB && fcnInfo.ArgInfo[BlockIOIdx] == 1
    %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
      baseSystemIdx, block, sysFcnName, instIdx)
    %assign rtmField = rtmContainedInSelf ? ".blockIO" : ".rtb"
    %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
  %endif
  %assign subsysRegFcnForCPPClassModelRefBlock = block.MdlRefIsCPPClassGenMode && ...
    !IsSystemReusableParentBaseSys(BlockIdx[0]) &&...
    (!IsModelRefScalableBuild() || GenerateClassInterface)

  %assign regFcn4MdlRefBlkCPPFromSubSys = subsysRegFcnForCPPClassModelRefBlock && ...
    sysFcnName == "RegistrationFcn" && ...
    ISFIELD(block,"CPPObjDWorkIdxInSubsys")

  %if regFcn4MdlRefBlkCPPFromSubSys
    %assert "RegistrationFcn" == sysFcnName
    %assign mdlRefInstCPPVar = ...
      SLibGetModelBlockVarGroupPath(baseSystemIdx, block, instIdx) ...
      + mdlRefInstCPPVar    
  %elseif subsysRegFcnForCPPClassModelRefBlock && ...
    ISFIELD(block,"ModelInstVarGroupIndex") && ...
    block.ModelInstVarGroupIndex > -1
    %assign mdlRefInstCPPVar = ...
      SLibCGIRVarGroupPath(block.ModelInstVarGroupIndex,sysFcnName != "RegistrationFcn" ? System[BlockIdx[0]].SystemIdx : GetBaseSystemIdx(),TLC_FALSE) ...
      + mdlRefInstCPPVar
  %endif

  %%
  %% DWork
  %if !skipLocalDW && ...
    (fcnInfo.ArgInfo[DWorkIdx] == 1 || regFcn4MdlRefBlkCPPFromSubSys)
    %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
      baseSystemIdx, block, sysFcnName, instIdx)
    %assign rtmField = rtmContainedInSelf ? ".dwork" : ".rtdw"
    %assign args = args + "&(%<mdlBlkDWork>%<rtmField>)"
  %endif
    
  %if (sysFcnName == "RegistrationFcn") && ...
    GenerateClassInterface && block.MdlRefIsCPPClassGenMode
      %return SLibGetModelBlockRegistrationFunction(block,blkPath,blockInterface,instIdx,childIdx)
  %endif %%  (sysFcnName == "RegistrationFcn") && GenerateClassInterface && 
         %%  block.MdlRefIsCPPClassGenMode


  %% All the rest will be supported when ERT supports continuous states/time, we
  %% must test them when that is online.
  %%
  %% ContStates
  %if !skipLocalX && fcnInfo.ArgInfo[ContStatesIdx] == 1
    %assign arg = SLibModelBlockContinuousStateAddr(baseSystemIdx, mSysIdx, ...
      block, sysFcnName, instIdx)
    %assign args = args + "%<arg>"
  %endif
  %%
  %% ContStatesDerivative
  %if !skipLocalXdot && fcnInfo.ArgInfo[ContStatesDerivativeIdx] == 1
    %assert (sysFcnName != "RegistrationFcn")
    %assign arg  = SLibContinuousStateDerivativeAddr(mSysIdx)
    %assign args = args + "%<arg>"
  %endif
  %%
  %% ContStatesDisabled
  %if !skipLocalXdis && fcnInfo.ArgInfo[ContStatesDisabledIdx] == 1
    %assert (sysFcnName != "RegistrationFcn")
    %assign arg = SLibContStateDisabledAddr(mSysIdx)
    %assign args = args + "%<arg>"
  %endif
  %%
  %% Continuous States Absolute Tolerance
  %if !skipLocalXabstol && fcnInfo.ArgInfo[ContStatesAbsoluteToleranceIdx] == 1
    %assert (sysFcnName != "RegistrationFcn")
    %assign arg = SLibContStateAbsoluteToleranceAddr(mSysIdx)
    %assign args = args + "%<arg>"
  %endif  
  %%
  %% NonsampledZC
  %if !skipLocalZCSV && fcnInfo.ArgInfo[NonsampledZCIdx] == 1
    %assert (sysFcnName != "RegistrationFcn")
    %assign arg  = SLibNonsampledZCAddr()
    %assign args = args + "%<arg>"
  %endif
  %%
  %% ZCEvent
  %if !skipLocalZCE && fcnInfo.ArgInfo[ZCEventIdx] == 1
    %assign mdlBlkDWork = SLibGetModelBlockStructDWorkArg(mdlBlkDWork, ...
      baseSystemIdx, block, sysFcnName, instIdx)
    %assign args = args + "&(%<mdlBlkDWork>.rtzce)"
  %endif
  %%
  %% MassMatrix
  %if blockInterface.IsLinearlyImplicit
    %assert (::CompiledModel.ModelIsLinearlyImplicit == "yes")
    %if (sysFcnName == "RegistrationFcn")
      %assign mmOffset = SLibBlockMassMatrixPrOffset("","",0)
      %if SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
        %assign tIdx = SLibDeploymentGetTaskIndexForComponent(mSysIdx, 0)
        %assign args = args + ...
          "&(%<SLibDeploymentGetTasksMassMatricesVarName(tIdx)>.pr[%<mmOffset>])"
      %else
        %assign args = args + "&(%<LibGetMassMatrixGlobalPr()>[%<mmOffset>])"
      %endif
    %endif    
  %endif  
  %%
  %% Parameter Arguments
  %foreach argIdx=numPrmArgs
    %assign argInfo = canPrmArgInfo[argIdx]
    %if !skipCanParam[argIdx] && argInfo >= 1
      %assign prmType = prmTypes[argIdx]
      %assign isPointer = (1 == prmIsPointer[argIdx])
      %assign numBlockParamArgs = block.ParamSettings.NumBlockParamArgs
      %assign args = args + ...
        SLibGetModelBlockParameter(block, argIdx+numBlockParamArgs, argInfo, prmType, isPointer)
    %endif
  %endforeach

  %%
  %% In the ModelReference initialization code we need to pass in the systemRan
  %% dwork pointer and the corresponding tid.  All this is already hanging off
  %% the DataMapInfo, so simply index in to the correct array(s).
  %%
  %if (sysFcnName == "RegistrationFcn")
    %if IsModelReferenceSimTarget()
      %assign descIdx = ::CompiledModel.System[BlockIdx[0]].DescSysIdx[instIdx]
      %assign contIdx = ::CompiledModel.SubsystemRanBC.ContextSysIdx[descIdx]
      %assign arg1 = "%<RTMGet("DataMapInfo")>.systemRan[%<contIdx>]"
      %assign arg2 = "%<RTMGet("DataMapInfo")>.systemTid[%<contIdx>]"
      %assign args =  args + "%<arg1>" + "%<arg2>"
    %elseif ::isRAccel
      %assign args = args + "NULL" + "0"
    %endif
  %endif
  
  %% For every child model, when C-API is selected we need to pass the parent 
  %% MMI structure to the child initialize function. The child MMI is cached
  %% inside the parent MMI. Also, the child model instance is assigned the 
  %% corresponding block path in the parent model. Need to pass the block path 
  %% and continous state start index (if states are logged). 
  %if (sysFcnName == "RegistrationFcn")
    %assign blockInterface = GetModelrefInterface(block)
    %if ISFIELD(blockInterface, "RegFcnNeedsCAPIArgs") && ...
      blockInterface.RegFcnNeedsCAPIArgs
      %% Protected model blocks, and blocks inside foreach do not
      %% have any C-API information because they don't log.
      %if (RTWCAPI == 1) && !block.ParamSettings.InsideForEachSS && ...
        !block.ParamSettings.ProtectedModelBlock
        %% The top model has C-API turned on, i.e. it defines a MMI structure.
        %% Need to pass a pointer of the parent MMI to the child model
        %if GenRTModel
          %assign arg1 = "&(%<RTMGet("DataMapInfo")>.mmi)"
        %else
          %%RSim does not use rtModel with the C-API
          %assign arg1 = "&(%<RSimRTWCAPIVarPtr>->mmi)"
        %endif
        
        %% For protected SIM targets, we don't want to use actual blockpaths
        %assign blockPath = blkPath
        %if SLibIsGeneratingSimTargetForProtectedModel()
          %assign blockPath = SLibGetProtectedBlockPath()
        %endif
        
        %assign args = args + "%<arg1>" + "\"%<blockPath>\"" + "%<childIdx>"
        %if (block.ContStates[0] > 0)
          %% Search through all the global ContinuousStates to find the one that is associated
          %% with the Model block and instance to handle code reuse.
          %assign modelBlockSigSrc = [%<block.BlockIdx[0]>, %<instIdx>, %<block.BlockIdx[2]>]
          %with ::CompiledModel.ContStates
            %foreach csIdx = NumContStates
              %if ContState[csIdx].SigSrc == modelBlockSigSrc
                %assign csvIdx = ContState[csIdx].StartIndex
                %break
              %endif
            %endforeach
          %endwith
        %else
          %assign csvIdx = -1
        %endif
        %assign args = args + "%<csvIdx>"
      %else
        %% The top model has not defined a MMI pointer. Pass NULL pointers
        %% to the child model, if the child-model has a MMI structure
        %assign args = args + SLibGetNullDefinitionFromTfl() + SLibGetNullDefinitionFromTfl() + "0" + "-1"
      %endif %% RTWCAPI == 1
    %endif %% blockInterface.RegFcnNeedsCAPIArgs
  %endif %% Registration Functions
  
  %% Fill the return string fcnName(args, ...)
  %assign retStr = ""
  
  %if ISEMPTY(args)
    %% no input argument
    %if !GenerateClassInterface || !block.MdlRefIsCPPClassGenMode
      %assign retStr = "%<retStr>%<fcnName>" + "()"
    %else
      %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)
      %if (!IsSystemReusableParentBaseSys(BlockIdx[0]) || ...
        !(sysFcnName == "RegistrationFcn") || ...
        !IsModelRefScalableBuild()) && ...
        ISFIELD(block,"CPPObjDWorkIdxInSubsys")
        %assign subSysDWRec = SLibGetSubsysDWorkForCPPMdlRefBlk(block)
        %assign theObjArg = LibBlockDWork(subSysDWRec, "","","0")
        %assign retStr = "%<retStr>" + "(" + theObjArg +")%<dotOrArrow>%<fcnName>" + "()"
      %else
        %assign retStr = "%<retStr>" + mdlRefInstCPPVar +"%<dotOrArrow>%<fcnName>" + "()"
      %endif
    %endif
  %else
    %if !GenerateClassInterface || !block.MdlRefIsCPPClassGenMode
      %assign retStr = "%<retStr>%<fcnName>" + "("
    %else
      %assign dotOrArrow = SLibCPPDotOrArrowAccessOperator(block,blockInterface)

      %if (!IsSystemReusableParentBaseSys(BlockIdx[0])||...
          !(sysFcnName == "RegistrationFcn") ||...
          !IsModelRefScalableBuild()) && ...
          ISFIELD(block,"CPPObjDWorkIdxInSubsys")
        %assign subSysDWRec = SLibGetSubsysDWorkForCPPMdlRefBlk(block)
        %assign theObjArg = LibBlockDWork(subSysDWRec, "","","0")
        %assign retStr = "%<retStr>" + "(" + theObjArg +")%<dotOrArrow>%<fcnName>" + "("
      %else
        %assign retStr = "%<retStr>" + mdlRefInstCPPVar +"%<dotOrArrow>%<fcnName>" + "("
      %endif
    %endif
    
    %foreach idx = SIZE(args,1)
      %if idx == 0
        %% one input argument (no comma is needed)
        %assign retStr = retStr + args[idx]
      %else
        %assign retStr =  retStr + ", " + args[idx] 
      %endif
    %endforeach
    %assign retStr = retStr +  ")"
  %endif
  
  %if retArgPortIdx >= 0
    %assign retStr = LibBlockAssignOutputSignal(retArgPortIdx, "", "", 0, retStr)
  %elseif !WHITE_SPACE(retStr)
    %assign retStr = retStr + ";"
  %endif

  %% Insert assignments between reusable inports and outports
  %if !ReuseMdlRefIO 
    %assign retStr = GetReusableInoutAssignmentsFromFPC(...
      FPC, mSysIdx, block, sysFcnName, mdlRefIdx, canInputInfo) + retStr
  %endif 
  
  %return retStr
%endfunction


%% Function: GetFunctionStr  ==================================================
%% Abstract:
%%     The following order is used in FcnGetAdditionalArgs and
%%     FcnAddParametersAndReturn. We must use the same order:
%%           TID
%%           outputIdx (VarDims only)
%%           ruleIdx (VarDims only)
%%           CanonicalInput
%%           CanonicalDWork for CanonicalInput
%%           CanonicalOutput
%%           CanonicalDWork for CanonicalOutput
%%           SimStruct
%%           rtModel
%%           BlockIO
%%           ConstBlockIO (?)
%%           DWork
%%           Prm (?)
%%           ContStates
%%           ContStatesDerivative
%%           ContStatesDisabled
%%           ContStatesAbsoluteTolerance
%%           NonsampledZC
%%           ZCEvent
%%           MassMatrix
%%           NumCanonicalPrm
%%           CanDWork (?)
%%           C-API required arguments (optional)
%%             o sysRan        (mdlrefsim target required)
%%             o sysTID        (mdlrefsim target required)
%%             o MMI           (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o block Path    (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o child Idx     (mdlrefsim required, rtwtarget if RTWCAPI==true)
%%             o Cont State Idx(mdlrefsim required, rtwtarget if RTWCAPIStates)
%%             
%function GetFunctionStr(block, sysFcn, instIdx, tid, childIdx, blkPath) 
  %assign sysFcnName = ISEQUAL(tid,"") ? ...
    "%<sysFcn>Fcn" :  "%<sysFcn>TID%<tid>Fcn"
  %assign blockInterface = GetModelrefInterface(block)
  %assign fcnInfo = blockInterface.%<sysFcnName>
  %return SLibCallModelBlockFunction([], block, sysFcnName, blockInterface, ...
    fcnInfo, instIdx, tid, childIdx, blkPath)
%endfunction %%GetFunctionStr

%function GetSetDimsFunctionStr(outAndRuleIdx, block, sysFcn, instIdx, tid, childIdx, blkPath) 
  %assign sysFcnName = ISEQUAL(tid,"") ? ...
    "%<sysFcn>Fcn" :  "%<sysFcn>TID%<tid>Fcn"
  %assign blockInterface = GetModelrefInterface(block)
  %assign fcnInfo = blockInterface.%<sysFcnName>

  %return SLibCallModelBlockFunction(outAndRuleIdx, block, sysFcnName, blockInterface, ...
    fcnInfo, instIdx, tid, childIdx, blkPath)
%endfunction %%GetFunctionStr

%function GetModelRefFcnCallTriggerTIDIsReq(block) void
  %assign blockInterface = GetModelrefInterface(block)
  %return blockInterface.FcnCallMdlRefTriggerTIDIsReq
%endfunction

%% Function: GetModelRefFcnNeedsTID  ===========================================
%% Abstract:
%%     Returns whether this function uses TID in the argument list, we only
%% need to check this for the update and output functions.
%function GetModelRefFcnNeedsTID(block, sysFcn)
  %assert (sysFcn == "UpdateFcn") || (sysFcn == "OutputFcn") || ...
    (sysFcn == "OutputUpdateFcn")
  %% Note that the TIDidx must match the index in GetFunctionStr above.
  %assign TIDIdx = 0
  %assign needsTID = 0

  %with block
    %assign blockInterface = GetModelrefInterface(block)
    %if ISFIELD(blockInterface, "%<sysFcn>")
      %assign needsTID = blockInterface.%<sysFcn>.ArgInfo[TIDIdx]
    %endif
  %endwith
  %return needsTID
%endfunction

%function FcnEmitInitializerRegion(parent, mdlrefBlock) void
  %openfile buffer
  {
  %assign numElements = SIZE(parent.Elements, 1)
  %foreach eIdx = numElements
    %assign comma = (eIdx < (numElements - 1)) ? "," : ""
    %assign element = parent.Elements[eIdx].Element
    %if TYPE(element) == "String"
      %assign idNum = IDNUM(element)
      %switch idNum[0]
        %% Reference to coder data group from this model
        %case "RCDG"
            %assign group = ::CompiledModel.CoderGroup[idNum[1]]
            &(%<SLibCoderDataGroupInstance(group)>)%<comma>
          %break
        %% Reference to propagated coder data group from descendent model
        %case "RPCDG"
          %assign group = ::CompiledModel.CoderDataGroups.CoderDataGroup[idNum[1]]
          %assign parentGroupIndex = SLibCoderDataGroupIndex(group.Name)
          %assign parentGroup = ::CompiledModel.CoderDataGroup[parentGroupIndex]
          %if parentGroup.AsStructure != "None"
            %assign parentGroupInstance = SLibCoderDataGroupInstance(parentGroup) + "."
          %else
            %assign parentGroupInstance = ""
          %endif
          &(%<parentGroupInstance>%<group.GroupPath>)%<comma>
          %break
        %case "RVG"
          %assign vargroup = ::CompiledModel.VarGroups.VarGroup[idNum[1]]
          %break
        %case "PD"
          %foreach pads = idNum[1]
            %assign comma2 = (pads < (idNum[1] - 1)) ? "," : ""
            'a'%<comma2>\
          %endforeach
          %<comma>
          %break
        %default
          %<element>%<comma>
          %break
      %endswitch
    %else
      %<FcnEmitInitializerRegion(element, mdlrefBlock)>%<comma>
    %endif
  %endforeach
  }\
  %closefile buffer
  %return buffer
%endfunction

%function FcnEmitInitializer(groupInitializer, mdlrefBlock) void
  %if ISEMPTY(groupInitializer) || WHITE_SPACE(groupInitializer)
    %return ""
  %elseif TYPE(groupInitializer) == "String"
    %return groupInitializer
  %else
    %return FcnEmitInitializerRegion(groupInitializer, mdlrefBlock)
  %endif
%endfunction

%% Function: FcnAdjustInitializer ==============================================================================
%% Abstract:
%%   reformulate the static initializer of a propagated group to the context of this parent model
%%
%function FcnAdjustInitializer(originalInitializer, mdlrefBlock) void
  %if ISEMPTY(originalInitializer) || (TYPE(originalInitializer) == "String")
    %return originalInitializer
  %endif
  %createrecord adjustedInitializer {}
  %assign numElements = SIZE(originalInitializer.Elements, 1)
  %foreach eIdx = numElements
    %assign element = originalInitializer.Elements[eIdx].Element
    %if TYPE(element) == "String"
      %% In case element is a dataref, need to truly make a string to get element[0]
      %assign element0 = STRING(element)[0]
      %assign idNum = IDNUM(element)
      %switch idNum[0]
          %% Non-testpointed model parameter: just replace with the fornatted value
        %case "P"
          %assign blktpIdx = idNum[1]
          %assign prmIdx = mdlrefBlock.Parameter[blktpIdx].ASTNode.ModelParameterIdx
          %assign mdlprm = ::CompiledModel.ModelParameters.Parameter[prmIdx]
          %assign mdltpIdx = mdlprm.TestpointIndex
          %assert mdltpIdx < 0
          %addtorecord adjustedInitializer Elements { Element "%<SLibGetFormattedPrmValue(mdlprm, "")>" }
          %break
          %% Testpointed parameter: adjust to this parent model, unless this parent model 
          %% is a top model in which case replace with the formatted value
        %case "TP"
          %assign blktpIdx = idNum[1]
          %assign prmIdx = mdlrefBlock.Parameter[blktpIdx].ASTNode.ModelParameterIdx
          %assign mdlprm = ::CompiledModel.ModelParameters.Parameter[prmIdx]
          %assign mdltpIdx = mdlprm.TestpointIndex
          %% We don't support testpointed parameters for top model
          %if mdltpIdx < 0 || !IsModelReferenceTarget()
            %if mdlprm.StorageClass == "Custom"
              %assign genType = SLibGetGenerateTypeForData(mdlprm)
              %assign init = GENERATE_TYPE(mdlprm,"DataAccess",genType,"contents","","")
              %addtorecord adjustedInitializer Elements { Element "%<init>" }
            %else
              %addtorecord adjustedInitializer Elements { Element "%<SLibGetFormattedPrmValue(mdlprm, "")>" }
            %endif
          %else
            %addtorecord adjustedInitializer Elements { Element "TP%<mdltpIdx>" }
          %endif
          %break
          %% Padding: preserve as-is
        %case "PD"
          %addtorecord adjustedInitializer Elements { Element element }
          %break
          %% reference to coder data group: convert to reference to propagated group with the index adjusted
          %% to this parent model
        %case "RCDG"
          %assign coderDataGroupIndexMap = mdlrefBlock.CoderDataGroupIndexMap
          %assign mapKey = "Group" + STRING(idNum[1])
          %assign mapValue = coderDataGroupIndexMap.%<mapKey>
          %assign groupIndex = mapValue.CoderDataGroupIndex
          %assign adjustedElement = "RPCDG" + STRING(groupIndex)
          %addtorecord adjustedInitializer Elements { Element adjustedElement }
          %break
          %% Reference to propagated coder data group from descendent model
        %case "RPCDG"
          %assign coderDataGroupIndexMap = mdlrefBlock.CoderDataGroupIndexMap
          %assign mapKey = "ChildGroup" + STRING(idNum[1])
          %assign mapValue = coderDataGroupIndexMap.%<mapKey>
          %assign groupIndex = mapValue.CoderDataGroupIndex
          %assign adjustedElement = idNum[0] + STRING(groupIndex)
          %addtorecord adjustedInitializer Elements { Element adjustedElement }
          %break
          %% Embedded Propagated coder data group from descendent model: preserve as-is
        %case "PCDG"
          %addtorecord adjustedInitializer Elements { Element element }
          %break
          %% Reference to (non-codergroup) vargroup: preserve as-is
        %case "RVG"
          %addtorecord adjustedInitializer Elements { Element %<element> }
          %break
          %% Default for string: preserve as-is
        %default
          %addtorecord adjustedInitializer Elements { Element element }
          %break
      %endswitch
    %elseif TYPE(element) == "Scope"
      %% Recurse for scopes
      %% Initialize to dummy value since addrecord can't handle newlines thus we 
      %% will directly set the value of the new element after adding the dummy value.
      %addtorecord adjustedInitializer Elements { Element 0 }
      %assign init = FcnAdjustInitializer(element, mdlrefBlock)
      %assign numElements = SIZE(adjustedInitializer.Elements, 1)
      %assign adjustedInitializer.Elements[numElements - 1].Element = init
    %else
      %assign errTxt = "Unhandled argument"
      %<LibBlockReportError(mdlrefBlock,errTxt)>
    %endif
  %endforeach
  %return adjustedInitializer
%endfunction

%% Function: FcnAdjustDynamicInitializer ======================================================================
%% Abstract:
%%   reformulate the dynamic initializer of a propagated group to the context of this parent model
%%
%function FcnAdjustDynamicInitializer(originalInitializer, mdlrefBlock, blockInterface, path) void
  %if ISEMPTY(originalInitializer) 
    %return originalInitializer
  %endif
  %createrecord adjustedInitializer {}
  %assign fieldNames = FIELDNAMES(originalInitializer)
  %assign numElements = SIZE(fieldNames, 1)
  %foreach eIdx = numElements
    %assign fieldName = fieldNames[eIdx]
    %assign originalPath = originalInitializer.%<fieldName>
    %assign idNum = IDNUM(fieldName)
    %if idNum[0] == "TP"
      %assign blktpIdx = idNum[1]
      %assign prmIdx = mdlrefBlock.Parameter[blktpIdx].ASTNode.ModelParameterIdx
      %assign mdlprm = ::CompiledModel.ModelParameters.Parameter[prmIdx]
      %assign mdltpIdx = mdlprm.TestpointIndex
      %if blockInterface.OkToMultiInstance
        %assign adjustedPath = path + "." + originalPath
      %else
        %assign adjustedPath = originalPath
      %endif
      %if mdltpIdx >= 0 && !::isRAccel && !Accelerator
        %addtorecord adjustedInitializer TP%<mdltpIdx> adjustedPath
      %else
        %addtorecord adjustedInitializer P%<prmIdx> adjustedPath
      %endif
    %elseif idNum[0] == "P"
      %% Do nothing; swallow it up
    %else
      %assign errTxt = "Unhandled argument type '%<idNum[0]>'."
      %<LibBlockReportError(mdlrefBlock,errTxt)>
    %endif
  %endforeach
  %return adjustedInitializer
%endfunction

%% Function: CallModelrefBlockRegFcns  =========================================
%% Abstract:
%%    Call all child model reference block registration functions.  Note
%% that the input mdlRefBlks can be empty.
%function CallModelrefBlockRegFcns(mdlRefBlks)
  %assign baseSysIdx = GetBaseSystemIdx()
  %openfile modelrefBuffer
  %if !ISEMPTY(mdlRefBlks)
    %assign needsTimingBridgeForDeploymentDiagram = TLC_FALSE
    %% First determine if any of the model blocks in this
    %% model need the global timing engine.
    %foreach rowIdx = SIZE(mdlRefBlks,0)
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx = mdlRefInfo[0]
      %assign bIdx    = mdlRefInfo[1]
      %assign instIdx = mdlRefInfo[2]
      %with ::CompiledModel.System[mSysIdx].Block[bIdx]
        %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
        %assert 0 == blk.DeletedInIR
        %assign blockInterface = GetModelrefInterface(blk)
        %if blockInterface.NeedsGlobalTimingEngine
          %assign ::tMdlRefTimingBridgeAccessed = TLC_TRUE
          %if LibIsDeploymentDiagram() && ...
            !SLibIsMappedSystemInDeploymentDiagram(mSysIdx)
            %assign needsTimingBridgeForDeploymentDiagram = TLC_TRUE
          %endif
          %break
        %endif
      %endwith
    %endforeach
    
    %if !LibIsDeploymentDiagram() || needsTimingBridgeForDeploymentDiagram
    %% We only need to declare a local timing bridge
    %% for ERT based targets.  If the target is simstruct based
    %% (like RSIM), then the simstruct will already have a timing bridge.


    %if !IsModelReferenceTarget() && SLibIsERTCodeFormat() && ...
      ::tMdlRefTimingBridgeAccessed
      %if !MultiInstanceERTCode
        %assign timingVar = "rtTimingBridge %<SLibGetGlobalTimingBridge()>;"
        %<SLibCacheCodeToFile("mdl_data_defn", timingVar)>
        %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", "extern " + timingVar)>
      %endif
      {
        %% Determine if any clockticks are needed.  Note that if a long clock
        %% tick is needed, then the normal clock tick is also needed since they
        %% come in pairs.
        %assign needClockTicks = TLC_FALSE
        %assign needLongClockTicks = TLC_FALSE
        %foreach idx = NumSynchronousSampleTimes
          %if ClockTickForTIDIsReqFcn(idx)
            %assign needClockTicks = TLC_TRUE
            %if LongClockTickForTIDIsReqFcn(idx)
              %assign needLongClockTicks = TLC_TRUE
              %break
            %endif
          %endif
        %endforeach
        
        %if needClockTicks
          static uint32_T *clockTickPtrs[%<NumSampleTimes>];
          %if needLongClockTicks
            static uint32_T *clockTickHPtrs[%<NumSampleTimes>];
          %endif
        %endif    
        %if RTMTimePtrIsReqFcn() || RTMTaskTimeIsReqFcnForTID(0)
          static real_T *taskTimePtrs[%<NumSampleTimes>];
        %endif
        %if ::CompiledModel.SingleRate != "yes" 
          %if RTMTaskCountersIsReqFcn()
            static uint32_T *taskCounterPtrs;
          %endif
          %if ERTPerTaskSampleHitsIsReqFcn()
            %assign rateTransitionSize = ...
              "(%<NumSampleTimes> * %<NumSampleTimes>)"
            static boolean_T *rateTransitionPtrs[%<rateTransitionSize>];
          %endif
        %endif
        
        %<SLibGetGlobalTimingBridge()>.nTasks = %<NumSampleTimes>;
        
        %if needClockTicks
          %foreach idx = NumSampleTimes
            %if ClockTickForTIDIsReqFcn(idx)
              clockTickPtrs[%<idx>] = &(%<RTMGet("ClockTick%<idx>")>);
            %else
              clockTickPtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
            %endif
            %if needLongClockTicks
              %if LongClockTickForTIDIsReqFcn(idx)
                clockTickHPtrs[%<idx>] = &(%<RTMGet("ClockTickH%<idx>")>);
              %else
                clockTickHPtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
              %endif
            %endif
          %endforeach
          %<SLibGetGlobalTimingBridge()>.clockTick = clockTickPtrs;
          %if needLongClockTicks
            %<SLibGetGlobalTimingBridge()>.clockTickH = clockTickHPtrs;
          %else
            %<SLibGetGlobalTimingBridge()>.clockTickH = %<SLibGetNullDefinitionFromTfl()>;
          %endif
        %else
          %<SLibGetGlobalTimingBridge()>.clockTick = %<SLibGetNullDefinitionFromTfl()>;
          %<SLibGetGlobalTimingBridge()>.clockTickH = %<SLibGetNullDefinitionFromTfl()>;
        %endif
        
        %if ::CompiledModel.SingleRate != "yes" 
          %if RTMTaskCountersIsReqFcn()
            %assign cTick = RTMGet("TaskCounters")
            taskCounterPtrs = ...
              &(%<cTick>.%<SLibERTMultiRateCounterField(0)>);
            %<SLibGetGlobalTimingBridge()>.taskCounter = taskCounterPtrs;
          %endif        
          %if ERTPerTaskSampleHitsIsReqFcn()
            %assign shMat = RTMGet("PerTaskSampleHits")
            %foreach i = NumSynchronousSampleTimes 
              %foreach j = NumSynchronousSampleTimes
                %if SLibGetNeedRateInteraction(i,j)
                  %if SuppressMultiTaskScheduler
                    %assign val = "%<RTMGet("PerTaskSampleHits")>."...
                      "b_%<SLibERTMultiRateTimingField(j,i)>"
                  %else
                    %assign val = "%<RTMGet("PerTaskSampleHits")>."...
                      "%<SLibERTMultiRateTimingField(j,i)>"
                  %endif
                  rateTransitionPtrs[%<i>*%<NumSampleTimes> + %<j>] \ 
                  = &(%<val>);
                %endif
              %endforeach
            %endforeach
            %<SLibGetGlobalTimingBridge()>.rateTransition = rateTransitionPtrs;
          %endif
        %endif
        
        %if RTMTimePtrIsReqFcn() || RTMTaskTimeIsReqFcnForTID(0)
          %foreach idx = NumSampleTimes 
            %if SampleTime[idx].NeedFloatTime == "yes"
              taskTimePtrs[%<idx>] = &(%<LibGetTaskTime(idx)>);
            %else
              taskTimePtrs[%<idx>] = %<SLibGetNullDefinitionFromTfl()>;
            %endif
          %endforeach
          %<SLibGetGlobalTimingBridge()>.taskTime = taskTimePtrs;
        %endif
        
        %if RTMFirstInitCondFlagIsReqFcn()
          %<SLibGetGlobalTimingBridge()>.firstInitCond = &%<RTMIs("FirstInitCond")>;
        %endif        
      }
    %endif %% !IsModelReferenceTarget() && SLibIsERTCodeFormat() && ...
    %endif %% !LibIsDeploymentDiagram() || needsTimingBridgeForDeploymentDiagram
    
    %% Add information to generate the top model's initialize to generate the
    %% data need to pass into the child model's initalize
    %if !IsModelReferenceTarget() && ISFIELD(::CompiledModel, "NumDataTransfers") && ::CompiledModel.NumDataTransfers > 0
      %assign rteBlkDWorkIndex = ::CompiledModel.RteBlockDWorkIndex
      %with System[NumSystems-1]
        const uint32_T *gblDataTransferIds = &%<LibBlockDWork(::CompiledModel.DWorks.DWork[rteBlkDWorkIndex],"", "", 0)>;
      %endwith
    %endif
  %endif %% !ISEMPTY(mdlRefBlks)
  
  %if LibIsDeploymentDiagram() 
    %assign buf = SLibDeploymentCallModelrefBlockRegFcns(mdlRefBlks)
    %if !WHITE_SPACE(buf)
      %<buf>
    %endif
  %endif

  %with ::CompiledModel.System[baseSysIdx]
    %assign mdlBlkIdx = 0
    %foreach rowIdx = SIZE(mdlRefBlks,0)
       %assign mdlRefInfo = mdlRefBlks[rowIdx]
       %assign mSysIdx = mdlRefInfo[0]
       %assign bIdx    = mdlRefInfo[1]
       %assign instIdx = mdlRefInfo[2]
       %assign thisSystem = ::CompiledModel.System[mSysIdx]
       %assign thisBlock = thisSystem.Block[bIdx]
       %with thisBlock
         %assert 0 == thisBlock.DeletedInIR
         %assign blockInterface = GetModelrefInterface(thisBlock)
         %assign doSSInitCacheClose = TLC_FALSE
         %if instIdx != -1
           %assign standaloneSysIdx = thisSystem.StandaloneParentSysIdx[instIdx]
           %if standaloneSysIdx != -1 
             %% cache registration fcn to parent standalone initialize fcn
             %openfile stdSSBuffer
             %assign doSSInitCacheClose = TLC_TRUE
           %endif
         %endif

         %assign tmpVec = [%<mdlRefInfo[3]>, %<mdlRefInfo[4]>]
         %assign bpath  = STRING(SLibMangledGrBlockPath(tmpVec))        
         %if EXISTS(slrt)
         %%SPECIAL CASE FOR SLRT
             %assign bpath  = STRING(SLibMangledGrBlockPath(tmpVec))
             %assign bpath = FEVAL("xpcgate","htmlencode",bpath)
         %endif

         %if MdlRefIsCPPClassGenMode
           %assign needsAuxilaryRegFcns = ...
             blockInterface.RTMAccessed || ...
             blockInterface.NeedsErrorStatus || ...
             blockInterface.StopReqAccessed || ...
             blockInterface.NeedsGlobalTimingEngine || ...
             (ISFIELD(blockInterface, "RegFcnNeedsCAPIArgs") && ...
             blockInterface.RegFcnNeedsCAPIArgs)
         %else
           %assign needsAuxilaryRegFcns = TLC_FALSE
         %endif
         %if ISFIELD(blockInterface, "RegistrationFcn")
           /* Model Initialize fcn for %<Type> Block: '%<Name>' */
           %% TopTester : test/toolbox/simulink/variants/inlineVariants/modelref/tmdlref_basic.m -testspec:g1300511
           %assign ifCond = SLibIfVariantCondition16b(thisBlock)
           %assign ifEndCond = SLibEndIfVariantCondition16b(thisBlock)
           %assign sysIdxForMdlBlk = thisBlock.BlockIdx[0]
           %assign blockSystem = ::CompiledModel.System[sysIdxForMdlBlk]
           %assign parentIfCond = SLibIfSystemVariantCondition16b(blockSystem)
           %assign parentIfEndCond = SLibEndIfSystemVariantCondition16b(blockSystem)
           %<parentIfCond>
           %<ifCond>
           %<SLibMdlRefIfNetPreprocessorCondition(mSysIdx, instIdx, bIdx)>
           %assign mdlBlk = ::CompiledModel.ModelBlock[rowIdx]
           %if ISFIELD(mdlBlk, "ForEachSSLoopBnds")
             %assign ::NeedForEachLoopInReg = TLC_TRUE
             %assign ::NumForEachLoopHierarchyLevel = SIZE(mdlBlk.ForEachSSLoopBnds,1)
             %% Calculate the total number of for-loop iterations
             %assign numForLoops = 1
             %foreach levelIdx = ::NumForEachLoopHierarchyLevel
               %assign numForLoops = numForLoops * mdlBlk.ForEachSSLoopBnds[levelIdx]
             %endforeach
             %assign ::NeedLoopUnrolling = ((FEVAL("slsvTestingHook", "ForEachCodeGenLoopUnrolling") > 0) && (numForLoops < RollThreshold))
             {
             %if (::NeedLoopUnrolling)
               %% Initialize counter vector for loop unrolling
               %assign ::Counter4LoopUnrolling = []
               %foreach levelIdx = ::NumForEachLoopHierarchyLevel
                 %assign ::Counter4LoopUnrolling = ::Counter4LoopUnrolling + 0
               %endforeach
               %% Generate the unrolled loop
               %foreach loopIdx = numForLoops
                 %assign ::ForEachLoopHierarchyLevel = 1
                 %<GetFunctionStr(thisBlock, "Registration", instIdx, "", mdlBlkIdx, bpath)>
                 %% Update counter vector by adding 1 to the first level (the inner most ForEach)
                 %foreach levelIdx = ::NumForEachLoopHierarchyLevel
                   %assign ::Counter4LoopUnrolling[levelIdx] = ::Counter4LoopUnrolling[levelIdx] + 1
                   %if (::Counter4LoopUnrolling[levelIdx] < mdlBlk.ForEachSSLoopBnds[levelIdx])
                     %break
                   %else
                     %assign ::Counter4LoopUnrolling[levelIdx] = 0
                   %endif
                 %endforeach
               %endforeach
             %else
               %assign ::ForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevel
               %foreach ssIdx = SIZE(mdlBlk.ForEachSSLoopBnds,1)
                 %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
                 %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevel - 1
                   int32_T %<iterVar>;
                   for (%<iterVar> = 0; %<iterVar> < %<mdlBlk.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel]>; %<iterVar>++) {
               %endforeach
               %assign ::ForEachLoopHierarchyLevel = 1
               %<GetFunctionStr(thisBlock, ...
                 "Registration", instIdx, "", mdlBlkIdx, bpath)>
               %foreach ssIdx = SIZE(mdlBlk.ForEachSSLoopBnds,1)
                 }
               %endforeach
             %endif
             }
             %assign ::NeedForEachLoopInReg = TLC_FALSE
           %else
             %<GetFunctionStr(thisBlock, ...
               "Registration", instIdx, "", mdlBlkIdx, bpath)>
           %endif
           %<SLibMdlRefEndIfNetPreprocessorCondition(mSysIdx, instIdx, bIdx)>
           %<ifEndCond>
           %<parentIfEndCond>
         %elseif needsAuxilaryRegFcns
           /* Model Initialize fcn for %<Type> Block: '%<Name>' */
           %assign ifCond = SLibIfVariantCondition16b(thisBlock)
           %assign ifEndCond = SLibEndIfVariantCondition16b(thisBlock)
           %assign sysIdxForMdlBlk = thisBlock.BlockIdx[0]
           %assign blockSystem = ::CompiledModel.System[sysIdxForMdlBlk]
           %assign parentIfCond = SLibIfSystemVariantCondition16b(blockSystem)
           %assign parentIfEndCond = SLibEndIfSystemVariantCondition16b(blockSystem)
           %<parentIfCond>
           %<ifCond>
           %<SLibMdlRefIfNetPreprocessorCondition(mSysIdx, instIdx, bIdx)>
           %<SLibGetModelBlockRegistrationFunction(thisBlock,bpath,blockInterface,instIdx,mdlBlkIdx)>
           %<SLibMdlRefEndIfNetPreprocessorCondition(mSysIdx, instIdx, bIdx)>
           %<ifEndCond>
           %<parentIfEndCond>
         %endif
         %if (::CompiledModel.RTWStatesLogging || (isRAccel&&(RTWCAPISignals==1))   ) && ...
           !IsModelReferenceTarget() && !thisBlock.ParamSettings.InsideForEachSS && ...
           !thisBlock.ParamSettings.ProtectedModelBlock
           %if GenRTModel
             %assign rtm_mmi = "&(%<RTMGet("DataMapInfo")>.mmi)"
           %else
             %assign rtm_mmi = "&(%<RSimRTWCAPIVarPtr>->mmi)"
           %endif
           %assign childMMI = "rtwCAPI_GetChildMMI(%<rtm_mmi>,%<mdlBlkIdx>)"
           { 
             /* MAT-file logging: Update full-paths stored in the MMI */
             %assign bpath_unmangled  = STRING(SLibGrBlockPath(tmpVec))
             char_T *tempStr = rtwCAPI_EncodePath("%<bpath_unmangled>");
             rtwCAPI_UpdateFullPaths((%<childMMI>), tempStr, 1);
             utFree(tempStr);
           } 
         %endif
         
         %if doSSInitCacheClose
           %closefile stdSSBuffer
           %<LibAddToSystemField(System[standaloneSysIdx],"CachedInitializeDataBody",...
             "\n" + stdSSBuffer+ "\n")>
         %endif

       %endwith
       
       %% ChildMMI's are only created for unprotected models
       %if !thisBlock.ParamSettings.ProtectedModelBlock
         %assign mdlBlkIdx = mdlBlkIdx + 1
       %endif
     %endforeach
     %% We need to dump again ground declarations for model reference. 
     %% This case happens when a scalar Ground signal is feeding a Reusable
     %% subsystem and the reusable subsystem contains a Model Reference
     %% Block
     %%            -------------------
     %%           |     ----------    |
     %%  Grnd sig |    |          |   |
     %%  -------->|--->|          |   |
     %%           |    |          |   |
     %%           |    |          |   |
     %%      ---->|--->|          |   |
     %%  Grnd Sig |    |          |   |
     %%           |     ----------    |
     %%           |     Model Block   |
     %%            -------------------
     %%             Reusable Subsystem
     
     %<SLibCacheCodeToFile("mdl_data_defn", LibDumpGroundDeclarations(0))>

   %endwith
   
   %if ((RTWCAPI == 1)  && IsModelReferenceTarget()) && !GenerateClassInterface
     %assign mmiStr = "%<RTMGetModelSS()>->DataMapInfo.mmi"
     /* Initialize Parent model MMI */
     if ((rt_ParentMMI != %<SLibGetNullDefinitionFromTfl()>) && (rt_ChildPath != %<SLibGetNullDefinitionFromTfl()>))
     {
       rtwCAPI_SetChildMMI(*rt_ParentMMI, rt_ChildMMIIdx, &(%<mmiStr>));
       rtwCAPI_SetPath(%<mmiStr>, rt_ChildPath);
       rtwCAPI_MMISetContStateStartIndex(%<mmiStr>, rt_CSTATEIdx);
     }
   %endif
   
   %if IsModelReferenceForASimstructBasedTarget()
     %if EXISTS(SolverResetInfo) && SolverResetInfo.NumNonContDerivSignals > 0
      %assign numNoncontDerivSigs = SIZE(SolverResetInfo.NonContDerivSignal,1)
      %assign arrayIdx = 0
      %foreach idx =  numNoncontDerivSigs
        %assign dU = SolverResetInfo.NonContDerivSignal[idx]
        %if ISFIELD(dU,"MdlRefInfo")
          %assign mdlRefInfo = dU.MdlRefInfo
          %assign mSysIdx = mdlRefInfo[0][0]
          %assign bIdx    = mdlRefInfo[0][1]
          %assign instIdx = mdlRefInfo[0][2]
          %assign port    = mdlRefInfo[0][3]
          %assign blk = System[mSysIdx].Block[bIdx]
          %assign name = blk.ParamSettings.ReferencedModelName
          %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, ...
            bIdx, instIdx)
          %foreach subIdx = dU.NumMdlRefNonContSigs
            %<RTMSetNonContDerivSignal(arrayIdx,...
              "mr_%<mangleName>nonContOutputArray[%<port>][%<subIdx>].sizeInBytes", ...
              "mr_%<mangleName>nonContOutputArray[%<port>][%<subIdx>].currVal")>;
            %assign arrayIdx = arrayIdx + 1
          %endforeach
        %else
          %if dU.ComplexSignal
            %assign dtype = LibGetDataTypeComplexNameFromId(dU.DataTypeIdx)
          %else
            %assign dtype = LibGetDataTypeNameFromId(dU.DataTypeIdx)
          %endif
          %% For NonContDerivSignal inside For Each subsystem, we need to
          %% index each For Each vargroup level by right index
          %if ISFIELD(dU, "ForEachSSIterIndices")
            %assign ::UseConstantForVarGroupIdx = TLC_TRUE
            %assign ::VarGroupIndexVector = dU.ForEachSSIterIndices
            %assign ::VarGroupIndexVectorSize = SIZE(::VarGroupIndexVector, 1)
            %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
          %endif
          %<RTMSetNonContDerivSignal(arrayIdx,...
            "%<dU.RegionLen>*sizeof(%<dtype>)", ...
            "%<GetNonContAddress(dU, System[baseSysIdx])>")>;
          %if ISFIELD(dU, "ForEachSSIterIndices")
            %assign ::UseConstantForVarGroupIdx = TLC_FALSE
            %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
          %endif
          %assign arrayIdx = arrayIdx + 1
        %endif
      %endforeach
    %endif
    %if EXISTS(SolverResetInfo) &&  ISFIELD(SolverResetInfo,"NonContOutputSignals")
      %foreach idx = ExternalOutputs.NumExternalOutputs
        %assign nonContOut = ...
          SolverResetInfo.NonContOutputSignals.NonContOutput[idx]
        %assign numNonContSigs = ISFIELD(nonContOut,"NonContOutputSignal") ? ...
          SIZE(nonContOut.NonContOutputSignal,1) : 0
        %assign arrayIdx = -1
        %foreach cIdx =  numNonContSigs
          %assign nonContElem = nonContOut.NonContOutputSignal[cIdx]
          %assign regLen = nonContElem.RegionLen
          %if nonContElem.ComplexSignal
            %assign dType = LibGetDataTypeComplexNameFromId(nonContElem.DataTypeIdx)
          %else
            %assign dType = LibGetDataTypeNameFromId(nonContElem.DataTypeIdx)
          %endif
          %% If this signal is coming from a submodel, then we 
          %% can't initialize it here.  We will initialize the
          %% information after we call the submodels registration function
          if (mr_nonContOutputArray[%<idx>] != %<SLibGetNullDefinitionFromTfl()>) {
            %if ISFIELD(nonContElem,"MdlRefInfo") 
              %assign mdlRefInfo = nonContElem.MdlRefInfo
              %assign mSysIdx = mdlRefInfo[0][0]
              %assign bIdx    = mdlRefInfo[0][1]
              %assign instIdx = mdlRefInfo[0][2]
              %assign port    = mdlRefInfo[0][3]
              %assign blk = System[mSysIdx].Block[bIdx]
              %assign name = blk.ParamSettings.ReferencedModelName
              %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, ...
                bIdx, instIdx)
              %foreach mIdx = nonContElem.NumMdlRefNonContSigs
                %assign arrayIdx = arrayIdx + 1
                mr_nonContOutputArray[%<idx>][%<arrayIdx>].sizeInBytes = ...
                  mr_%<mangleName>nonContOutputArray[%<port>][%<mIdx>].sizeInBytes;
                mr_nonContOutputArray[%<idx>][%<arrayIdx>].currVal = ...
                  mr_%<mangleName>nonContOutputArray[%<port>][%<mIdx>].currVal;
                %% If this is the last array, set the next pointer to NULL
                %if cIdx == numNonContSigs - 1 && ...
                  mIdx == nonContElem.NumMdlRefNonContSigs -1 
                  mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = %<SLibGetNullDefinitionFromTfl()>;
                %else
                  %assign nextIdx = arrayIdx + 1
                  mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = ...
                    &(mr_nonContOutputArray[%<idx>][%<nextIdx>]);
                %endif
              %endforeach
            %else
              %% For NonContDerivSignal inside For Each subsystem, we need to
              %% index each For Each vargroup level by right index
              %if ISFIELD(nonContElem, "ForEachSSIterIndices")
                %assign ::UseConstantForVarGroupIdx = TLC_TRUE
                %assign ::VarGroupIndexVector = nonContElem.ForEachSSIterIndices
                %assign ::VarGroupIndexVectorSize = SIZE(::VarGroupIndexVector, 1)
                %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
              %endif
              %assign address = GetNonContAddress(nonContElem, ...
                ::CompiledModel.System[GetBaseSystemIdx()])
              %if ISFIELD(nonContElem, "ForEachSSIterIndices")
                %assign ::UseConstantForVarGroupIdx = TLC_FALSE
                %assign ::VarGroupIndexVectorIdx = ::VarGroupIndexVectorSize - 1
              %endif
              %assign arrayIdx = arrayIdx + 1
              mr_nonContOutputArray[%<idx>][%<arrayIdx>].sizeInBytes = ...
                %<regLen>*sizeof(%<dType>);
              mr_nonContOutputArray[%<idx>][%<arrayIdx>].currVal = (char_T *)%<address>;
              %if cIdx ==  numNonContSigs - 1
                mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = %<SLibGetNullDefinitionFromTfl()>;
              %else
                %assign nextIdx = arrayIdx + 1
                mr_nonContOutputArray[%<idx>][%<arrayIdx>].next = ...
                  &(mr_nonContOutputArray[%<idx>][%<nextIdx>]);
              %endif
            %endif
          }
        %endforeach
      %endforeach
    %endif
  %endif
  %closefile modelrefBuffer
  %return modelrefBuffer
%endfunction %%CallModelrefBlockRegFcns

%% Function: FcnGetChildCoderGroupDWorkPath ======================================
%% Abstract:
%%    Get dwork path to use with child codergroup
%function FcnGetChildCoderGroupDWorkPath(modelBlock, blockInterface, instIdx) void
  %if !blockInterface.OkToMultiInstance
    %assign dworkPath = ""
  %elseif blockInterface.rtmAllocateInParent
    %if IsModelReferenceTarget() && ::CompiledModel.OkToMultiInstanceModelref
      %assign dworkPath = modelBlock.Identifier
    %else
      %assign dworkPath = SLibGetModelBlockStructDWorkArg( ...
        "", NumSystems-1, modelBlock, "RegistrationFcn", instIdx)
    %endif
  %else
    %assign dworkPath = SLibGetModelBlockStructDWorkArg( ...
      "", NumSystems-1, modelBlock, "RegistrationFcn", instIdx)
  %endif
  %return dworkPath
%endfunction

%% Function: FcnAddToCoderGroupIndexMap =====================================
%% Abstract:
%%    add an entry to the CoderDataGroupIndexMap for a model block
%function FcnAddToCoderGroupIndexMap(modelBlock, childGroup, childGroupIndex, mappedCoderDataGroupIndex) void
  %% If a group originating in this child model, the key is Group#.
  %% Otherwise, it is ChildGroup#
  %if childGroup.Depth == 0
    %assign mapKey = "Group" + childGroupIndex
  %else
    %assign mapKey = "ChildGroup" + childGroupIndex
  %endif
  %createrecord mapValue {}
  %addtorecord mapValue CoderDataGroupIndex mappedCoderDataGroupIndex
  %addtorecord modelBlock.CoderDataGroupIndexMap %<mapKey> %<mapValue>
  %undef mapValue
%endfunction

%% Function: FcnGetCoderGroupPointerPath =================================
%% Abstract:
%%    Compute the pointer path for a child coder group
%function FcnGetCoderGroupPointerPath(childGroup, blockInterface, dworkPath) void
  %if !blockInterface.OkToMultiInstance
    %assign pointerPath = childGroup.PointerPath
  %else
    %if blockInterface.rtmAllocateInParent
      %% self group has empty pointer path
      %if ISEMPTY(childGroup.PointerPath)
        %assign pointerPath = dworkPath
      %else
        %assign pointerPath = dworkPath + "." + childGroup.PointerPath
      %endif
    %else
      %if childGroup.Depth == 0
        %assign pointerPath = dworkPath + "." + childGroup.PointerPath
      %else
        %if ::isRAccel || ::isRSim
          %assign pointerPath = dworkPath + "." + childGroup.PointerPath
        %else
          %assign pointerPath = dworkPath + ".rtdw." + childGroup.PointerPath
        %endif
      %endif
    %endif
  %endif
  %return pointerPath
%endfunction

%% Function: FcnGetCoderGroupDynamicInitPath =============================
%% Abstract:
%%    Compute the dynamic init path for a child coder group
%function FcnGetCoderGroupDynamicInitPath(childGroup, modelBlock, blockInterface, dworkPath) void
  %if !blockInterface.OkToMultiInstance
    %assign dynamicInitPath = childGroup.PointerPath
  %else
    %if blockInterface.rtmAllocateInParent
      %assign dynamicInitPath = modelBlock.Identifier
    %else
      %if ::isRAccel || ::isRSim
        %assign dynamicInitPath = dworkPath
      %else
        %assign dynamicInitPath = "rtdw." + dworkPath
      %endif
    %endif
  %endif
  %return dynamicInitPath
%endfunction

%% Function FcnGetCoderGroupPath ===========================================
%% Abstract:
%%   Compute the GroupPath for a child coder group
%function FcnGetCoderGroupPath(childGroup, modelBlock, blockInterface) void
  %if childGroup.AsStructure == "InParent" && blockInterface.OkToMultiInstance
    %assign elemName = ""
    %assign varGroupIdx = SLibGetRootVarGroupIdxForCoderGroup(childGroup)
    %if varGroupIdx < 0
      %assign groupPath = modelBlock.Identifier + "_" + childGroup.GroupPath
    %else
      %assign numElement = SLibVarGroupNumElements(varGroupIdx)
      %foreach elemIdx = numElement
        %assign idnum  = ...
          IDNUM(SLibVarGroupElementSource(varGroupIdx, elemIdx))
        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]
        %if recType == "PCDG" && ...
          (modelBlock.ParamSettings.CompiledModelBlockIndex == recIdx)
          %assign elemName = ...
            SLibVarGroupElementName(varGroupIdx, elemIdx)
          %break
        %endif
      %endforeach
      %assign groupPath = elemName
      %if !ISEMPTY(childGroup.GroupPath)
        %assign groupPath = groupPath + "." + childGroup.GroupPath
      %endif
    %endif
  %else
    %if childGroup.IsSelf
      %assign groupPath = modelBlock.Identifier
    %else
      %assign groupPath = modelBlock.Identifier + "_" + childGroup.GroupPath
    %endif
    
  %endif
  %return groupPath
%endfunction

%% Function FcnGenerateGroupInstance ============================================
%% Abstract:
%%    Do we generate an instance for the group?
%function FcnGenerateGroupInstance(childGroup) void
  %assign generateGroupInstance = TLC_FALSE

  %if !childGroup.IsImportedFromFile
    %if childGroup.AsStructure == "InParent"
      %assign isSelfGroup = SLibGetSelfCoderDataGroupIndex() > -1 && ...
        childGroup.Name == ::CompiledModel.CoderDataGroup[SLibGetSelfCoderDataGroupIndex()].Name
      %if childGroup.ContainsInstanceSpecificParameter
        %assign generateGroupInstance = !IsModelReferenceTarget()
      %elseif !isSelfGroup
        %assign generateGroupInstance = childGroup.Depth == 0
      %endif
    %else
      %assign generateGroupInstance = TLC_TRUE
    %endif
  %endif
  %return generateGroupInstance
%endfunction

%% Function: FcnCopyInstPForSimTargets =========================================
%% Abstract:
%%   Copy instance-specific parameter values for sim targets
%function FcnCopyInstPForSimTargets(dynamicInitializer) void
  %assign fieldNames = FIELDNAMES(dynamicInitializer)
  %assign numElements = SIZE(fieldNames, 1)
  %foreach eIdx = numElements
    %assign fieldName = fieldNames[eIdx]
    %assign idNum = IDNUM(fieldName)
    %if idNum[0] == "P"
      %assign dst = dynamicInitializer.%<fieldName>
      %assign mdlParam = ::CompiledModel.ModelParameters.Parameter[idNum[1]]
      %assign src = LibModelParameterAddr(mdlParam, "", "", 0)
      %assign sizeof = "sizeof(" + dst + ")"
      %assign memcpy = "(void) " + ...
        LibGenMemFcnCall("memcpy", "&(" + dst + ")", src, sizeof) + ";\n"
      %if ::isRAccel || Accelerator
        %assign ::CompiledModel.ChildCoderDataGroupAssignment = ...
          ::CompiledModel.ChildCoderDataGroupAssignment + memcpy
      %else
        %assert ::isRSim
        %<LibMdlStartCustomCode(memcpy, "execution")>
      %endif
    %endif
  %endforeach
%endfunction

%% Function: FcnAssignCoderGroupsInNonAllocators ==================================
%% Abstract: 
%%   Assign self pointers for coder groups in middle models with AsStructure=InParent
%function FcnAssignCoderGroupsInNonAllocators(childGroup, modelBlock, blockInterface, groupPath, selfPath) void
  %if SLibMultiInstance()
    %assign groupPath = SLibGetCoderDataGroupStructPtr(SLibCoderDataGroupIndex(childGroup.Name)) + "->" + groupPath
  %elseif !::isRAccel && !Accelerator
    %assign groupPath = SLibCoderDataGroupInstance(childGroup) + "." + groupPath
  %endif
  %assign localStructAccess = ""
  %if IsModelReferenceTarget()
    %if !::CompiledModel.OkToMultiInstanceModelref
      %assign localStructAccess = ""
    %elseif blockInterface.rtmAllocateInParent
      %assign localStructAccess = ::tSimStruct + "->"
    %else
      %assign localStructAccess = SLibGetModelBlockVarGroupRoot(modelBlock)
    %endif
  %endif
  %assign comment = "/* Assign pointer for %<childGroup.Identification>, Block: '%<modelBlock.Name>' */\n"
  %assign ::CompiledModel.ChildCoderDataGroupAssignment = ...
    ::CompiledModel.ChildCoderDataGroupAssignment + comment + ...
    "%<localStructAccess>%<selfPath> = &%<groupPath>;\n"
%endfunction

%% Function: FcnDeclareChildCoderGroups ===============================================
%% Abstract:
%%   declare and define child coder groups
%function FcnDeclareChildCoderGroups(childGroup, blockInterface, groupPath, selfPath, initializer) void
  %if !WHITE_SPACE(initializer)
    %assign initializer = " = " + initializer
  %endif
  %if blockInterface.OkToMultiInstance
    %assign instance = groupPath
  %else
    %assign instance = selfPath
  %endif
  %if !ISEMPTY(childGroup.Type) && !ISEMPTY(instance)
    %assign comment = "/* Define buffer for %<childGroup.Identification>, Block: '%<Name>' */\n"
    %assign allocation = "%<childGroup.Type> %<instance>%<initializer>;\n"
    %assign ::CompiledModel.ChildCoderDataGroupAllocate = ...
      ::CompiledModel.ChildCoderDataGroupAllocate + comment + ...
      SLibApplyMemSecToDataDefnForGroup(allocation, childGroup, instance, ::CompiledModel.ConfigSet, TLC_TRUE)
    %assign comment = "/* Declare buffer for %<childGroup.Identification>, Block: '%<Name>' */\n"
    %assign declaration = "%<childGroup.Type> %<instance>;\n"
    %assign ::CompiledModel.ChildCoderDataGroupDeclare = ...
      ::CompiledModel.ChildCoderDataGroupDeclare + comment + ...
      SLibApplyMemSecToDataDeclForGroup(declaration, childGroup, instance, ::CompiledModel.ConfigSet, TLC_TRUE)
  %endif
%endfunction

%% Function: FcnAssignCoderGroupsInAllocators ==================================
%% Abstract: 
%%   Assign self pointers for coder groups in allocating models with AsStructure=InParent
%function FcnAssignCoderGroupsInAllocators(childGroup, modelBlock, groupPath, selfPath) void
  %assign comment = "/* Assign pointer for %<childGroup.Identification>, Block: '%<modelBlock.Name>' */\n"
  %if childGroup.AsStructure == "InSelf"
    %assign sizeof = "sizeof(" + childGroup.Type + ")"
    %assign memcpy = "(void) " + ...
      LibGenMemFcnCall("memcpy", "&(" + selfPath + ")", "&(" + groupPath + ")", sizeof) + ";\n"
    %assign ::CompiledModel.ChildCoderDataGroupMemcpy = ...
      ::CompiledModel.ChildCoderDataGroupMemcpy + comment + memcpy
    %% Self is directly embededed instead of via reference
  %elseif (childGroup.Depth == 0) && !childGroup.IsSelf
    %assign ::CompiledModel.ChildCoderDataGroupAssignment = ...
      ::CompiledModel.ChildCoderDataGroupAssignment + comment + ...
      "%<selfPath> = &%<groupPath>;\n"
  %endif
%endfunction

%function FcnGetCoderGroupSelfPointerInit(group)
  %% Promote to static if inparent or inself and self is static
  %if SLibAccessGroupThroughSelf(group)
    %if SLibHasSelfWithStaticInit()
      %return "Static"
    %else
      %return "Dynamic"
    %endif
  %else
    %return group.DataInit
  %endif
%endfunction

%% Do we need to dynamically assign this codergroup pointer in the self?
%function FcnAssignCoderGroup(childGroup) void
  %return !::isRAccel && !Accelerator && ...
    !GenerateClassInterface && ...
    !childGroup.SingleInstMdlRef && ...
    !childGroup.IsImportedFromFile && ...
    (childGroup.AsStructure != "None") && ...
    (childGroup.SelfPointerInit == "Dynamic") && ...
    !childGroup.IsSelf
   !SLibIsSynthesizedRTM(childGroup)
%endfunction
  
%% Function: FcnProcessChildCoderGroups  =========================================
%% Abstract:
%%    Process child coder groups
%function FcnProcessChildCoderGroups() void
  %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
    ::CompiledModel.ModelReferenceBlocks : []
  %if ISEMPTY(mdlRefBlks)
    %return
  %endif
  %assign baseSysIdx = GetBaseSystemIdx()

  %assign childCoderDataGroupIndex = 0
  %assign ::CompiledModel.ChildCoderDataGroupDeclare = ""
  %assign ::CompiledModel.ChildCoderDataGroupAllocate = ""
  %assign ::CompiledModel.ChildCoderDataGroupAssignment = ""
  %assign ::CompiledModel.ChildCoderDataGroupMemcpy = ""
  %assign ancestorAllocatesCoderDataGroups = ::CompiledModel.AncestorAllocatesCoderDataGroups
  %with System[baseSysIdx]
    %assign mdlBlkIdx = 0

    %% Loop over all the model blocks ...
    %foreach rowIdx = SIZE(mdlRefBlks,0)
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx = mdlRefInfo[0]
      %assign bIdx    = mdlRefInfo[1]
      %assign instIdx = mdlRefInfo[2]
      %with ::CompiledModel.System[mSysIdx].Block[bIdx]
        %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
        %assert 0 == blk.DeletedInIR
        %assign blockInterface = GetModelrefInterface(blk)

        %% If the model block propagates child code groups ...
        %if ISFIELD(blockInterface, "CoderDataGroups") && ...
          !ISEMPTY(blockInterface.CoderDataGroups)
          %assign childGroups = blockInterface.CoderDataGroups.CoderDataGroup
          %assign numChildGroups = SIZE(childGroups, 1)
          %assign dworkPath = FcnGetChildCoderGroupDWorkPath(blk, blockInterface, instIdx)

          %% Establish codergroup mapping from index in child model to index in this model
          %assign mappedCoderDataGroupIndex = childCoderDataGroupIndex
          %addtorecord blk CoderDataGroupIndexMap {}


          %% Loop over each child group
          %foreach gIdx = numChildGroups
            %assign childGroup = blockInterface.CoderDataGroups.CoderDataGroup[gIdx]
            %assign previousChildGroupIndex = STRING(CAST("Number", childGroup.CoderDataGroupIndex))
            %<FcnAddToCoderGroupIndexMap(blk, childGroup, previousChildGroupIndex, mappedCoderDataGroupIndex)>

            %% Keep track of whether an ancestor allocates coder groups for this model, 
            %% since that breaks incremental build.
            %if !SLibAllocatesCoderDataGroup(childGroup)
              %assign ::CompiledModel.AncestorAllocatesCoderDataGroups = TLC_TRUE
            %endif

            %% Assign paths since we'll need them in the second loop below where we 
            %% adjust initializers
            %assign selfPath = ...
              FcnGetCoderGroupPointerPath(childGroup, blockInterface, dworkPath)
            %assign dynamicInitPath = ...
              FcnGetCoderGroupDynamicInitPath(childGroup, blk, blockInterface, dworkPath)
            %assign childGroupPath = FcnGetCoderGroupPath(childGroup, blk, blockInterface)
            %assign selfPointerInit = FcnGetCoderGroupSelfPointerInit(childGroup)

            %% Create the child data group records
            %addtorecord ::CompiledModel.CoderDataGroups CoderDataGroup { \
            Name childGroup.Name \
            Description childGroup.Description \
            Identification childGroup.Identification \
            Type childGroup.Type \
            Depth childGroup.Depth+1 \
            PointerPath selfPath \
            GroupPath childGroupPath \
            DataInit childGroup.DataInit \
            SelfPointerInit selfPointerInit \
            SingleInstMdlRef childGroup.SingleInstMdlRef \
            IsInstanceSpecific childGroup.IsInstanceSpecific \
            IsSelf childGroup.IsSelf \
            IsSynthesized childGroup.IsSynthesized \
            IsOpaque childGroup.IsOpaque \
            MemorySection childGroup.MemorySection \
            IsImportedFromFile childGroup.IsImportedFromFile \
            AsStructure childGroup.AsStructure \
            CompiledModelBlockIndex blk.ParamSettings.CompiledModelBlockIndex \
            CoderDataGroupIndex mappedCoderDataGroupIndex \
            ContainsInstanceSpecificParameter childGroup.ContainsInstanceSpecificParameter \
            }

            %assign mappedCoderDataGroupIndex = mappedCoderDataGroupIndex + 1

          %endforeach

          %% Now set up all static and dynamic initializers, which can cross reference
          %% other groups - that's why we had to do this in two separate loops
          %assign mappedCoderDataGroupIndex = childCoderDataGroupIndex

          %% Loop over each group
          %foreach gIdx = numChildGroups

            %assign childGroup = blockInterface.CoderDataGroups.CoderDataGroup[gIdx]
            %assign childGroupPath = ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].GroupPath
            %assign selfPath = ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex].PointerPath
            %% If we're allocating the group, or if a top-model multi-instance build,
            %% create group allocation and definition buffers
            %if SLibAllocatesCoderDataGroup(childGroup) || ...
              (!IsModelReferenceTarget() && MultiInstanceERTCode)
              
              %% Adjust the initializers to the context of this parent model
              %assign adjustedInitializer = FcnAdjustInitializer(childGroup.Initializer, blk)
              %assign dynamicInitializer = FcnAdjustDynamicInitializer(childGroup.DynamicInitializer, blk, blockInterface, dynamicInitPath)
              %% Emit the initializer since we're allocating groups
              %assign initializer = FcnEmitInitializer(adjustedInitializer, blk)
              
              %% Declare child groups that are in-self, or single instance
              %if childGroup.AsStructure != "InParent" || childGroup.SingleInstMdlRef
                %% We only allocate and declare data in some cases
                %if FcnGenerateGroupInstance(childGroup)
                  %<FcnDeclareChildCoderGroups(childGroup, blockInterface, childGroupPath, selfPath, initializer)>
                %endif
              %% Otherwise, put finishing touches on childGroupPath
              %else
                %assign parentGroupIndex = SLibCoderDataGroupIndex(childGroup.Name)
                %% Parent group may not be present if child creates _self but
                %% parent does not.  In that case, leave childGroupPath alone.
                %if parentGroupIndex >= 0
                  %assign parentGroup = ::CompiledModel.CoderDataGroup[parentGroupIndex]
                  %if SLibCoderGroupPackageAsStruct(parentGroup)
                    %if MultiInstanceERTCode
                      %assign childGroupPath = ...
                        SLibGetCoderDataGroupPointerFromRTM(parentGroup, 0) + "->" + childGroupPath
                    %elseif !::isRAccel && !Accelerator
                      %assign childGroupPath = SLibCoderDataGroupInstance(childGroup) + "."  + childGroupPath
                    %endif
                  %endif
                %endif
              %endif

              %% Create coder group assignment buffers
              %if FcnAssignCoderGroup(childGroup)
                %<FcnAssignCoderGroupsInAllocators(childGroup, blk, childGroupPath, selfPath)>
              %endif

              %% Copy instance-specific parameter values for sim targets
              %if ::isRAccel || Accelerator || ::isRSim
                %<FcnCopyInstPForSimTargets(dynamicInitializer)>
              %endif

            %% if we don't allocate or declare the childGroup, we still need to 
            %% adjust the initializer to the context of this parent model 
            %% as well as initialize pointers for submodel's InParent groups
            %else
              %assign initializer = FcnAdjustInitializer(childGroup.Initializer, blk)
              %assign dynamicInitializer = FcnAdjustDynamicInitializer(childGroup.DynamicInitializer, blk, blockInterface, dynamicInitPath)
              %% Create coder group assignment buffers
              %if FcnAssignCoderGroup(childGroup) && ...
                childGroup.AsStructure == "InParent" && (childGroup.Depth == 0)
                %<FcnAssignCoderGroupsInNonAllocators(childGroup, blk, blockInterface, childGroupPath, selfPath)>
              %endif
            %endif
            
            %% Add the static and dynamic initializers to the child coder group record.
            %addtorecord ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex] Initializer initializer
            %addtorecord ::CompiledModel.CoderDataGroups.CoderDataGroup[mappedCoderDataGroupIndex] DynamicInitializer dynamicInitializer
               
            %assign mappedCoderDataGroupIndex = mappedCoderDataGroupIndex + 1
          %endforeach
          %assign childCoderDataGroupIndex = childCoderDataGroupIndex + numChildGroups
            
        %endif
      %endwith
    %endforeach
  %endwith

  %% Cache the allocation and declaration buffers 
  %if !ISEMPTY(::CompiledModel.ChildCoderDataGroupDeclare)
    %<SLibCacheCodeToFile("mdl_priv_data_define", ::CompiledModel.ChildCoderDataGroupDeclare)>
  %endif
  %if !ISEMPTY(::CompiledModel.ChildCoderDataGroupAllocate)
    %<SLibCacheCodeToFile("mdldata_data_defn", ::CompiledModel.ChildCoderDataGroupAllocate)>
  %endif
  
%endfunction %%CallModelrefBlockRegFcns

%% Function: GetNonContAddress ================================================
%% Abstract:
%%  Returns the address of the signal which is used to track a noncontinuous
%% signal feeding an integrator.
%function GetNonContAddress(du, ss)
  %assign sigSrc  = du.SigSrc
  %assign startEl = du.StartEl
  %assign regLen  = du.RegionLen
  %assign idNum = IDNUM(sigSrc)
  %%
  %switch idNum[0]
      %% Note: no need for "u" because the top model will
      %% check for the reset in this case.  
    %case "y"
      %assign opIdx        = idNum[1]
      %assign interface    = ss.Interface
      %assign canOutputArg = interface.CanonicalOutputArgDef[opIdx]
      %assign name  = LibGetRecordIdentifier(canOutputArg)
      %assign addr  = "&%<name>[%<startEl>]"
      %<SLibAccessArgHelper(canOutputArg,"",ss.CurrentTID)>
      %break
    %default
      %assign bo = BlockOutputs.GlobalBlockOutput[idNum[1]]
      %assert (bo.Invariant == "no")
      %assert (LibGetRecordWidth(bo) >= regLen + startEl)
      %assign cross = System[bo.SigSrc[0]].CrossNoArgFcnBound
      %assign name  = SLibCG_GetVarGroupElementPath(bo.VarGroupIdx, ...
        ss.SystemIdx, cross)
      %assign opW   = (LibGetRecordWidth(bo) == 1) ? "" : "[%<startEl>]"
      %assign addr  = "&%<name>%<opW>"
      %break
  %endswitch
  %return addr
%endfunction


%% Function: CallModelrefBlockFreeFullPaths  ===================================
%% Abstract:
%%    Call rtwCAPI_SetFreeFullPaths
%function CallModelrefBlockFreeFullPaths(mdlRefBlks)
  %openfile modelrefBuffer
  %if ::CompiledModel.RTWStatesLogging && !IsModelReferenceTarget() && ...
    HasModelReferenceBlocks()
    %assign baseSysIdx = GetBaseSystemIdx()
    %with System[baseSysIdx]
      %if ::NumModelBlocksWithCAPI > 0
        %assign mdlBlkIdx = 0
        %foreach rowIdx = SIZE(mdlRefBlks,0)
          %% This does a deep dive so we only want to do it
          %% for the top (note: the engine takes care of this in sim)
          %assign mdlRefInfo = mdlRefBlks[rowIdx]
          %assign mSysIdx = mdlRefInfo[0]
          %assign bIdx    = mdlRefInfo[1]
          %assign instIdx = mdlRefInfo[2]
          %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
          %assert 0 == blk.DeletedInIR
          %if !blk.ParamSettings.SupportsCAPI
            %continue
          %endif
          
          %if GenRTModel
            %assign rtm_mmi = "&(%<RTMGet("DataMapInfo")>.mmi)"
          %else
            %assign rtm_mmi = "&(%<RSimRTWCAPIVarPtr>->mmi)"
          %endif
          %assign childMMI = "rtwCAPI_GetChildMMI(%<rtm_mmi>,%<mdlBlkIdx>)"
          rtwCAPI_FreeFullPaths((%<childMMI>));
          %assign mdlBlkIdx = mdlBlkIdx + 1
        %endforeach
      %endif
    %endwith
  %endif
  %closefile modelrefBuffer
  %return modelrefBuffer
%endfunction %%CallModelrefBlockFreePath


%% =============================================================================
%%
%function ModelrefCacheVarStepSolverResetCode(ss) void
  %openfile tmpbuf
  %if SolverType == "VariableStep"
    %assign nDU = SolverResetInfo.NumNonContDerivSignals
    %if nDU > 0
      if (%<RTMIs("MajorTimeStep")>) {
	%foreach idx = nDU
	  %assign dulocal = RTMGetIdxed("NonContDerivSignal", %<idx>)
	  if (%<LibGenMemFcnCall("memcmp", "%<dulocal>.pCurrVal", ...
	    "%<dulocal>.pPrevVal", "%<dulocal>.sizeInBytes")> != 0) {
	    (void) %<LibGenMemFcnCall("memcpy", "%<dulocal>.pPrevVal", ...
	      "%<dulocal>.pCurrVal", "%<dulocal>.sizeInBytes")>;
	    %<RTMSetSolverNeedsReset()>;
	  }
	%endforeach
      }
    %endif
  %endif %% SolverType == "VariableStep"
  %closefile tmpbuf
  %return tmpbuf
%endfunction


%% The following functions have similar formats for exported identifiers.
%% SLibWriteMdlRefExportedMdlInfo is used in model reference sim target and
%% CacheMdlRefExportedMdlInfoInBinfo is used in ModelReferenceRTWTarget.
%% If you change the exported signal format in one function, you should modify another one.
%function CacheMdlRefExportedMdlInfoInBinfo() void
  %with ::CompiledModel
    %createrecord mdlInfoRecords {}
    
    %foreach idIdx = ExportedMdlInfo.NumExportedMdlInfo
      %assign id = ExportedMdlInfo.ExportedMdlInfo[idIdx]
      %assign path = ""
      %if !ISEMPTY(id.BPath) && !WHITE_SPACE(id.BPath)
        %assign path =  id.BPath
      %endif
      
      %addtorecord mdlInfoRecords mdlInfo  { \
        Id     id.Id;    \
        Class  id.Class; \ 
        Alias  id.Alias; \
        Port   id.Port;  \
        Path   path      \
      }
    %endforeach
    %<CacheModelrefInterfaceInMatInfoFile(::CompiledModel.Name, ...
      "addMdlInfos", mdlInfoRecords)>
  %endwith
%endfunction

%% The following functions have similar formats for exported identifiers.
%% SLibWriteMdlRefExportedMdlInfo is used in model reference sim target and
%% CacheMdlRefExportedMdlInfoInBinfo is used in ModelReferenceRTWTarget.
%% If you change the exported signal format in one function, you should modify another one.
%function SLibWriteMdlRefExportedMdlInfo() void
  %with ::CompiledModel
    %openfile tmpBuffer
    static RegMdlInfo rtMdlInfo_%<Name>[%<ExportedMdlInfo.NumExportedMdlInfo>] = {
    %foreach idIdx = ExportedMdlInfo.NumExportedMdlInfo
      %assign id = ExportedMdlInfo.ExportedMdlInfo[idIdx]
      %if ISEMPTY(id.BPath) || WHITE_SPACE(id.BPath)
	{"%<id.Id>", %<id.Class>, %<id.Alias>, %<id.Port>, %<SLibGetNullDefinitionFromTfl()>}\
      %else
	{"%<id.Id>", %<id.Class>, %<id.Alias>, %<id.Port>, (void *) "%<STRING(id.BPath)>"}\
      %endif
      %if idIdx < (ExportedMdlInfo.NumExportedMdlInfo-1)
	,
      %endif
    %endforeach
    };
    %assign numSharedDSM = ::CompiledModel.NumDataStoresPushedToTopModel
    %if numSharedDSM > 0
      
      void *%<::CompiledModel.Name>_DSM[%<numSharedDSM>];
      int  %<::CompiledModel.Name>_DSMIdx[%<numSharedDSM>];
    %endif
    %closefile tmpBuffer
    %<SLibCacheCodeToFile("mdl_data_defn", tmpBuffer)>
    
    %openfile tmpBuffer
    %if numSharedDSM > 0
      extern void *%<::CompiledModel.Name>_DSM[%<numSharedDSM>];
      extern int  %<::CompiledModel.Name>_DSMIdx[%<numSharedDSM>];
    %endif
    %closefile tmpBuffer
    %<SLibCacheCodeToFile("mdl_fcn_decl", tmpBuffer)>

    %<SLibWriteMdlRefMdlInfoRegFcn()>
    %if ModelRefAccelModeSimState
      %% These might be better off in the SIM target boilerplate?
      %<SLibWriteMdlRefCacheDataAsMxArrayFcn()>
      %<SLibWriteMdlRefRestoreDataFromMxArrayFcn()>
      %<SLibWriteMdlRefCacheBitFieldToMxArrayFcn()>
      %<SLibWriteMdlRefExtractBitFieldFromMxArrayFcn()>

      %<SLibWriteMdlRefCacheDataToMxArrayWithOffsetFcn()>
      %<SLibWriteMdlRefRestoreDataFromMxArrayWithOffsetFcn()>
      %<SLibWriteMdlRefCacheBitFieldToCellArrayWithOffsetFcn()>
      %<SLibWriteMdlRefExtractBitFieldFromCellArrayWithOffsetFcn()>

      %<SLibWriteMdlRefGetSetDWorkFcns()>
      %<SLibWriteRegisterSimStateChecksumFcn()>
      %<SLibWriteGetSimStateDisallowedBlocksFcn()>
    %endif
  %endwith
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefMdlInfoRegFcn
%% Abstract: Writes model_MdlInfoRegFcn in model.c.
%%           Extracted from SLibWriteMdlRefExportedMdlInfo.
%%
%function SLibWriteMdlRefMdlInfoRegFcn() void
    %assign regFcnName = SLibCreateMdlInfoRegFcnName()
    %createrecord ReferencedModelHash {}
    %openfile mdlInfoRegFcnBuffer
    void %<regFcnName>(SimStruct* mdlRefSfcnS, char_T *modelName, int_T *retVal)
    {
      *retVal = 0;
      %if ISFIELD(::CompiledModel, "NumModelReferenceBlocks")
        {
          boolean_T regSubmodelsMdlinfo = %<GET_TYPE_ID_REPLACEMENT("false")>;
          ssGetRegSubmodelsMdlinfo(mdlRefSfcnS, &regSubmodelsMdlinfo);
          if (regSubmodelsMdlinfo) {
            %foreach idIdx = NumModelReferenceBlocks
              %assign blkIdx    = ModelReferenceBlocks[idIdx]
              %assign mdlBlock  = System[blkIdx[0]].Block[blkIdx[1]]
              %assign modelName = mdlBlock.ParamSettings.ReferencedModelName
              %if !ISFIELD(ReferencedModelHash, modelName)
                mr_%<modelName>_MdlInfoRegFcn(mdlRefSfcnS, "%<modelName>", retVal);
                if (*retVal == 0) return;
                *retVal = 0;
                %addtorecord ReferencedModelHash %<modelName> 1
              %endif
            %endforeach
          }
        }
      %endif
      
     %<RegisterMdlRefSFcnToWksDataTypes()>

      %assign modelName = Name
      *retVal = 0;
      ssRegModelRefMdlInfo(...
        mdlRefSfcnS, modelName, rtMdlInfo_%<modelName>, ...
        %<ExportedMdlInfo.NumExportedMdlInfo>);
      
      *retVal = 1;
    }
    
    %closefile mdlInfoRegFcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_defn", mdlInfoRegFcnBuffer)>
    
    %openfile mdlInfoRegFcnBuffer
    %<LibExternInFcnDecls()>void %<regFcnName>(SimStruct* mdlRefSfcnS, char_T *modelName, int_T *retVal);
    %closefile mdlInfoRegFcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_prototype", mdlInfoRegFcnBuffer)>            
%endfunction

%% =========================================================================== |
%% BEGIN ModelRefAccelModeSimState support
%% =========================================================================== |

%% =========================================================================== |
%% Function: SLibWriteGetSimStateDisallowedBlocksFcn
%% Abstract: Recursively packages the information about blocks that prevent
%%           the SimState from being safely stored, and returns it in an
%%           mxArray.
%%
%function SLibWriteGetSimStateDisallowedBlocksFcn() void
  %assign currentSystem = System[GetBaseSystemIdx()]
  %with currentSystem.Interface
    %assign fcnSig = SLibCreateGetSimStateDisallowedBlocksFcnSigForModel(Name)

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Code generation for header prototype.
    %%
    %openfile fcnBuffer
    %<LibExternInFcnDecls()>%<fcnSig>;
    %closefile fcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_prototype", fcnBuffer)>

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Code generation for function implementation.
    %%
    %openfile fcnBuffer

    %selectfile fcnBuffer
    %<fcnSig>
    {
    %with SimStateDisallowedBlocks

      %assign modelNames  = LibGetReferencedModelNames()
      %assign numChildren = modelNames.NumReferencedModels

      %if (0 == NumSimStateDisallowedBlocks) && (0 == numChildren)
        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% This model is a leaf node with no disallowed block data.
        %%
        return NULL;

      %elseif (0 == NumSimStateDisallowedBlocks) && (1 == numChildren)
        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% This is an internal node with no disallowed block data of its own.
        %% Just return the singleton child's result to the caller.
        %%
        return %<SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(...
          modelNames.ReferencedModel[0].Name)>();

      %elseif (0 == NumSimStateDisallowedBlocks)
        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% This is a multi-child internal node with no disallowed block data of 
        %% its own. We must fetch data from each unique child in turn.
        %% If only one child returns non-NULL, simply return its data.
        %% Otherwise, concatenate the results into a new cell matrix, destroy 
        %% the individual arrays, and return the consolidated data instead.
        %%        
        mxArray * data = NULL;
        size_t numChildrenWithDisallowedBlocks = 0;
        size_t numBlocks = 0;

        %<SLibWriteFetchChildSimStateDisallowedBlockData(modelNames, fcnBuffer)>

        if (numChildrenWithDisallowedBlocks > 1) {
          mwIndex subs[2], offset;

          data = mxCreateCellMatrix(numBlocks, 3);

          subs[0] = 0;

          %<SLibWriteCacheChildSimStateDisallowedBlockData(...
            modelNames, fcnBuffer)>
        }

        return data;

      %elseif (0 == numChildren)
        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% This is a leaf node with disallowed block data. Pack the data into
        %% a new cell matrix and return it.
        %%
        mxArray * data = mxCreateCellMatrix(%<NumSimStateDisallowedBlocks>, 3);
        mwIndex subs[2], offset;

        %<SLibWriteCacheLocalSimStateDisallowedBlockData(numChildren, fcnBuffer)>

        return data;

      %else
        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% This is the general case of an internal node with disallowed block
        %% data of its own. Generate an array of mxArrays along with a running
        %% total of  non-null results and a total block count, then concatenate
        %% the contents 
        %%
        mxArray * data = NULL;
        mwIndex subs[2], offset;
        size_t numChildrenWithDisallowedBlocks = 0;
        size_t numBlocks = 0;

          %<SLibWriteFetchChildSimStateDisallowedBlockData(...
            modelNames, fcnBuffer)>

          %assign allocM = "numBlocks + %<NumSimStateDisallowedBlocks>"

          data = mxCreateCellMatrix(%<allocM>, 3);

          %<SLibWriteCacheLocalSimStateDisallowedBlockData(...
            numChildren, fcnBuffer)>

          %<SLibWriteCacheChildSimStateDisallowedBlockData(...
            modelNames, fcnBuffer)>

        return data;

      %endif

    %endwith

    }

    %closefile fcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>

  %endwith

%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheChildSimStateDisallowedBlockData
%% Abstract: Emit code to cache the disallowed block lists returned by
%%           recursive calls into child models.
%%
%function SLibWriteCacheChildSimStateDisallowedBlockData(...
  modelNames, fcnBuffer) void

  %selectfile fcnBuffer

  {
    size_t i;
    for (i = 0; i < %<modelNames.NumReferencedModels>; ++i) {
      mxArray * data_i = disallowedBlocksInChild[i];

      if (NULL != data_i) {
        mwIndex subs_i[2], offset_i;
        const mwIndex numRows_i = (mwIndex) mxGetM(data_i);

        for (subs_i[0] = 0; subs_i[0] < numRows_i; ++(subs_i[0])) {
          mwIndex j;
          for (j = 0; j < 3; ++j) {
            mxArray* data_ij;

            subs_i[1] = j;

            offset_i = mxCalcSingleSubscript(data_i, 2, subs_i);
            
            data_ij = mxGetCell(data_i, offset_i);
            data_ij = mxDuplicateArray(data_ij);

            subs[1] = j;
            offset  = mxCalcSingleSubscript(data,   2, subs  );

            mxSetCell(data, offset, data_ij);        
          }

          ++(subs[0]);
        }

        mxDestroyArray(data_i);
      }
    }
  }
  
%endfunction

%% =========================================================================== |
%% Function: SLibWriteFetchChildSimStateDisallowedBlockData
%% Abstract: Emit code to ask each child model for an mxArray of disallowed 
%%           blocks, then perform some bookkeeping to ensure that all of the
%%           block data gets passed up correctly.
%%
%function SLibWriteFetchChildSimStateDisallowedBlockData(...
  modelNames, fcnBuffer) void

  %selectfile fcnBuffer

  %with modelNames

    mxArray * disallowedBlocksInChild[%<NumReferencedModels>];

    %foreach idx = NumReferencedModels

      disallowedBlocksInChild[%<idx>] = 
        %<SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(...
          ReferencedModel[idx].Name)>();

    %endforeach
    {
      size_t i;
      for (i = 0; i < %<NumReferencedModels>; ++i) {
        mxArray * data_i = disallowedBlocksInChild[i];    
        if (NULL != data_i) {
          if (0 == numChildrenWithDisallowedBlocks++) {
            data = data_i;
          }
          numBlocks += mxGetM(data_i);
        }
      }
    }
  %endwith

%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheLocalSimStateDisallowedBlockData
%% Abstract: Emit code to cache the disallowed block data contained in the
%%           model.rtw file being processed.
%%
%function SLibWriteCacheLocalSimStateDisallowedBlockData(...
  numChildren, fcnBuffer) void

  %selectfile fcnBuffer

  %with SimStateDisallowedBlocks

  {
    static const char * blockType[%<NumSimStateDisallowedBlocks>] = {
      %foreach idx = NumSimStateDisallowedBlocks
        "%<SimStateDisallowedBlock[idx].BlockType>",
      %endforeach
    };

    static const char * blockPath[%<NumSimStateDisallowedBlocks>] = {
      %foreach idx = NumSimStateDisallowedBlocks
        "%<SimStateDisallowedBlock[idx].BlockPath>",
      %endforeach
    };

    static const int reason[%<NumSimStateDisallowedBlocks>] = {
      %foreach idx = NumSimStateDisallowedBlocks
        %<SimStateDisallowedBlock[idx].Reason>,
      %endforeach
    };

    %% There is a bit of a hack-fu that uses the side effect of incrementing
    %% subs[0] to the correct value prior to the start of appending child data.
    for (subs[0] = 0; subs[0] < %<NumSimStateDisallowedBlocks>; ++(subs[0])) {
      subs[1] = 0;
      offset  = mxCalcSingleSubscript(data, 2, subs);

      mxSetCell(data, offset, mxCreateString(blockType[subs[0]]));

      subs[1] = 1;
      offset  = mxCalcSingleSubscript(data, 2, subs);

      mxSetCell(data, offset, mxCreateString(blockPath[subs[0]]));

      subs[1] = 2;
      offset  = mxCalcSingleSubscript(data, 2, subs);

      mxSetCell(data, offset, mxCreateDoubleScalar((double)reason[subs[0]]));
    }
  }

  %endwith

%endfunction

%% =========================================================================== |
%% Function SLibLogStatesAfterStateWrite
%% Abstract: call into simulink to log states after stateWriter block's output
%%
%function SLibLogStatesAfterStateWrite(stateWriteBlockPath) void
  %return "slmrLogStatesAfterStateWrite(%<RTMGet("MdlRefSfcnS")>, \"%<stateWriteBlockPath>\")"
%endfunction

%% =========================================================================== |
%% Function SLibIsRapidAccelSimulating
%% Abstract: return if it is Rapid Accelerator simulation
%%
%function SLibIsRapidAccelSimulating() void
  %return "slIsRapidAcceleratorSimulating()"
%endfunction


%% =========================================================================== |
%% Function: SLibWriteRegisterSimStateChecksumFcn
%% Abstract: Construct the model_RegisterSimStateChecksum function.
%%
%function SLibWriteRegisterSimStateChecksumFcn() void
  %assign currentSystem = System[GetBaseSystemIdx()]
  %with currentSystem.Interface
    %assign fcnSig = SLibCreateRegisterSimStateChecksumFcnSigForModel(Name)

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Code generation for function definition.
    %%
    %openfile fcnBuffer
    %<fcnSig>
    {
      %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
      %% Initialize with value computed during the build procedure
      %%
      const uint32_T chksum[4] = {
      %foreach idx = 4
        %<SimStateChecksum[idx]>,
      %endforeach
      };

      slmrModelRefRegisterSimStateChecksum(S, "%<Name>", &chksum[0]);

      %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
      %% Ask all child models to register their checksums.
      %%
      %assign modelNames = LibGetReferencedModelNames() %% from mdlrefutil.tlc

      %with modelNames
        %foreach idx = NumReferencedModels
            %<SLibCreateRegisterSimStateChecksumFcnNameForModel ...
              (ReferencedModel[idx].Name)>(S);
        %endforeach
      %endwith
    }
    %closefile fcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>

    %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
    %% Code generation for header prototype.
    %%
    %openfile fcnBuffer
    %<LibExternInFcnDecls()>%<fcnSig>;
    %closefile fcnBuffer
    %<SLibCacheCodeToFile("mdl_fcn_prototype", fcnBuffer)>
  %endwith
%endfunction

%% =========================================================================== |
%% Function: SLibCreateRegisterSimStateChecksumFcnSigForModel
%% Abstract: Construct the model_RegisterSimStateChecksum function signature.
%%
%function SLibCreateRegisterSimStateChecksumFcnSigForModel(thisModelName)
  %assign regFcnName = SLibCreateRegisterSimStateChecksumFcnNameForModel(Name)
  %return "void %<regFcnName>(SimStruct* S)"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateRegisterSimStateChecksumFcnNameForModel
%% Abstract: Creates the model_RegisterSimStateChecksum function name.
%%
%function SLibCreateRegisterSimStateChecksumFcnNameForModel(thisModelName)
  %return "mr_%<thisModelName>_RegisterSimStateChecksum"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefGetSetDWorkFcns
%% Abstract: Write a getter and setter for a model's DWork items.
%%
%function SLibWriteMdlRefGetSetDWorkFcns() void
  %assign currentSystem = System[GetBaseSystemIdx()]
  %with currentSystem.Interface
    %assign getterFcnSig = SLibCreateGetDWorkFcnSigForModel(Name)
    %assign setterFcnSig = SLibCreateSetDWorkFcnSigForModel(Name)

    %assign isSingleInstance = !::CompiledModel.OkToMultiInstanceModelref
    %assign dwMembers ...
      = SLibGetDWorkMemberNamesForSystem(currentSystem, isSingleInstance)

    %with dwMembers %% rtbName->"mdlrefDW->rtb", hasRTB etc

      %assign needsToCacheDWorkState ...
        =  hasRTB ...
        || hasRTDW ...
        || hasRTZCE ...
        || HasModelReferenceBlocks()

      %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
      %% Code generation for function bodies begins here.
      %%
      %openfile getDWorkBuffer
      %<getterFcnSig> {

      %openfile setDWorkBuffer
      %<setterFcnSig> {

      %assign ssMxName = "ssDW"

      %if needsToCacheDWorkState
    
        %<SLibWriteGetDWorkPreamble(...
          rtbMxName, rtdwMxName, rtzceMxName, ssMxName, getDWorkBuffer)>

        %if hasRTB
          %<SLibWriteCacheRestoreVariableToFromMxArray(...
            rtbName, ssMxName, 0, getDWorkBuffer, setDWorkBuffer)>
        %endif

        %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
        %% Traverse the RTDW tree and list of referenced models, make lists
        %% of variables to stash, emit code to stash them if necessary.
        %%

        %assign rtdwTree = SLibCreateEmptyRTDWTreeObject(rtdwName)

        %if hasRTDW
          %% This picks up state for this model, s-functions in models 
          %% referenced from this model, and MdlrefDW structs for multi-instance
          %% models referenced from this model.
          %%
          %assign varGroupIdx = FcnSysVarGroupIndex(currentSystem, "DWork", 0)
          %<SLibGetDWorkStateItemsForVarGroup(rtdwTree, varGroupIdx)>
        %endif

        %if HasModelReferenceBlocks() && isSingleInstance
          %% Iterate over the list, picking out the single-instance models
          %% and noting their name. These need to be stashed even if no
          %% RTDW struct exists.
          %%
          %<SLibGetDWorkPairsForSingleInstanceModelBlocks(rtdwTree)>
        %endif

        %if SLibRTDWTreeContainsPersistentState(rtdwTree)
          %% If this model or its children own persistent state, emit code
          %% to cache it.
          %%
          %<SLibWriteGetSetRTDWContents(...
            rtdwTree, ssMxName, 1, getDWorkBuffer, setDWorkBuffer)>          
        %endif

        %if hasRTZCE
          %<SLibWriteCacheRestoreVariableToFromMxArray(...
            rtzceName, ssMxName, 2, getDWorkBuffer, setDWorkBuffer)>
        %endif

        %selectfile getDWorkBuffer
          return %<ssMxName>;
      %else %% doesn't need to cache DWork state
        %selectfile getDWorkBuffer
        %if !isSingleInstance
          (void) %<SLibGetMdlrefDWPtrName()>;
        %endif
        return NULL;

        %selectfile setDWorkBuffer
        (void) %<ssMxName>;
        %if !isSingleInstance
          (void) %<SLibGetMdlrefDWPtrName()>;
        %endif
      %endif

      %selectfile getDWorkBuffer
      }
      %selectfile setDWorkBuffer
      }

      %closefile getDWorkBuffer
      %closefile setDWorkBuffer

      %<SLibCacheCodeToFile("mdl_fcn_defn", getDWorkBuffer)>
      %<SLibCacheCodeToFile("mdl_fcn_defn", setDWorkBuffer)>

      %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
      %% Code generation for header declarations.
      %%
      %openfile getDWorkBuffer
      %<LibExternInFcnDecls()>%<getterFcnSig>;
      %closefile getDWorkBuffer

      %openfile setDWorkBuffer
      %<LibExternInFcnDecls()>%<setterFcnSig>;
      %closefile setDWorkBuffer

      %<SLibCacheCodeToFile("mdl_fcn_prototype", getDWorkBuffer)>
      %<SLibCacheCodeToFile("mdl_fcn_prototype", setDWorkBuffer)>
    %endwith %% dwMembers
  %endwith  %% currentSystem.Interface
%endfunction

%% =========================================================================== |
%% Function: SLibCreateEmptyRTDWTreeObject
%% Abstract: Create an initialized empty instance of the record used to cache
%%           the results of traversing the RTDW tree.
%%
%% Members of the returned struct:
%%
%%    prefixName          : Name of this node in path to DWORK items.
%%
%%    numStateItems       : The number of POD items to store at this level.
%%
%%    numModelBlocks      : The number of Model blocks at this level.
%%
%%    numberOfIterations  : The number of times this level is iterated.
%%                          (> 0 == For Each SS)
%%
%%    numForEachSSs       : The number of For Each Subsystems at this level.
%%
%function SLibCreateEmptyRTDWTreeObject(newPrefixName)
  %createrecord rtdwTree { ...
    prefixName    newPrefixName; ...
    numStateItems       0; ...
    numModelBlocks      0; ...
    numberOfIterations  0; ...
    numForEachSSs       0  ...
  }

  %return rtdwTree
%endfunction

%% =========================================================================== |
%% Function: SLibRTDWTreeContainsPersistentState
%% Abstract: Returns true if there is something that needs to be cached.
%%
%function SLibRTDWTreeContainsPersistentState(rtdwTree)
  %return ...
    rtdwTree.numStateItems  > 0 || ...
    rtdwTree.numModelBlocks > 0 || ...
    rtdwTree.numForEachSSs  > 0
%endfunction

%% =========================================================================== |
%% Function: SLibEnumerateAndIndexRTDWTree
%% Abstract: Make a flat list of DWORK paths to be used in various places, and
%%           insert the corresponding indices to the flat list into each leaf
%%           node. For single-instance Model blocks, the model name is used
%%           as a placeholder since the paths are used as the field names for
%%           the container struct.
%%
%function SLibEnumerateAndIndexRTDWTree(...
  rtdwTree, prefix, rtdwList, loopDepth) void

  %foreach modelIdx = rtdwTree.numModelBlocks

    %assign thisBlock = rtdwTree.modelBlock[modelIdx]

    %addtorecord thisBlock index rtdwList.numItems

    %if WHITE_SPACE(thisBlock.dwName)
      %addtorecord rtdwList item { value thisBlock.modelName }
    %else
      %addtorecord rtdwList item { value prefix + "." + thisBlock.dwName }
    %endif

    %assign rtdwList.numItems = rtdwList.numItems + 1
  %endforeach

  %foreach stateIdx = rtdwTree.numStateItems
    %assign thisState = rtdwTree.stateItem[stateIdx]

    %addtorecord thisState index rtdwList.numItems

    %addtorecord rtdwList item { value prefix + "." + thisState.name }

    %assign rtdwList.numItems = rtdwList.numItems + 1
  %endforeach

  %if rtdwTree.numForEachSSs > 0
    %assign maxLoopDepth = %<loopDepth> + 1

    %foreach ssIdx = rtdwTree.numForEachSSs
      %assign thisSS = rtdwTree.forEachSS[ssIdx]
      %assign subPrefix = prefix + "." + thisSS.prefixName + "[0]"
      %assign subLoopDepth = ...
        %<SLibEnumerateAndIndexRTDWTree(thisSS, subPrefix, rtdwList, loopDepth+1)>
      %if subLoopDepth > maxLoopDepth
        %assign maxLoopDepth = subLoopDepth
      %endif
    %endforeach

    %assign loopDepth = maxLoopDepth
  %endif

  %return loopDepth
%endfunction

%% =========================================================================== |
%% Function: SLibGetDWorkMemberNamesForSystem
%% Abstract: Construct the fully-qualified variable names for the members
%%           of the MdlrefDW_model_checksum_T struct and return them as
%%           a record.
%%
%function SLibGetDWorkMemberNamesForSystem(currentSystem, isSingleInstance)
  %assign hasRTB   = currentSystem.HasBlockIOArg
  %assign hasRTDW  = currentSystem.HasDWorkArg
  %assign hasRTZCE = currentSystem.HasZCEventArg

  %if isSingleInstance
    %assign rtbName   = FcnSysVarGroupNonreusedName(currentSystem, "BlockIO")
    %assign rtdwName  = FcnSysVarGroupNonreusedName(currentSystem, "DWork"  )
    %assign rtzceName = FcnSysVarGroupNonreusedName(currentSystem, "ZCEvent")

    %assign rtbMxName   = hasRTB   ? rtbName   : "NULL_B"
    %assign rtdwMxName  = hasRTDW  ? rtdwName  : "NULL_DW" 
    %assign rtzceMxName = hasRTZCE ? rtzceName : "NULL_PrevZCX"
  %else
    %assign rtbName = !SLibGetUseRTMcgType() ? "rtb" : "rtm.blockIO"
    %assign dwName  = !SLibGetUseRTMcgType() ? "rtdw" : "rtm.dwork"
    %assign rtbMxName   = hasRTB   ? "%<rtbName>"   : "NULL->rtb"
    %assign rtdwMxName  = hasRTDW  ? "%<dwName>"  : "NULL->rtdw"
    %assign rtzceMxName = hasRTZCE ? "rtzce" : "NULL->rtzce"

    %assign mdlrefDWPtrName = SLibGetMdlrefDWPtrName()

    %assign rtbName   = hasRTB   ? "%<mdlrefDWPtrName>->%<rtbMxName>"   : ""
    %assign rtdwName  = hasRTDW  ? "%<mdlrefDWPtrName>->%<rtdwMxName>"  : ""
    %assign rtzceName = hasRTZCE ? "%<mdlrefDWPtrName>->%<rtzceMxName>" : ""
  %endif

  %createrecord dwMembers { ...
    rtbName   "%<rtbName>"   ;  rtbMxName   "%<rtbMxName>"   ; ...
    rtdwName  "%<rtdwName>"  ;  rtdwMxName  "%<rtdwMxName>"  ; ...
    rtzceName "%<rtzceName>" ;  rtzceMxName "%<rtzceMxName>" ; ...
    hasRTB %<hasRTB> ; hasRTDW %<hasRTDW> ; hasRTZCE %<hasRTZCE> ...
  }

  %return dwMembers
%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetDWorkPreamble
%% Abstract: Write the variable declarations needed at the beginning of the
%%           top-level scope of mr_model_{Get,Set}DWork.
%%
%function SLibWriteGetDWorkPreamble(...
    rtbMxName, rtdwMxName, rtzceMxName, ssMxName, getDWorkBuffer) void
  %selectfile getDWorkBuffer
  static const char * %<ssMxName>FieldNames[3] = {
    "%<rtbMxName>",
    "%<rtdwMxName>",
    "%<rtzceMxName>",
  };
  mxArray * %<ssMxName> = mxCreateStructMatrix(1, 1, 3, %<ssMxName>FieldNames);
%endfunction

%% =========================================================================== |
%% Function: SLibDWorkIsPWork
%% Abstract: Returns true if the argument DWORK is declared to be a PWORK or
%%           pointer type.
%%
%function SLibDWorkIsPWork(thisDWork)
  %if thisDWork.Origin == "PWORK"
    %return TLC_TRUE
  %endif

  %if LibCGTypeIsPointer(thisDWork.CGTypeIdx)
    %return TLC_TRUE
  %endif

  %if LibCGTypeIsMatrix(thisDWork.CGTypeIdx) && ...
    LibCGTypeIsPointer(LibCGTypeBaseIndex(thisDWork.CGTypeIdx))
    %return TLC_TRUE
  %endif

  %return TLC_FALSE
%endfunction

%% =========================================================================== |
%% Function: SLibGetDWorkStateItemsForVarGroup
%% Abstract: Recursively make a flat list of members of the DW to cache for
%%           the current model. Includes MdlrefDW structs for multi-instance
%%           models.
%%
%function SLibGetDWorkStateItemsForVarGroup(rtdwTree, varGroupIdx) void

  %if varGroupIdx >= 0

    %assign varGroup = ::CompiledModel.VarGroups.VarGroup[varGroupIdx]
    %assign cgType   = ::CompiledModel.CGTypes.CGType[varGroup.CGTypeIdx]

    %if LibCGTypeIsMatrix(varGroup.CGTypeIdx) %% this is a ForEach SS

      %% grab the number of iterations of this SS
      %assign rtdwTree.numberOfIterations = LibCGTypeWidth(varGroup.CGTypeIdx) 

      %% proceed using the base type of the SS
      %assign cgType = ::CompiledModel.CGTypes.CGType[LibCGTypeBaseIndex(varGroup.CGTypeIdx)]

    %endif

    %with cgType.Members

      %foreach mIdx = NumMembers

        %assign memberName = Member[mIdx].Name

        %assign idnum = IDNUM(varGroup.VarGroupElements[mIdx])

        %assign recType = idnum[0]
        %assign recIdx  = idnum[1]

        %switch recType
          %case "W"
          %case "LDW" %% local scratch dwork converted to global
            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Most DWORKs fall under this case.
            %%
            %assign dataRec = SLibGetDataRecForVarGroupMember(recType, recIdx)
            %assign sysIdx  = dataRec.SigSrc[0]
            %assign blkIdx  = dataRec.SigSrc[2]

            %if !(sysIdx >= 0 && blkIdx >= 0) %% is virtual
              %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
              %% If we ever encounter this combination, abort the compilation.
              %%
              %<SLibReportErrorWithIdAndArgs(...
                "Simulink:modelReference:InternalCodeGenerationError", ...
                Name + ": Virtual DWORK")>
              %exit
            %endif

            %assign ownerBlk = ::CompiledModel.System[sysIdx].Block[blkIdx]

            %if "ModelReference" == ownerBlk.Type && "DWORK" == dataRec.Origin
              %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
              %% Multi-instance Model blocks will have an entry in the DWORK
              %% tree. The MdlrefDW items for single-instance Models are picked
              %% up in SLibGetDWorkPairsForSingleInstanceModelBlocks.
              %%
              %if GetModelrefInterface(ownerBlk).IsScalableBuild
                %% This is an S-Function DWork owned by a single-instance model
                %% referenced from ownerBlk. Add it to the list of states
                %%
                %if !SLibDWorkIsPWork(dataRec)
                  %<SLibAppendStateItem(...
                    varGroup, mIdx, rtdwTree, memberName, dataRec)>
                %endif
              %else
                %% This is a MdlrefDW struct that belongs to the model 
                %% referenced by this block.
                %%
                %addtorecord rtdwTree ...
                  modelBlock { ...
                    modelName ownerBlk.ParamSettings.ReferencedModelName; ...
                    dwName memberName ...
                  }
                %assign rtdwTree.numModelBlocks = rtdwTree.numModelBlocks + 1
              %endif
            %elseif !SLibDWorkIsPWork(dataRec) %% all non-ModelReference blocks
              %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
              %% Most POD DWORKs will be picked up here.
              %%                
              %<SLibAppendStateItem(...
                varGroup, mIdx, rtdwTree, memberName, dataRec)>
            %endif

            %break %% case "W" "LDW"

          %case "VG"
            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% Recursively descend into non-virtual subsystems.
            %%
            %assign newRtdwTree = SLibCreateEmptyRTDWTreeObject(memberName)

            %<SLibGetDWorkStateItemsForVarGroup(newRtdwTree, recIdx)>

            %if newRtdwTree.numberOfIterations > 0
              %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
              %% If we parsed a ForEach SS DWORK structure, we need to add an 
              %% entry for each instance with the proper index appended the 
              %% member name prefix prior to the dot operator.
              %%
              %addtorecord rtdwTree forEachSS %<newRtdwTree>
              %assign rtdwTree.numForEachSSs = rtdwTree.numForEachSSs + 1
            %else
              %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
              %% This is a normal sub-structure in the DWORK, all we need is
              %% the dot operator. Fold the new sub-tree into the existing tree.
              %%
              %<SLibAppendNewRtdwTree(rtdwTree, newRtdwTree)>
            %endif

            %break %% case "VG"

          %case "S"
            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% 
            %addtorecord rtdwTree ...
              stateItem { name memberName; bitFieldWidth 0 }

            %assign rtdwTree.numStateItems = rtdwTree.numStateItems + 1
            
            %break %% case "S"

          %default
            %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
            %% If there other states that we haven't handled, abort compilation.
            %%
            %<SLibReportErrorWithIdAndArgs(...
              "Simulink:modelReference:InternalCodeGenerationError", ...
              Name + ": Unexpected recType")>
            %exit
        %endswitch
      %endforeach
    %endwith
  %endif

%endfunction

%% =========================================================================== |
%% Function: SLibAppendStateItem
%% Abstract: Append the current struct data member to the list of new state
%%           items for the system of interest.
%%
%function SLibAppendStateItem(...
  varGroup, mIdx, rtdwTree, memberName, dataRec) void

  %assign subStructIdx = varGroup.NumSubStructs > 0 ? ...
    varGroup.SubStructIndex[mIdx] : -1

  %assign subStructPath = -1 != subStructIdx ? ...
    varGroup.SubStuctNames[subStructIdx] + "." : ""

  %addtorecord rtdwTree ...
    stateItem { ...
      name subStructPath + memberName; ...
      bitFieldWidth dataRec.BitFieldWidth ...
    }

  %assign rtdwTree.numStateItems = rtdwTree.numStateItems + 1

%endfunction

%% =========================================================================== |
%% Function: SLibAppendNewRtdwTree
%% Abstract: Append the given tree of DWORK items to the current tree,
%%           prepending the new tree's prefix path.
%%
%function SLibAppendNewRtdwTree(rtdwTree, newRtdwTree) void

  %assign prefix = newRtdwTree.prefixName + "."

  %foreach stateIdx = newRtdwTree.numStateItems

    %addtorecord rtdwTree ...
      stateItem { ...
        name prefix + newRtdwTree.stateItem[stateIdx].name; ...
        bitFieldWidth newRtdwTree.stateItem[stateIdx].bitFieldWidth ...
      }

  %endforeach

  %assign rtdwTree.numStateItems = ...
    rtdwTree.numStateItems + newRtdwTree.numStateItems

  %foreach blockIdx = newRtdwTree.numModelBlocks

    %assign thisDwName = newRtdwTree.modelBlock[blockIdx].dwName

    %addtorecord rtdwTree ...
      modelBlock { ...
        modelName newRtdwTree.modelBlock[blockIdx].modelName; ...
        dwName "" == thisDwName ? "" : prefix + thisDwName ...
      }

  %endforeach

  %assign rtdwTree.numModelBlocks = ...
    rtdwTree.numModelBlocks + newRtdwTree.numModelBlocks  

  %foreach ssIdx = newRtdwTree.numForEachSSs

    %assign thisForEachSS = newRtdwTree.forEachSS[ssIdx]
    %assign thisForEachSS.prefixName = prefix + thisForEachSS.prefixName
    %addtorecord rtdwTree forEachSS %<thisForEachSS>

  %endforeach

  %assign rtdwTree.numForEachSSs = ...
    rtdwTree.numForEachSSs + newRtdwTree.numForEachSSs

%endfunction

%% =========================================================================== |
%% Function: SLibGetDWorkPairsForSingleInstanceModelBlocks
%% Abstract: Appends entries for the single-instance referenced models to
%%           the provided list of { model ; path.to.model_DWORK1 } pairs.
%%
%%         > Single-instance referenced models own their state, so an empty
%%           string is returned for the path. This signifies that the 
%%           getter/setter does not require a pointer to be passed from the
%%           parent model.
%%
%%         > Multi-instance referenced models place their state in the RTDW
%%           heirarchy, so the data needed to generate calls to their
%%           respective mr_model_{get,set}DWork functions is picked up in
%%           SLibGetDWorkStateItemsForVarGroup.
%%
%function SLibGetDWorkPairsForSingleInstanceModelBlocks(rtdwTree) void

  %foreach idIdx = NumModelReferenceBlocks

    %assign blkIdx  = ModelReferenceBlocks[idIdx]
    %assign mdlBlk  = System[blkIdx[0]].Block[blkIdx[1]]
    %assign blkIntf = GetModelrefInterface(mdlBlk)

    %if blkIntf.IsScalableBuild %% single-instance mode

      %addtorecord rtdwTree ...
        modelBlock { ...
          modelName mdlBlk.ParamSettings.ReferencedModelName; ...
          dwName "" ...
        }

      %assign rtdwTree.numModelBlocks = rtdwTree.numModelBlocks + 1

    %endif
  %endforeach
%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetSetRTDWContents
%% Abstract: Writes code to cache/restore the contents of dw->rtdw/model_DW.
%%
%function SLibWriteGetSetRTDWContents(...
    rtdwTree, ...
    ssMxName, ssMxIndex, ...
    getDWorkBuffer, setDWorkBuffer) void

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Prepare to generate code.
  %%
  %createrecord rtdwList { numItems 0 }
  %assign maxLoopDepth = ...
    SLibEnumerateAndIndexRTDWTree(rtdwTree, rtdwTree.prefixName, rtdwList, 0)

  %% for variable and constant declarations at the beginning of the rtdw scope
  %openfile getDWorkDeclarationsBuffer
  %openfile setDWorkDeclarationsBuffer

  %% for memory allocation statements and other things that must happen between
  %% the definition statements and the main body
  %openfile getDWorkPreambleBuffer
  %openfile setDWorkPreambleBuffer

  %% for the actual load/save operation statements
  %openfile getDWorkBodyBuffer
  %openfile setDWorkBodyBuffer

  %% for anything that must be done after all of the state load/save operations
  %% are complete
  %openfile getDWorkEpilogueBuffer
  %openfile setDWorkEpilogueBuffer

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Generate code.
  %%
  %assign rtdwMxName = "rtdwData"

  %<SLibWriteGetSetRTDWDeclarations(...
    rtdwList, rtdwMxName, ...
    ssMxName, ssMxIndex, ...
    getDWorkDeclarationsBuffer, setDWorkDeclarationsBuffer)>

  %<SLibWriteGetSetRTDWItems(...
    rtdwTree, rtdwList, maxLoopDepth, ...
    rtdwMxName, ...
    getDWorkDeclarationsBuffer, setDWorkDeclarationsBuffer, ...
    getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
    getDWorkBodyBuffer, setDWorkBodyBuffer)>

  %<SLibWriteGetSetRTDWEpilogue(...
    rtdwMxName, ssMxName, ssMxIndex, ...
    getDWorkEpilogueBuffer, setDWorkEpilogueBuffer)>

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Consolidate generated code.
  %%
  %closefile getDWorkDeclarationsBuffer
  %closefile setDWorkDeclarationsBuffer

  %closefile getDWorkPreambleBuffer
  %closefile setDWorkPreambleBuffer

  %closefile getDWorkBodyBuffer
  %closefile setDWorkBodyBuffer

  %closefile getDWorkEpilogueBuffer
  %closefile setDWorkEpilogueBuffer

  %selectfile getDWorkBuffer

  %<getDWorkDeclarationsBuffer>
  %<getDWorkPreambleBuffer>
  %<getDWorkBodyBuffer>
  %<getDWorkEpilogueBuffer>

  %selectfile setDWorkBuffer

  %<setDWorkDeclarationsBuffer>
  %<setDWorkPreambleBuffer>
  %<setDWorkBodyBuffer>
  %<setDWorkEpilogueBuffer>

%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetSetRTDWDeclarations
%% Abstract: Open a new scope and declare local variables needed to cache the
%%           contents of dw->rtdw/model_DW.
%%
%function SLibWriteGetSetRTDWDeclarations(...
    rtdwList, ...
    rtdwMxName, ssMxName, ssMxIndex, ...
    getDWorkDeclarationsBuffer, setDWorkDeclarationsBuffer) void

  %selectfile getDWorkDeclarationsBuffer

  {
    %if rtdwList.numItems > 0
    static const char * %<rtdwMxName>FieldNames[%<rtdwList.numItems>] = {
      %foreach itemIdx = rtdwList.numItems
        "%<rtdwList.item[itemIdx].value>",
      %endforeach
    };
    %else 
    static const char * %<rtdwMxName>FieldNames = NULL;
    %endif
    mxArray * %<rtdwMxName> =
      mxCreateStructMatrix(1, 1, %<rtdwList.numItems>, %<rtdwMxName>FieldNames);

  %selectfile setDWorkDeclarationsBuffer

  {
    const mxArray * %<rtdwMxName> = 
      mxGetFieldByNumber(%<ssMxName>, 0, %<ssMxIndex>);

%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetSetRTDWEpilogue
%% Abstract: Terminate the block scope that caches/restores the rtdw struct.
%%
%function SLibWriteGetSetRTDWEpilogue(...
    rtdwMxName, ssMxName, ssMxIndex, ...
    getDWorkBodyBuffer, setDWorkBodyBuffer) void
  
  %selectfile getDWorkBodyBuffer

    mxSetFieldByNumber(%<ssMxName>, 0, %<ssMxIndex>, %<rtdwMxName>);
  }
  
  %selectfile setDWorkBodyBuffer  

  }

%endfunction

%% =========================================================================== |
%% Function: SLibWriteGetSetRTDWItems
%% Abstract: Writes the code that caches/restores the MdlrefDW contents.
%%
%% This creates a record of commonly-used items such as loop variable names,
%% along with the workspace used to compute offsets when marshalling DWORKS
%% contained within a For Each SS. After this record is created, recurse the 
%% tree and populate the loop bodies.
%%
%function SLibWriteGetSetRTDWItems(...
    rtdwTree, rtdwList, maxLoopDepth, rtdwMxName, ...
    getDWorkDeclarationsBuffer, setDWorkDeclarationsBuffer, ...
    getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
    getDWorkBodyBuffer, setDWorkBodyBuffer) void

  %createrecord forEachDims { numDims 0; maxDims %<maxLoopDepth> }

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% If we are generating loop bodies, pre-generate the variable names and
  %% emit code declaring the loop counter variables. Since we may have multiple
  %% loop scopes, we emit the offsetN variable at the start of each loop body
  %% instead of declaring them with the loop counter. Loop counts are written
  %% as numeric literals.
  %%
  %foreach loopIdx = maxLoopDepth

    %addtorecord forEachDims dim { size 0 }

    %assign loopVarName = "k" + "%<loopIdx>"

    %addtorecord forEachDims loopVar { name loopVarName }
    %addtorecord forEachDims offsetVar { name "offset%<loopIdx>" }

    %selectfile getDWorkDeclarationsBuffer

    int %<loopVarName>;

    %selectfile setDWorkDeclarationsBuffer

    int %<loopVarName>;

  %endforeach

  %<SLibTraverseAndGenerateGetSetRTDWItems(...
    rtdwTree, rtdwList, forEachDims, "", rtdwMxName, ...
    getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
    getDWorkBodyBuffer, setDWorkBodyBuffer)>

%endfunction

%% =========================================================================== |
%% Function: SLibTraverseAndGenerateGetSetRTDWItems
%% Abstract: Recursively descend the intermediate tree of DWORK items.
%%
%% DWORKs contained inside atomic SSs within a For Each SS are folded into their
%% enclosing For Each SS. On entry, we write out all DWORK items that are not
%% contained within a For Each SS, then traverse the tree of each For Each SS.
%% At each level, we open a new loop body on entry and close it on exit.
%%
%% Within a given loop body, then number of copies of all DWORKS at that level
%% of the tree are fixed. This number is stored in the variable "offset{0,...}"
%% and used where appropriate.
%%
%% Memory allocation for each DWORK happens in the preamble. For MdlrefDW and
%% bitfield types, a cell matrix is created. All other items are marshalled
%% into an appropriately-sized uint8_T array.
%%
%function SLibTraverseAndGenerateGetSetRTDWItems(...
  rtdwTree, rtdwList, forEachDims, prefixName, rtdwMxName, ...
  getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
  getDWorkBodyBuffer, setDWorkBodyBuffer) void

  %assert 0 == rtdwTree.numberOfIterations
  %assert WHITE_SPACE(prefixName)

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Emit code for Model blocks
  %%
  %foreach modelIdx = rtdwTree.numModelBlocks
    %assign thisBlock = rtdwTree.modelBlock[modelIdx]
    %assign modelName = thisBlock.modelName
    %assign dwIndex = thisBlock.index
    %assign dwName = rtdwList.item[dwIndex].value
    %assign isSingleInstanceModelBlock = WHITE_SPACE(thisBlock.dwName)

    %selectfile getDWorkBodyBuffer
    {
     
    %if isSingleInstanceModelBlock
      mxArray* varData = %<SLibCreateGetDWorkFcnNameForModel(modelName)>();
    %else
      mxArray* varData = %<SLibCreateGetDWorkFcnNameForModel(modelName)>(\
        &(%<dwName>));
    %endif
      mxSetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>, varData);
    }

    %selectfile setDWorkBodyBuffer
    
    %if isSingleInstanceModelBlock
      %<SLibCreateSetDWorkFcnNameForModel(modelName)>(\
      mxGetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>));
    %else
      %<SLibCreateSetDWorkFcnNameForModel(modelName)>(
        &(%<dwName>),
        mxGetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>));
    %endif

  %endforeach

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Emit code for this model's DWORKs
  %%
  %foreach stateIdx = rtdwTree.numStateItems
    %assign thisState = rtdwTree.stateItem[stateIdx]
    %assign numBits   = thisState.bitFieldWidth

    %assign dwIndex = thisState.index
    %assign dwName  = rtdwList.item[dwIndex].value

    %if 0 != numBits
      %<SLibWriteCacheRestoreBitFieldToFromMxArray(...
        dwName, rtdwMxName, dwIndex, ...
        numBits, getDWorkBodyBuffer, setDWorkBodyBuffer)>
    %else
      %<SLibWriteCacheRestoreVariableToFromMxArray(...
        dwName, rtdwMxName, dwIndex, ...
        getDWorkBodyBuffer, setDWorkBodyBuffer)>        
    %endif

  %endforeach

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Recursively emit code for For Each SS blocks
  %%
  %foreach ssIdx = rtdwTree.numForEachSSs

    %<SLibGenerateForEachGetSetRTDWItems(...
      rtdwTree.forEachSS[ssIdx], rtdwList, forEachDims, ...
      rtdwTree.prefixName, rtdwMxName, ...
      getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
      getDWorkBodyBuffer, setDWorkBodyBuffer)>

  %endforeach

%endfunction

%% =========================================================================== |
%% Function: SLibGenerateForEachGetSetRTDWItems
%% Abstract: Emit code to cache/restore DWORK items that are inside a
%%           For Each SS hierarchy.
%%
%% Recurses on every For Each SS it contains.
%%
%function SLibGenerateForEachGetSetRTDWItems(...
  rtdwTree, rtdwList, forEachDims, prefixName, rtdwMxName, ...
  getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
  getDWorkBodyBuffer, setDWorkBodyBuffer) void

  %assert 0 < rtdwTree.numberOfIterations
  %assert !WHITE_SPACE(prefixName)

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Setup up dimensions and loop variables
  %%
  %assign loopVarName = forEachDims.loopVar[forEachDims.numDims].name
  %assign fullPrefix  = "%<prefixName>.%<rtdwTree.prefixName>[%<loopVarName>]"

  %assign forLoopStatement = ...
    "for(" + loopVarName + " = 0; " ...
      +  loopVarName + " < " + "%<rtdwTree.numberOfIterations>" + "; " ...
      + "++" + loopVarName + ")"

  %assign forEachDims.dim[forEachDims.numDims].size = rtdwTree.numberOfIterations
  %assign offsetVarName = forEachDims.offsetVar[forEachDims.numDims].name
  %assign forEachDims.numDims = forEachDims.numDims + 1
  %assign loopOffsetStatement = SLibGetOffsetDefinitionForLoop(forEachDims)
  %assign matrixSize = SLibGetMatrixSizeForLoop(forEachDims)

  %selectfile getDWorkBodyBuffer

  %<forLoopStatement>
  {
    %<loopOffsetStatement>

  %selectfile setDWorkBodyBuffer

  %<forLoopStatement>
  {
    %<loopOffsetStatement>

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Emit code for Model blocks
  %%
  %foreach modelIdx = rtdwTree.numModelBlocks
    %assign thisBlock = rtdwTree.modelBlock[modelIdx]
    %assign modelName = thisBlock.modelName
    %assign dwIndex = thisBlock.index
    %assign dwName = fullPrefix  + "." + thisBlock.dwName

    %if WHITE_SPACE(thisBlock.dwName)
      %<SLibReportErrorWithIdAndArgs(...
        "Simulink:modelReference:InternalCodeGenerationError", ...
        Name + ": Single-instance Model block within For Each Subsystem")>
    %endif

    %selectfile getDWorkPreambleBuffer

    mxSetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>, \
      mxCreateCellMatrix(1, %<matrixSize>));

    %selectfile getDWorkBodyBuffer
    {
     
      mxArray* varData = %<SLibCreateGetDWorkFcnNameForModel(modelName)>( \
        &(%<dwName>));

      mxSetCell(mxGetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>), \
        %<offsetVarName>, varData);
    }

    %selectfile setDWorkBodyBuffer

    %<SLibCreateSetDWorkFcnNameForModel(modelName)>(\
      &(%<dwName>), \
      mxGetCell(mxGetFieldByNumber(%<rtdwMxName>,0, %<dwIndex>), \
      %<offsetVarName>));

  %endforeach

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Emit code for DWORK items at this level
  %%
  %foreach stateIdx = rtdwTree.numStateItems
    %assign thisState = rtdwTree.stateItem[stateIdx]
    %assign numBits   = thisState.bitFieldWidth

    %assign dwIndex = thisState.index
    %assign dwName  = fullPrefix + "." + thisState.name

    %if 0 != numBits

      %selectfile getDWorkPreambleBuffer

      mxSetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>, \
        mxCreateCellMatrix(1, %<matrixSize>));

      %selectfile getDWorkBodyBuffer

      %<SLibGetCacheBitFieldToCellArrayWithOffsetFcnName()>(\
        %<rtdwMxName>, 0, %<dwIndex>, %<offsetVarName>, %<dwName>);

      %selectfile setDWorkBodyBuffer

      %<dwName> = %<SLibGetExtractBitFieldFromCellArrayWithOffsetFcnName()>(\
        %<rtdwMxName>, 0, %<dwIndex>, %<offsetVarName>, %<numBits>);

    %else

      %selectfile getDWorkPreambleBuffer

      mxSetFieldByNumber(%<rtdwMxName>, 0, %<dwIndex>, \
        mxCreateUninitNumericMatrix( \
          1, \
          %<matrixSize>*sizeof(%<rtdwList.item[dwIndex].value>), \
          mxUINT8_CLASS, mxREAL));

      %selectfile getDWorkBodyBuffer

      %<SLibGetCacheDataToMxArrayWithOffsetFcnName()>( \
        %<rtdwMxName>, 0, %<dwIndex>, %<offsetVarName>, \
        &(%<dwName>), sizeof(%<rtdwList.item[dwIndex].value>));

      %selectfile setDWorkBodyBuffer

      %<SLibGetRestoreDataFromMxArrayWithOffsetFcnName()>( \
        &(%<dwName>), \
        %<rtdwMxName>, 0, %<dwIndex>, %<offsetVarName>, \
        sizeof(%<rtdwList.item[dwIndex].value>));

    %endif

  %endforeach

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Recursively emit code for For Each SSs at this level
  %%
  %foreach ssIdx = rtdwTree.numForEachSSs

    %<SLibGenerateForEachGetSetRTDWItems(...
      rtdwTree.forEachSS[ssIdx], rtdwList, forEachDims, ...
      fullPrefix, rtdwMxName, ...
      getDWorkPreambleBuffer, setDWorkPreambleBuffer, ...
      getDWorkBodyBuffer, setDWorkBodyBuffer)>

  %endforeach

  %% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |
  %% Close this loop body and decrement the dimensions vector counter
  %%
  %selectfile getDWorkBodyBuffer
  }

  %selectfile setDWorkBodyBuffer
  }

  %assign forEachDims.numDims = forEachDims.numDims - 1

%endfunction

%% =========================================================================== |
%% Function: SLibGetOffsetDefinitionForLoop
%% Abstract: Compute and define the offsetN variable for the innermost loop body
%%           with the specified dimensions. Returns the variable definition
%%           statement.
%%
%% This is the offset into the array used to store the instances of a DWORK
%% contained within a For Each SS. The value is
%%
%%   offset_(N_d-1) = Sum_(i=0)_(N_d-1) { k_i * Prod_(j=i+1)_(j=N_d-1){ l_j } }
%%
%%   , where
%%
%%   N_d = depth of the loop nest
%%   k_i = loop variable of the i'th dimension
%%   l_j = number of loops over the j'th dimension
%% 
%% (We use the convention that Prod_n_n {} = 1)
%%
%function SLibGetOffsetDefinitionForLoop(forEachDims)
  %assign offsetVal = ""

  %foreach i = forEachDims.numDims

    %if i > 0
      %assign offsetVal = offsetVal + " + "
    %endif

    %assign offsetVal = offsetVal + forEachDims.loopVar[i].name

    %foreach j = forEachDims.numDims
      %if j > i
        %assign offsetVal = offsetVal + "*%<forEachDims.dim[j].size>"
      %endif
    %endforeach

  %endforeach 

  %return "const mwIndex %<forEachDims.offsetVar[forEachDims.numDims-1].name>" ...
    + " = %<offsetVal>;"

%endfunction

%% =========================================================================== |
%% Function: SLibGetMatrixSizeForLoop
%% Abstract: For a given loop nesting level, compute the number of times its
%%           body will be executed and return it.
%%
%function SLibGetMatrixSizeForLoop(forEachDims)
  %assign matrixSize = 1
  %foreach i = forEachDims.numDims
    %assign matrixSize = matrixSize * forEachDims.dim[i].size
  %endforeach
  %return matrixSize
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetDWorkFcnSigForModel
%% Abstract: Construct the model_GetDWork function signature.
%%
%function SLibCreateGetDWorkFcnSigForModel(thisModelName)
  %assign getFcnName = SLibCreateGetDWorkFcnNameForModel(Name)
  %assign getFcnArgs = SLibCreateGetDWorkFcnArgs()
  %return "mxArray * %<getFcnName>%<getFcnArgs>"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateSetDWorkFcnSigForModel
%% Abstract: Construct the model_SetDWork function signature.
%%
%function SLibCreateSetDWorkFcnSigForModel(thisModelName)
  %assign setFcnName = SLibCreateSetDWorkFcnNameForModel(Name)
  %assign setFcnArgs = SLibCreateSetDWorkFcnArgs()
  %return "void %<setFcnName>%<setFcnArgs>"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetDWorkFcnNameForModel
%% Abstract: Creates the model_GetDWork function name.
%%
%function SLibCreateGetDWorkFcnNameForModel(thisModelName)
  %return "mr_%<thisModelName>_GetDWork"
%endfunction

%% =========================================================================== |
%% Function: SLibGetMdlrefDWPtrName
%% Abstract: Single point of definition for the pointer to the MdlrefDW struct.
%%
%function SLibGetMdlrefDWPtrName()
  %return "mdlrefDW"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetDWorkFcnArgs
%% Abstract: Get the argument signature for the mr_model_GetDWork function.
%%           If the model is single-instance, then it owns its DWork and
%%           takes no arguments.
%% 
%function SLibCreateGetDWorkFcnArgs()
  %if ::CompiledModel.OkToMultiInstanceModelref
    %return "(const %<tsysMdlrefDWorkType> * %<SLibGetMdlrefDWPtrName()>)"
  %endif
  %return "()"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateSetDWorkFcnNameForModel
%% Abstract: Creates the model_SetDWork function name.
%%
%function SLibCreateSetDWorkFcnNameForModel(thisModelName)
  %return "mr_%<thisModelName>_SetDWork"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateSetDWorkFcnArgs
%% Abstract: Get the argument signature for the model_SetDWork function.
%%           If the model is single-instance, then it owns its DWork and
%%           only needs a pointer to the data it cached in the getter.
%%
%function SLibCreateSetDWorkFcnArgs()
  %if ::CompiledModel.OkToMultiInstanceModelref
    %assign mdlrefDW = SLibGetMdlrefDWPtrName()
    %return "(%<tsysMdlrefDWorkType> * %<mdlrefDW>, const mxArray* ssDW)"
  %endif
  %return "(const mxArray* ssDW)"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetSimStateDisallowedBlocksFcnSigForModel
%% Abstract: Create the function signature for the function
%%           mr_model_GetSimStateDisallowedBlocks.
%%
%function SLibCreateGetSimStateDisallowedBlocksFcnSigForModel(thisModelName)
  %assign fcnName = ...
    SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(thisModelName)

  %assign fcnArgs = SLibCreateGetSimStateDisallowedBlocksFcnArgs()

  %return "mxArray * %<fcnName>%<fcnArgs>"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetSimStateDisallowedBlocksFcnArgs
%% Abstract: Get the argument signature for the function
%%           mr_model_GetSimStateDisallowedBlocks.
%%
%function SLibCreateGetSimStateDisallowedBlocksFcnArgs()
  %return "()"
%endfunction

%% =========================================================================== |
%% Function: SLibCreateGetSimStateDisallowedBlocksFcnNameForModel
%% Abstract: Create the mr_model__GetSimStateDisallowedBlocks function name.
%%
%function SLibCreateGetSimStateDisallowedBlocksFcnNameForModel(thisModelName)
  %return "mr_%<thisModelName>_GetSimStateDisallowedBlocks"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheRestoreBitFieldToFromMxArray
%% Abstract: Add code to cache/restore the specified variable
%%           to the appropriate buffers. 
%%
%function SLibWriteCacheRestoreBitFieldToFromMxArray(...
    varName, mxName, mxIndex, numBits, getBuffer, setBuffer) void
  
  %selectfile getBuffer
  %<SLibGetCacheBitFieldToMxArrayFcnName()>(
    %<mxName>, 0, %<mxIndex>, (uint_T) %<varName>);

  %selectfile setBuffer
  %<varName> = %<SLibGetExtractBitFieldFromMxArrayFcnName()>(
    %<mxName>, 0, %<mxIndex>, %<numBits>);

%endfunction

%% =========================================================================== |
%% Function: SLibWriteCacheRestoreVariableToFromMxArray
%% Abstract: Add code to cache/restore the specified variable
%%           to the appropriate buffers. 
%%
%function SLibWriteCacheRestoreVariableToFromMxArray(...
    varName, mxName, mxIndex, getBuffer, setBuffer) void
  %selectfile getBuffer
  %<SLibGetCacheDataAsMxArrayFcnName()>(
    %<mxName>, 0, %<mxIndex>, &(%<varName>), sizeof(%<varName>));
 
  %selectfile setBuffer
  %<SLibGetRestoreDataFromMxArrayFcnName()>(
    &(%<varName>), %<mxName>, 0, %<mxIndex>, sizeof(%<varName>));

%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefCacheBitFieldToMxArrayFcn
%% Abstract: Construct the mr_cacheBitFieldToMxArray function.
%%
%function SLibWriteMdlRefCacheBitFieldToMxArrayFcn() void
  %assign fcnArgs = "(mxArray * destArray, mwIndex i, int j, uint_T bitVal)"
  %assign fcnSig  = ...
    "static void %<SLibGetCacheBitFieldToMxArrayFcnName()>%<fcnArgs>"

  %openfile fcnBuffer
  %<fcnSig>;
  %<fcnSig>
  {
    %% This seems brittle to me: What if someone creates a 64-bit wide field?
    %% A double can only encode 51 bits. Hopefully a compiler warning will
    %% tip the user off.
    %%
    mxSetFieldByNumber(destArray, i, j, mxCreateDoubleScalar((double) bitVal));
  }
  %closefile fcnBuffer

  %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefExtractBitFieldFromMxArrayFcn
%% Abstract: Construct the mr_extractBitFieldFromMxArray function.
%%
%function SLibWriteMdlRefExtractBitFieldFromMxArrayFcn() void
  %assign fcnArgs = ...
    "(const mxArray * srcArray, mwIndex i, int j, uint_T numBits)"
  %assign fcnSig = ...
    "static uint_T %<SLibGetExtractBitFieldFromMxArrayFcnName()>%<fcnArgs>"

  %openfile fcnBuffer
  %<fcnSig>;
  %<fcnSig>
  {
    const uint_T varVal = (uint_T) mxGetScalar(mxGetFieldByNumber(srcArray, i, j));
    return varVal & ((1u<<numBits)-1u);
  }
  %closefile fcnBuffer

  %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefCacheDataAsMxArrayFcn
%% Abstract: Construct the mr_cacheDataAsMxArray function.
%%
%function SLibWriteMdlRefCacheDataAsMxArrayFcn() void
  %assign fcnArgs = ...
    "(mxArray * destArray, mwIndex i, int j, const void * srcData, size_t numBytes)"
  %assign fcnSig  = ...
    "static void %<SLibGetCacheDataAsMxArrayFcnName()>%<fcnArgs>"

  %openfile fcnBuffer
  %<fcnSig>;
  %<fcnSig>
  {
    mxArray * newArray = 
      mxCreateUninitNumericMatrix((size_t) 1, numBytes, mxUINT8_CLASS, mxREAL);
    memcpy((uint8_T *) mxGetData(newArray), (const uint8_T *) srcData, numBytes);
    mxSetFieldByNumber(destArray, i, j, newArray);
  }
  %closefile fcnBuffer

  %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefRestoreDataFromMxArrayFcn
%% Abstract: Construct the mr_restoreDataFromMxArray function.
%%
%function SLibWriteMdlRefRestoreDataFromMxArrayFcn() void
  %assign fcnArgs = ...
    "(void * destData, const mxArray * srcArray, mwIndex i, int j, size_t numBytes)"
  %assign fcnSig  = ...
    "static void %<SLibGetRestoreDataFromMxArrayFcnName()>%<fcnArgs>"

  %openfile fcnBuffer
  %<fcnSig>;
  %<fcnSig>
  {
    memcpy((uint8_T *) destData, 
           (const uint8_T *) mxGetData(mxGetFieldByNumber(srcArray, i, j)),
           numBytes);
  }
  %closefile fcnBuffer

  %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibGetCacheBitFieldToMxArrayFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetCacheBitFieldToMxArrayFcnName()
  %return "mr_%<::CompiledModel.Name>_cacheBitFieldToMxArray"
%endfunction

%% =========================================================================== |
%% Function: SLibGetExtractBitFieldFromMxArrayFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetExtractBitFieldFromMxArrayFcnName()
  %return "mr_%<::CompiledModel.Name>_extractBitFieldFromMxArray"
%endfunction

%% =========================================================================== |
%% Function: SLibGetCacheDataAsMxArrayFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetCacheDataAsMxArrayFcnName()
  %return "mr_%<::CompiledModel.Name>_cacheDataAsMxArray"
%endfunction

%% =========================================================================== |
%% Function: SLibGetRestoreDataFromMxArrayFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetRestoreDataFromMxArrayFcnName()
  %return "mr_%<::CompiledModel.Name>_restoreDataFromMxArray"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefCacheDataToMxArrayWithOffsetFcn
%% Abstract: Construct the mr_cacheDataToMxArrayWithOffset function.
%%
%function SLibWriteMdlRefCacheDataToMxArrayWithOffsetFcn() void
  %assign fcnArgs = ...
    "(mxArray * destArray, mwIndex i, int j, mwIndex offset, const void * srcData, size_t numBytes)"
  %assign fcnSig  = "static void %<SLibGetCacheDataToMxArrayWithOffsetFcnName()>%<fcnArgs>"

  %openfile fcnBuffer
  %<fcnSig>;
  %<fcnSig>
  {
    uint8_T * varData = \
      (uint8_T *) mxGetData(mxGetFieldByNumber(destArray, i, j));

    memcpy( \
      (uint8_T *) &varData[offset*numBytes], \ 
      (const uint8_T *) srcData, \
      numBytes);
  }
  %closefile fcnBuffer

  %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefRestoreDataFromMxArrayWithOffsetFcn
%% Abstract: Construct the mr_restoreDataFromMxArrayWithOffset function.
%%
%function SLibWriteMdlRefRestoreDataFromMxArrayWithOffsetFcn() void
  %assign fcnArgs = ...
    "(void * destData, const mxArray * srcArray, mwIndex i, int j, mwIndex offset, size_t numBytes)"
  %assign fcnSig  = ...
    "static void %<SLibGetRestoreDataFromMxArrayWithOffsetFcnName()>%<fcnArgs>"

  %openfile fcnBuffer
  %<fcnSig>;
  %<fcnSig>
  {
    const uint8_T * varData = \
      (const uint8_T *) mxGetData(mxGetFieldByNumber(srcArray, i, j));

    memcpy( \
      (uint8_T *) destData, \
      (const uint8_T *) &varData[offset*numBytes], \ 
      numBytes);
  }
  %closefile fcnBuffer

  %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibGetCacheDataToMxArrayWithOffsetFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetCacheDataToMxArrayWithOffsetFcnName()
  %return "mr_%<::CompiledModel.Name>_cacheDataToMxArrayWithOffset"
%endfunction

%% =========================================================================== |
%% Function: SLibGetRestoreDataFromMxArrayWithOffsetFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetRestoreDataFromMxArrayWithOffsetFcnName()
  %return "mr_%<::CompiledModel.Name>_restoreDataFromMxArrayWithOffset"
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefCacheBitFieldToCellArrayWithOffsetFcn
%% Abstract: Construct the mr_cacheBitFieldToCellArrayWithOffset function.
%%
%function SLibWriteMdlRefCacheBitFieldToCellArrayWithOffsetFcn() void
  %assign fcnArgs = ...
    "(mxArray * destArray, mwIndex i, int j, mwIndex offset, uint_T fieldVal)"
  %assign fcnSig  = ...
    "static void %<SLibGetCacheBitFieldToCellArrayWithOffsetFcnName()>%<fcnArgs>"

  %openfile fcnBuffer
  %<fcnSig>;
  %<fcnSig>
  {
    mxSetCell(mxGetFieldByNumber(destArray, i, j), offset, \
      mxCreateDoubleScalar((double) fieldVal));
  }
  %closefile fcnBuffer

  %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibWriteMdlRefExtractBitFieldFromCellArrayWithOffsetFcn
%% Abstract: Construct the mr_extractBitFieldFromCellArrayWithOffset function.
%%
%function SLibWriteMdlRefExtractBitFieldFromCellArrayWithOffsetFcn() void
  %assign fcnArgs = ...
    "(const mxArray * srcArray, mwIndex i, int j, mwIndex offset, uint_T numBits)"
  %assign fcnSig  = ...
    "static uint_T %<SLibGetExtractBitFieldFromCellArrayWithOffsetFcnName()>%<fcnArgs>"

  %openfile fcnBuffer
  %<fcnSig>;
  %<fcnSig>
  {
    const uint_T fieldVal = \
      (uint_T) mxGetScalar(mxGetCell(mxGetFieldByNumber(srcArray, i, j), offset));

    return fieldVal & ((1u << numBits) - 1u);
  }
  %closefile fcnBuffer

  %<SLibCacheCodeToFile("mdl_fcn_defn", fcnBuffer)>
%endfunction

%% =========================================================================== |
%% Function: SLibGetCacheBitFieldToCellArrayWithOffsetFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetCacheBitFieldToCellArrayWithOffsetFcnName()
  %return "mr_%<::CompiledModel.Name>_cacheBitFieldToCellArrayWithOffset"
%endfunction

%% =========================================================================== |
%% Function: SLibGetExtractBitfieldFromCellArrayWithOffsetFcnName
%% Abstract: Canonical getter for the name of this static utility function.
%%
%function SLibGetExtractBitFieldFromCellArrayWithOffsetFcnName()
  %return "mr_%<::CompiledModel.Name>_extractBitFieldFromCellArrayWithOffset"
%endfunction

%% =========================================================================== |
%% END ModelRefAccelModeSimState support
%% =========================================================================== |

%% Write exported model information to the model_msf.c.
%function SLibWriteMdlRefExportedMdlInfoForModelRef() void
  %with ::CompiledModel
    %openfile tmpBuffer
    int_T retVal = 1;
    %assign regFcnName = SLibCreateMdlInfoRegFcnName() 
    %<regFcnName>(S, "%<Name>", &retVal);    
    if (!retVal) return;
    %closefile tmpBuffer    
  %endwith  
  %return tmpBuffer
%endfunction

%function SLibCreateMdlInfoRegFcnName() void
  %return "mr_%<Name>_MdlInfoRegFcn"
%endfunction

%function SLibWriteMdlRefChildMdlsData() void
  %openfile tmpBuffer
  %with ::CompiledModel
    %assign endStr = ", "
    %if ChildMdls.NumChildMdls > 0 
	MdlRefChildMdlRec %<GlobalScope.tChildModels>[%<ChildMdls.NumChildMdls>] = {
	%foreach mdlIdx = ChildMdls.NumChildMdls
	  %assign childMdlName = ChildMdls.ChildMdl[mdlIdx].MdlName  
	  %assign childMdlPath = ChildMdls.ChildMdl[mdlIdx].RefPath
	  %assign childMdlSingleInst = ChildMdls.ChildMdl[mdlIdx].IsSingleInst
          %if mdlIdx == ChildMdls.NumChildMdls - 1
            %assign endStr = "};"
          %endif
          "%<childMdlName>","%<childMdlPath>",%<childMdlSingleInst> %<endStr>
        %endforeach
    %endif
  %endwith
  %closefile tmpBuffer
  %return tmpBuffer
%endfunction


%function SLibWriteMdlRefChildMdlsReg() void
  %openfile tmpBuffer
  %with ::CompiledModel
    %if ChildMdls.NumChildMdls > 0 
	ssRegModelRefChildModel(S, %<ChildMdls.NumChildMdls>, %<GlobalScope.tChildModels>);
    %endif
  %endwith
  %closefile tmpBuffer
  %return tmpBuffer
%endfunction

%% Function: FcnInitializeModelRefGlobalTimingEngine ===========================
%% Abstract:
%%    Declare all the global variables necessary for the global timing engine
%% and initialize these variables in the registration function
%function FcnInitializeModelRefGlobalTimingEngine() Output
  %assert IsModelReferenceTarget()

  %% Write out the declaration of the global TID map.  Note that for inherited
  %% submodels, we will put the map into the rtModel.  This is because each
  %% instance the submodel could get a different TID and we need the TID
  %% for logging.
  %assign numTIDs = SLibGetNumTIDsForGlobalTIDMap()

  %openfile cbuffer
  %if ::tMdlRefGlobalTIDMapAccessed
    %if MdlRefIsConstSampleBlock() && !MdlRefHasParameterRate()
      int_T %<::tMdlRefGlobalTID>[1];
    %elseif !RTMMdlRefGlobalTIDIsInstanceBased()
      int_T %<::tMdlRefGlobalTID>[%<numTIDs>];
    %endif
  %endif
  %if !IsModelReferenceForASimstructBasedTarget() && ...
    ::tMdlRefTimingBridgeAccessed && !RTMTimingBridgeIsReqFcn()
    %assert SLibIsERTCodeFormat()
    const rtTimingBridge *%<SLibGetGlobalTimingBridge()>;
  %endif
  %closefile cbuffer
  %<SLibCacheCodeToFile("mdl_data_defn", cbuffer)>
  
  %openfile hpbuffer
  %if ::tMdlRefGlobalTIDMapAccessed
    %if MdlRefIsConstSampleBlock() && !MdlRefHasParameterRate()
      extern int_T %<::tMdlRefGlobalTID>[1];
    %elseif !RTMMdlRefGlobalTIDIsInstanceBased()
      extern int_T %<::tMdlRefGlobalTID>[%<numTIDs>];
    %endif
  %endif
  %if !IsModelReferenceForASimstructBasedTarget() && ...
    ::tMdlRefTimingBridgeAccessed && !RTMTimingBridgeIsReqFcn()
    %assert SLibIsERTCodeFormat()
    extern const rtTimingBridge *%<SLibGetGlobalTimingBridge()>;
  %endif
  %closefile hpbuffer
  %<SLibCacheCodeToFile("mdl_priv_extern_data_decl", hpbuffer)>

  %if !GenerateClassInterface
    %if ::tMdlRefGlobalTIDMapAccessed
      /* setup the global timing engine */
      %if !MdlRefIsConstSampleBlock() || MdlRefHasParameterRate()
        %foreach idx = numTIDs
          %<FcnGetMdlRefGlobalTIDMap("")>[%<idx>] = mdlref_TID%<idx>;
        %endforeach
      %else
        %<::tMdlRefGlobalTID>[0] = mdlref_TID0;
      %endif
      
      %if RTMMdlRefTriggerTIDIsReqFcn()
        %<FcnGetMdlRefTriggerTIDMap("")> = mdlref_TriggerTID;
      %endif
    %endif
    
    %if !IsModelReferenceForASimstructBasedTarget() && ...
      ::tMdlRefTimingBridgeAccessed 
      %assert SLibIsERTCodeFormat() 
      %if RTMTimingBridgeIsReqFcn()
        %% Set timing bridge of rtm 
        %<RTMSet("timingBridge", "timingBridge")>;
      %else
        %<SLibGetGlobalTimingBridge()> = timingBridge;
      %endif
    %endif
  %endif
%endfunction

%% Function: FcnInitializeNoncontSignals =======================================
%% Abstract:
%%   Write out the declaration and initialization of the data structures for
%% handling information on noncontinous signals coming from model reference
%% blocks.  We create an array of type ssNonContDerivSig for each model 
%% reference block, and initialize the outports that we need information for.
%function FcnInitializeNoncontSignals() Output
  %if !HasModelReferenceBlocks()
    %return
  %endif
  %% Declare all the arrays
  %assign mdlRefBlks = ::CompiledModel.ModelReferenceBlocks
  %openfile declbuf
  %openfile codebuf
  %foreach rowIdx = SIZE(mdlRefBlks,0)
    %assign mdlRefInfo = mdlRefBlks[rowIdx]
    %assign mSysIdx = mdlRefInfo[0]
    %assign bIdx    = mdlRefInfo[1]
    %assign instIdx = mdlRefInfo[2]
    %assign blk = ::CompiledModel.System[mSysIdx].Block[bIdx]
    %assert 0 == blk.DeletedInIR
    %assign name = blk.ParamSettings.ReferencedModelName
    %assign blockInterface = GetModelrefInterface(blk)
    %if blockInterface.HasNonContOutput
      %assign mangleName = FcnGetNoncontMangledName(name, mSysIdx, bIdx, instIdx)
      %selectfile declbuf
      %assign comma = ""
      %% This is an array of pointers  of size nOutputPorts.  If an
      %% output port has any noncontinuous signals, we'll create
      %% another array to hold all those signals below
      ssNonContDerivSigFeedingOutports *mr_%<mangleName>nonContOutputArray[%<LibBlockNumOutputPorts(blk)>] = {\
      %foreach nullIdx = LibBlockNumOutputPorts(blk)
        %<comma>%<SLibGetNullDefinitionFromTfl()>\
        %assign comma = ", "
      %endforeach
      };
      %assign nonContPorts = blockInterface.NonContOutports
      %foreach pIdx = SIZE(nonContPorts,1)
        %if nonContPorts[pIdx] > 0
          %assign intNumSigs = CAST("Number", nonContPorts[pIdx])
          %selectfile declbuf
          %% Create an array of noncont signals for this port
          ssNonContDerivSigFeedingOutports mr_%<mangleName>nonContDerivSig%<pIdx>[%<intNumSigs>];
          %selectfile codebuf
          mr_%<mangleName>nonContOutputArray[%<pIdx>] = mr_%<mangleName>nonContDerivSig%<pIdx>;
        %endif
      %endforeach
    %endif
  %endforeach
  %closefile declbuf
  %closefile codebuf
  %<declbuf>\
  
  %<codebuf>\
%endfunction

%% Function: SLibGenNoncontDerivSigStruct ======================================
%% Abstract:
%%   Write out the structure which holds the memory needed when looking
%% at noncontinuous signals feeding deriv ports.  This is for modelref
%% only, and it helps avoid using malloc.
%function SLibGenNoncontDerivSigStruct() void
  %openfile declBuf
  
  /*
   * The following structure contains memory needed to 
   * track noncontinuous signals feeding derivative ports.
   */
   struct {
     %assign numNoncontDerivSigs = SIZE(SolverResetInfo.NonContDerivSignal,1)
     %assign arrayIdx = 0
     %foreach idx = numNoncontDerivSigs
       %assign dU = SolverResetInfo.NonContDerivSignal[idx]
       %if ISFIELD(dU,"MdlRefInfo")
         %foreach subIdx = dU.NumMdlRefNonContSigs
           %assign numBytes = dU.NonContSigSizeInBytes[subIdx]
           uint8_T mr_nonContSig%<arrayIdx>[%<numBytes>];
           %assign arrayIdx = arrayIdx + 1
         %endforeach
       %else
         %if dU.ComplexSignal
           %assign dtype = LibGetDataTypeComplexNameFromId(dU.DataTypeIdx)
         %else
           %assign dtype = LibGetDataTypeNameFromId(dU.DataTypeIdx)
         %endif
         %<dtype> mr_nonContSig%<arrayIdx>[%<dU.RegionLen>];
         %assign arrayIdx = arrayIdx + 1
       %endif
     %endforeach
   } \
   %closefile declBuf
   %return declBuf
%endfunction


%% Function: CPPEncapNeedsLocalVars ======================================
%% Abstract:
%%  Does C++ encapsulation interface needs to introduce local variables to
%%  model regestration function?

%function CPPEncapNeedsLocalVars(genERTSfcn) void
   %assign hasDWork = ! SLibModelDWorkStructIsEmpty()
   %assign dworkZeroed = TLC_FALSE
   
   %if hasDWork && (!(ForceBlockIOInitOptimize && IsModelReferenceTarget()))
      %assign dworkZeroed = SLibZeroMemory("DWork")
   %endif
   
   %if hasDWork && genERTSfcn
      %% SIL requires DWork (if existing) to be Zeroed regardless user setting.
      %% See the callsite to SLibDumpERTAndModelrefInitMemoryCode in ertsfcnbody.tlc
      %assign dworkZeroed = TLC_TRUE
   %endif
   
   %return GenerateClassInterface && ...
           ConfigSet.UseOperatorNewForModelRefRegistration && ...
           dworkZeroed
%endfunction %% CPPEncapNeedsLocalVars


%% Function: SLibGetCPPEncapInitLocalVars ================================
%% Abstract:
%%  Determine what local variables will be needed for cpp encapsulation
%%  in the model initialization function; must be guarded by 
%%  CPPEncapNeedsLocalVars

%function SLibGetCPPEncapInitLocalVars(genERTSFcn) void
  %assert CPPEncapNeedsLocalVars(genERTSFcn)
  
  %assign localVars = ""
  
  %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
    ::CompiledModel.ModelReferenceBlocks : []
  
  
  %if !ISEMPTY(mdlRefBlks)
    %assign NO_PARENT        = ""
    %assign NO_QUALIFIER     = ""
    %assign ERT_MACRO_NONE   = [0, 0, 0, 0]
    
    %foreach rowIdx = SIZE(mdlRefBlks,0)
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx = mdlRefInfo[0]
      %assign bIdx    = mdlRefInfo[1]
      %assign instIdx = mdlRefInfo[2]
      %assign blk     = ::CompiledModel.System[mSysIdx].Block[bIdx]
      %assert 0 == blk.DeletedInIR
    
      %if !blk.MdlRefIsCPPClassGenMode
         %continue
      %endif
      
      %assign blkInterface = GetModelrefInterface(blk)
      
      %if blkInterface.IsScalableBuild || IsSystemReusableParentBaseSys(mSysIdx)
            %continue
      %endif
      
      %assign locVarName = "local_" + ::CompiledModel.ModelBlock[rowIdx].MdlRefInstanceVarName
      %assign mdlBlkCompiledModel = ::CompiledModel.ModelBlock[rowIdx]
      %assign optDim = ""
      %if ISFIELD(mdlBlkCompiledModel, "ForEachSSLoopBnds")
          %assign tmpLevel = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
          %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
            %assign tmpLevel = tmpLevel - 1
            %assign optDim = optDim + "[%<mdlBlkCompiledModel.ForEachSSLoopBnds[tmpLevel]>]"
          %endforeach
      %endif
                                            
      %openfile tmpBuf
         %assign namespaceStr = ""
         %if EXISTS(blkInterface.FPC.ClassNamespace) && (!ISEMPTY(blkInterface.FPC.ClassNamespace))
           %assign namespaceStr = "%<blkInterface.FPC.ClassNamespace>::"
         %endif
         
         %if ISEMPTY(optDim)
           %<namespaceStr>%<blkInterface.FPC.ModelClassName>_ptr %<locVarName>;
         %else
           %<namespaceStr>%<blkInterface.FPC.ModelClassName>_ptr %<locVarName>%<optDim>;
         %endif
      %closefile tmpBuf
      
      %assign localVars = localVars + tmpBuf
    %endforeach
  %endif
  
  %return localVars
  
%endfunction %% SLibGetCPPEncapInitLocalVars


%% Function:  SLibGetCPPEncapInitCopyCode================================
%% Abstract:
%%  Determine the code needed to copy the referenced model object pointers so that
%%  later we can restore them after the DWork has been Zeroed, in the model initialization function; 
%%  It must be guarded by CPPEncapNeedsLocalVars. The argument is a boolean flag to indicate that it
%%  is a back up operation or a restore operation.
%function SLibGetCPPEncapInitCopyCode(isBackup, genERTSfcn) void
  %assert CPPEncapNeedsLocalVars(genERTSfcn)
  
  %assign copyCode = ""
  
  %assign mdlRefBlks = ISFIELD(::CompiledModel,"ModelReferenceBlocks") ? ...
    ::CompiledModel.ModelReferenceBlocks : []
  
  
  %if !ISEMPTY(mdlRefBlks)
    %assign NO_PARENT        = ""
    %assign NO_QUALIFIER     = ""
    %assign ERT_MACRO_NONE   = [0, 0, 0, 0]
    
    %foreach rowIdx = SIZE(mdlRefBlks,0)
      %assign mdlRefInfo = mdlRefBlks[rowIdx]
      %assign mSysIdx = mdlRefInfo[0]
      %assign bIdx    = mdlRefInfo[1]
      %assign instIdx = mdlRefInfo[2]
      %assign blk     = ::CompiledModel.System[mSysIdx].Block[bIdx]
      %assert 0 == blk.DeletedInIR
      
      %if !blk.MdlRefIsCPPClassGenMode
         %continue
      %endif
      
      %assign blkInterface = GetModelrefInterface(blk)
     
      %if blkInterface.IsScalableBuild || IsSystemReusableParentBaseSys(mSysIdx)
            %continue
      %endif
      
      %assign locVarName = "local_" + ::CompiledModel.ModelBlock[rowIdx].MdlRefInstanceVarName

      %assign mdlBlkCompiledModel = ::CompiledModel.ModelBlock[rowIdx]


      %openfile tmpBuf
        %if !ISFIELD(mdlBlkCompiledModel, "ForEachSSLoopBnds")
          %assign cppVarPath = SLibCalcMdlRefObjSubsysAccessPath(mSysIdx,...
                                bIdx,instIdx,"Registration")
          %if isBackup
            %<locVarName> = %<cppVarPath>;
          %else
            %<cppVarPath> = %<locVarName>;
          %endif
        %else
          %assign ::NeedForEachLoopInReg = TLC_TRUE
          %assign ::NumForEachLoopHierarchyLevel = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
          %assign ::ForEachLoopHierarchyLevel = ::NumForEachLoopHierarchyLevel
          %assign copySrcVarForEachSS = locVarName

          {
            %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
              %assign iterVar = "i_%<ForEachLoopHierarchyLevel>"
              %assign ::ForEachLoopHierarchyLevel = ::ForEachLoopHierarchyLevel - 1
              %assign copySrcVarForEachSS = copySrcVarForEachSS + "[%<iterVar>]" 
              int32_T %<iterVar>;
              for (%<iterVar> = 0; %<iterVar> < %<mdlBlkCompiledModel.ForEachSSLoopBnds[::ForEachLoopHierarchyLevel]>; %<iterVar>++) {
            %endforeach
            %assign ::ForEachLoopHierarchyLevel = 1
            %assign cppVarPath = SLibCalcMdlRefObjSubsysAccessPath(mSysIdx,...
                                bIdx,instIdx,"Registration")
            %if isBackup
              %<copySrcVarForEachSS> = %<cppVarPath>;
            %else
              %<cppVarPath> = %<copySrcVarForEachSS>;
            %endif
            %assign ::ForEachLoopHierarchyLevel = 1
            
            %foreach ssIdx = SIZE(mdlBlkCompiledModel.ForEachSSLoopBnds,1)
                   }
            %endforeach
            }
            %assign ::NeedForEachLoopInReg = TLC_FALSE
        %endif
      %closefile tmpBuf

      %assign copyCode = copyCode + tmpBuf
    %endforeach
  %endif
  
  %return copyCode
  
%endfunction %% SLibGetCPPEncapInitCopyCode

%% Function: SLibCPPDotOrArrowAccessOperator ======================================
%% Abstract:
%%  Which access operator, "." or "->", to use when calling member functions on
%%  encapsulated model reference C++ objects.
%function SLibCPPDotOrArrowAccessOperator(blk, blkInterface) void
  %assert GenerateClassInterface
  %assert blk.MdlRefIsCPPClassGenMode
  
  %assign accOperator = ((!blkInterface.IsScalableBuild) && ...
                         ConfigSet.UseOperatorNewForModelRefRegistration) ? ...
                            "->" : "."
                          
  %return accOperator
%endfunction %% SLibCPPDotOrArrowAccessOperator


%% Function RegisterMdlRefSFcnToWksDataTypes ======================================
%% Abstract:
%%   Generate the S-Function code to register enum and fixed point data types used
%%   by workspace logging in the mdlInitializeSizes function.
%%
%function RegisterMdlRefSFcnToWksDataTypes() Output

  %% ToWks logging in Dataset format is only supported currently for modelref sim
  %% targets.
  %if (!IsModelReferenceSimTarget())
    %return
  %endif

  %% See if there are any logged non-builtin types to register
  %if !EXISTS(::CompiledModel.DataTypes.NonBuiltinLoggingTypes) || ...
      SIZE(::CompiledModel.DataTypes.NonBuiltinLoggingTypes, 1) < 1
    %return
  %endif

  /* Workspace Logging Data Type Registration */
  %foreach idx = SIZE(::CompiledModel.DataTypes.NonBuiltinLoggingTypes, 1)
    {
      DTypeId dtId = INVALID_DTYPE_ID;
      %assign dID = ::CompiledModel.DataTypes.NonBuiltinLoggingTypes[idx]
      
      %% ENUM data types
      %if LibIsEnumDataType(dID)
        %assign dtName = LibGetDataTypeNameFromId(dID)
        ssRegisterTypeFromNamedObject(mdlRefSfcnS, "%<dtName>", &dtId);
        
      %% FIXED POINT data types
      %elseif LibIsDataTypeFixpt(dID)
        %assign curDT = FixPt_GetDataTypeFromIndex(dID)
        
        %if FixPt_DataTypeIsFloat(curDT)
          dtId = ssRegisterDataTypeFxpScaledDouble( \
            mdlRefSfcnS, \
            %<curDT.IsSigned>, \
            %<curDT.RequiredBits>, \
            (double)%<curDT.FracSlope>, \
            %<curDT.FixedExp>, \
            (double)%<curDT.Bias>, \
            0);
          %else
            dtId = ssRegisterDataTypeFxpFSlopeFixExpBias( \
              mdlRefSfcnS, \
              %<curDT.IsSigned>, \
              %<curDT.RequiredBits>, \
              (double)%<curDT.FracSlope>, \
              %<curDT.FixedExp>, \
              (double)%<curDT.Bias>, \
              0);
          %endif
       
        %% BUS data types
        %elseif LibDataTypeIsBus(dID)
          %assign dtName = LibGetDataTypeNameFromId(dID)
          ssRegisterTypeFromNamedObject(mdlRefSfcnS, "%<dtName>", &dtId);
        
        %% UNKNOWN types
        %else
          %assign errTxt = ...
            "User-defined data types not supported for model reference simulation logging."
          %<LibReportFatalError(errTxt)>
        %endif
            
        if(dtId == INVALID_DTYPE_ID) {
          return;
        }
      }
    %endforeach
%endfunction %% RegisterMdlRefSFcnToWksDataTypes


%function SLibUsePortBasedSampleTime() void
  %return (::CompiledModel.UsePortBasedSampleTime == "yes")
%endfunction


%function GetConstantOutputSignalConditioning()
  %assign hasConstOutput = MdlRefHasConstantOutput()
  %openfile codeBuf1
  %if hasConstOutput
    if (%<::CompiledModel.GlobalScope.tTID> == CONSTANT_TID) {
      %assert (NumModelOutputs > 0)
      %<GenerateConstOutputSignalConditioning(::CompiledModel.RollThreshold)>
    }
  %endif
  %closefile codeBuf1
  %return codeBuf1
%endfunction
%% EOF modelrefsfcnlib.tlc
