%% 
%% 
%% 
%%
%% Copyright 1994-2017 The MathWorks, Inc.
%%
%% Abstract:
%%      Library to support the notion of an RTModel object
%%

%if EXISTS("_RTMDLLIB_") == 0
%assign _RTMDLLIB_ = 1

%include "rtmspecmacs.tlc"
%include "rtmisreqfcns.tlc"
%include "rtmdllib_obs.tlc"

%%------------------------------------------------------------------------------
%% RTM record creation SECTION:
%%------------------------------------------------------------------------------
%%  Has support for creating a TLC records that:
%%  - know about the data fields in an rtModel
%%  - know about special inline operations to rtModel data fields
%%------------------------------------------------------------------------------

%% Function: DocFunction{Other Useful Functions} LibGetSimStruct ===============
%% Abstract:
%%   Returns the model SimStruct or SimStruct function argument name
%%
%function LibGetSimStruct() void
  %return SLibCG_GetRTMArgumentName()
%endfunction

%% Function: SLibGetSimStruct ==================================================
%% Abstract:
%%   Returns the model SimStruct or SimStruct function argument
%%
%function SLibGetSimStruct() void
  %return SLibCG_GetRTMArgumentName()
%endfunction

%% Function: SLibGetSimStructAllocatedVarName
%% Abstract:
%%   Returns the allocated simstruct variable name. We should use this function
%%   only when it is single-instance case.
%%
%function SLibGetSimStructAllocatedVarName() void
  %assert IsModelRefScalableBuild() || !MultiInstanceERTCode
  %return "%<::tSimStruct>_"
%endfunction

%% Function: SLibGetSimStructReferenceVarName
%% Abstract:
%%   Returns the referenced simstruct variable name.
%%
%function SLibGetSimStructReferenceVarName() void
  %return ::tSimStruct
%endfunction


%% Function: RTMCreateRTModelRecShell ==========================================
%% Abstract:
%%   Create a shell to hold the rtModel records.
%%
%function RTMCreateRTModelRecShell() void
  %if !EXISTS(RootRTMdlRecs)
    %assign ::RootRTMdlRecNum = 1
    %createrecord ::RootRTMdlRecs {}
    %return 1
  %else
    %return 0
  %endif
%endfunction %% RTMCreateRTModelRecShell


%% Function: RTMGetRTModelRecShell =============================================
%% Abstract:
%%   Create a shell to hold the rtModel records.
%%
%function RTMGetRTModelRecShell() void
  %return ::RootRTMdlRecs
%endfunction %% RTMGetRTModelRecShell


%% Function: SLibRTModelNeedsZCTypes ==================================================
%% Abstract:
%%   It is possible that the real-time model uses the ZCSigState type even if
%%   this type is not required by the rest of the model. 
%%
%function SLibRTModelNeedsZCTypes() void

  %assign needZCTypes = TLC_FALSE
  %if EXISTS(::RootRTMdlRecs)
    %assign rtRecs = RTMGetRTModelRecShell()
    %assign needZCTypes = %<rtRecs.ZCSignalValues.IsRequiredFcn>
  %endif
  %return needZCTypes
  
%endfunction


%% Function: FcnNeedRTMInMacroArg =============================================
%% Abstract:
%%   Does the macro need the rtModel in the argment list?  In certain cases
%%   when using the global timing engine for model reference, we do not
%%   need the rtModel in the argument list.
%function FcnNeedRTMInMacroArg(theRec)
  %assert ((theRec.UseRTModelForMR >= 0) && (theRec.UseRTModelForMR < 4))
  %if !IsModelReferenceTarget() || ...
    (theRec.UseRTModelForMR == 2) || ...
    ((theRec.UseRTModelForMR == 1) && IsModelReferenceForASimstructBasedTarget()) || ...
    ((theRec.UseRTModelForMR == 3) && !SuppressErrorStatus)
    %return TLC_TRUE
  %else
    %return TLC_FALSE
  %endif
%endfunction %%FcnNeedRTMInMacroArg


%% Function: FcnRTMCreateBaseRec ===============================================
%% Abstract:
%%   Creates a base data record for the rtModel. 
%%
%%   The record contains information such as:
%%   name of variable in rtModel struct, place in the rtModel hierarchy for
%%   the field, the datatype, data qualifier, and whether or not the
%%   field is required to be present unconditionally in the rtModel.
%%   
%%   In addition to all of the above information, the record also has 
%%   information on whether or not it needs a specialized macro for 
%%   forwarding accesses to SimStructs of child S-functions to the rtModel.
%%   Such macros are necessary because in the era of the root SimStruct,
%%   child S-functions would sometimes reach into the root SimStruct for
%%   the information (e.g. ssGetT). Such accesses need to now be forwarded
%%   to the rtModel.
%% 
%function FcnRTMCreateBaseRec(rtRec, rName, vName, parent, dType, qual, ...
  ertMac, isReqFcn) void
  
  %addtorecord rtRec ...
  %<rName> {                       \
    RecType       "Variable";      \
    VarRecNumber  RootRTMdlRecNum; \
    VarName       vName;           \
    Parent        parent;          \
    DataType      dType;           \
    Qualifier     qual;            \
    ERTMacro      ertMac;          \
    StorageType   "";              \
    ArrayDims     [];              \
    IsRequiredFcn isReqFcn;        \
    NumSet        0;               \
    NumGet        0;               \
    TypeStr       ""               \
  }
  
  %assign ::RootRTMdlRecNum = RootRTMdlRecNum + 1
  
%endfunction %% FcnRTMCreateBaseRec


%% Function: RTMAddRecSclr =====================================================
%% Abstract:
%%   Creates a scalar data record for the rtModel
%% 
%function RTMAddRecSclr(rName, vName, parent, dType, qual, ertMac, ...
  isReqFcn) void
  %if qual != "" && qual != "CONST"
    %assign errTxt = "%<qual> is not a valid Qualifier for record '%<rName>'"...
      " in the rtModel object"
    %<LibReportError(errTxt)>
  %endif
  %assign rtRec = RTMGetRTModelRecShell()
  %<FcnRTMCreateBaseRec(rtRec,rName,vName,parent,dType,qual,ertMac,isReqFcn)>
  %assign rtRec.%<rName>.StorageType = "SCALAR"
%endfunction %% RTMAddRecSclr


%% Function: RTMAddRecPntr =====================================================
%% Abstract:
%%   Creates a pointer data record for the rtModel
%% 
%function RTMAddRecPntr(rName, vName, parent, dType, qual, ertMac, isReqFcn) void 
  %assign rtRec = RTMGetRTModelRecShell()
  %<FcnRTMCreateBaseRec(rtRec,rName,vName,parent,dType,qual,ertMac,isReqFcn)>
  %assign rtRec.%<rName>.StorageType = "POINTER"
%endfunction %% RTMAddRecPntr

%% Function: RTMAddRecVolatilePntr =====================================================
%% Abstract:
%%   Creates a pointer data record for the rtModel
%% 
%function RTMAddRecVolatilePntr(rName, vName, parent, dType, qual, ertMac, ...
  isReqFcn) void
  %assign rtRec = RTMGetRTModelRecShell()
  %<FcnRTMCreateBaseRec(rtRec,rName,vName,parent,dType,qual,ertMac,isReqFcn)>
  %assign rtRec.%<rName>.StorageType = "VOLATILEPOINTER"
%endfunction %% RTMAddRecPntr

%% Function: RTMAddRecPntrPntr =================================================
%% Abstract:
%%   Creates a pointer pointer data record for the rtModel
%% 
%function RTMAddRecPntrPntr(rName, vName, parent, dType, qual, ertMac, ...
  isReqFcn) void
  %assign rtRec = RTMGetRTModelRecShell()
  %<FcnRTMCreateBaseRec(rtRec,rName,vName,parent,dType,qual,ertMac,isReqFcn)>
  %assign rtRec.%<rName>.StorageType = "POINTERPOINTER"
%endfunction %% RTMAddRecPntrPntr

%% Function: RTMAddRecArry ======================================================
%% Abstract:
%%   Creates an array data record for the rtModel
%% 
%function RTMAddRecArry(rName, vName, parent, dType, qual, ertMac, ...
  dims, isReqFcn) void
  %if qual != "" && qual != "CONST"
    %assign errTxt = "%<qual> is not a valid Qualifier for record '%<rName>'"...
      " in the rtModel object"
    %<LibReportError(errTxt)>
  %endif
  %assign rtRec = RTMGetRTModelRecShell()
  
  %<FcnRTMCreateBaseRec(rtRec,rName,vName,parent,dType,qual,ertMac,isReqFcn)>
  %assign rtRec.%<rName>.StorageType = "ARRAY"
  %assign rtRec.%<rName>.ArrayDims   = dims
%endfunction %% RTMAddRecArry


%% Function: RTMAddRecIdxedAccs ================================================
%% Abstract:
%%   Add a record that indicates how to generated an indexed inline access of
%%   a vector rtModel field.
%%
%%   The record contains information such as:
%%   - name of variable in rtModel struct that is being accessed
%%   - information on whether or not we need to generate a macro for the
%%     given field into the rtmodel.h file. The macro will be of the form
%%     rtmGetSampleTime. It is used by files in the rtw/c/src directory.
%%     (The reason we use macros in  rtw/c/src/ is that these files retain the
%%      ability to run based on the root SimStruct instead of the rtModel. 
%%      If we are using the root SimStruct, the rtm macros automatically
%%      get mapped to macros for the root SimStruct).
%%   - information on whether or not it needs a specialized macro for 
%%     forwarding accesses to SimStructs of child S-functions to the rtModel.
%% 
%function RTMAddRecIdxedAccs(rName, accessedRec) void
  %assign rtRec    = RTMGetRTModelRecShell()
  
  %createrecord \
  %<rName> {                      \
    RecType       "IndexedAccess";\
    AccessedRec   accessedRec;    \
    NumGet        0;              \
    NumSet        0               \
  }
  
  %assign rtRec = rtRec + %<rName>
%endfunction %% RTMAddRecIdxedAccs


%% Function: RTMAddRecSpecialAccs ==============================================
%% Abstract:
%%   Add a record that indicates how to generated an special inline access of
%%   a vector rtModel field.
%%
%%   The record contains information such as:
%%   - names of the fields in rtModel struct that are being accessed
%%   - other args used in the access
%%   - the specific access method to call in the case of a 'set', 'get',
%%     or 'is' access. 
%%   - information on whether or not we need to generate a macro for the
%%     given field into the rtmodel.h file. 
%%   - information on whether or not it needs a specialized macro for 
%%     forwarding accesses to SimStructs of child S-functions to the rtModel.
%%   - For the modelreference target with GlobalTimingEngine, the field
%%     UseRTModelForMR specifies whether the macros have rtModel in the argument
%%     list.  The argument useTimingBridge specifies if any of the set, get
%%     or is functions need the timing bridge.  These have no effect for 
%%     non-model reference targets.
%% 
%function RTMAddRecSpecialAccs(rName, getFcn, setFcn, isFcn, oFcn, sva, ...
  nArgs, args, useTimingBridge, useRTModelForMR, ertMac) void

  %assign rtRec    = RTMGetRTModelRecShell()
  
  %createrecord \
  %<rName> {                           \
    RecType          "SpecialAccess";  \
    ERTMacro         ertMac;           \
    GetFcn           getFcn;           \
    SetFcn           setFcn;           \
    IsFcn            isFcn;            \
    OtherFcn         oFcn;             \
    SetHasValArg     sva;              \
    NumArgs          nArgs;            \
    Args             args;             \
    NumGet           0;                \
    NumSet           0;                \
    UseTimingBridge  useTimingBridge   \
    UseRTModelForMR  useRTModelForMR;  \
    Name             rName             \
  }
  
  %assign rtRec = rtRec + %<rName>
%endfunction %% RTMAddRecSpecialAccs


%% Function: RTMAddRecDummy ====================================================
%% Abstract:
%%   Add a dummy record that forwards old SimStruct accesses to never-never
%%   land
%% 
%function RTMAddRecDummy(rName) void
  %assign rtRec = RTMGetRTModelRecShell()

  %createrecord \
  %<rName> {                     \
    RecType       "Dummy"        \
  }
  
  %assign rtRec = rtRec + %<rName>
%endfunction %% RTMAddRecDummy


%%------------------------------------------------------------------------------
%% RTM access SECTION:
%%------------------------------------------------------------------------------
%% This section is devoted to methods that are called from all over the TLC code
%% to access a field of the RTModel. The appropriate access is generated from
%% the information in the corresponding TLC record for the RTModel.
%%------------------------------------------------------------------------------


%% Function: FcnRTMGenErr ======================================================
%% Abstract:
%%   Generate an RTM Error
%% 
%function FcnRTMGenErr(errKey, recName) void
  %switch(errKey)
    %case "ACCESSREC_NOT_FOUND"
      %assign errTxt = "RT_MODEL record %<recName> does not have a matching "...
	"access record"
      %break
    %case "RECTYPE_NOT_FOUND"
      %assign errTxt = "RT_MODEL record %<recName> has unknown RecType"
      %break
    %case "FIELD_NOT_FOUND"
      %assign errTxt = "RT_MODEL record %<recName> not found"
      %break
    %case "WRONGTYPE"
      %assign errTxt = "RT_MODEL record %<recName> processed using " ...
	"incorrect TLC function"
      %break
    %case "BADSPECIALACCS"
      %assign errTxt = "RT_MODEL record %<recName> accessed with " ...
	"incorrect special access"
      %break
    %default
      %assign errTxt = "Unknown error occurred in RT_MODEL generation"
      %break
  %endswitch
  %<LibReportError(errTxt)>
%endfunction

%function getRTMFieldPointerFromCGType(dataType,varIndex)
  %assign elem = ""
  %switch (dataType)
    %case "PARAMETER"
      %assign varGroupIdx = ...
        FcnSysVarGroupIndex(System[GetBaseSystemIdx()], "Parameter", 0)
      %assign elem = "RVG" + STRING(varGroupIdx)
      %break
    %case "BLOCKIO"
      %assign varGroupIdx = ...
        FcnSysVarGroupIndex(System[GetBaseSystemIdx()], "BlockIO", 0)
      %if SLibGetUseRTMcgType()
        %assign elem = "VG" + STRING(varGroupIdx)
      %else
        %assign elem = "RVG" + STRING(varGroupIdx)
      %endif
      %break
    %case "DWORK"        
      %assign varGroupIdx = ...
        FcnSysVarGroupIndex(System[GetBaseSystemIdx()], "DWork", 0)
      %if SLibGetUseRTMcgType()
        %assign elem = "VG" + STRING(varGroupIdx)
      %else
        %assign elem = "RVG" + STRING(varGroupIdx)
      %endif
      %break
    %case "STANDALONE"
      %% Accessed as individual variables
      %assert varIndex >= 0
      %assign elem = varIndex
      %break
    %case "ZC_SIG_STATE"
      %assign varGroupIdx = ...
        FcnSysVarGroupIndex(System[GetBaseSystemIdx()], "ZCEvent", 0)
      %if SLibGetUseRTMcgType()
        %assign elem = "VG" + STRING(varGroupIdx)
      %else
        %assign elem = "RVG" + STRING(varGroupIdx)
      %endif
      %break
    %default
      %break
  %endswitch
  %if !ISEMPTY(elem)
    %return SLibGetFieldPointerFromSelf(elem,TLC_FALSE)
  %else
    %return ""
  %endif
%endfunction

%% Function: FcnGenFieldAccessString ===========================================
%% Abstract: 
%%   Generates a string for the access of a plain field
%%
%function FcnGenFieldAccessString(theRec,forGetOrSet,optIdx,optSetVal,...
  rtmName) void
  %assign retStr = ""
  %if FcnRTMFieldIsRequired(theRec)
    %<SLibCG_AccessRTM()>
    %assign parent    = theRec.Parent
    %assign parentStr = (parent == "") ? "" : "%<parent>."
    %assign derefStr  = "->"
    %assign retStr    = "%<rtmName>%<derefStr>%<parentStr>%<theRec.VarName>"
  %elseif (SLibGetUseRTMcgType())
    %assign retStr = getRTMFieldPointerFromCGType(theRec.DataType,-1)
  %endif
  %if !ISEMPTY(retStr)
    %assign idxStr    = (optIdx == "") ? "" : "[%<optIdx>]"
    %assign retStr    = retStr + idxStr
    %if forGetOrSet == "set"
      %assign retStr = retStr + " = (%<optSetVal>)"
    %endif
  %endif
  %return retStr
%endfunction %% FcnGenFieldAccessString


%% Function: FcnUpdateRecUsage =================================================
%% Abstract:
%%   Update the usage info for a record
%% 
%function FcnUpdateRecUsage(theRec, accessType) void
  %switch (accessType)
    %case "get"
      %assign theRec.NumGet = theRec.NumGet + 1
      %break
    %case "is"
    %case "set"
      %assign theRec.NumSet = theRec.NumSet + 1      
      %break
  %endswitch
%endfunction %% FcnUpdateRecUsage

%% Function: getReusedParentSystem =====================================
%% Abstract:
%%   Helper method to get the correct parent reused system for accessing rtmodel
%% 
%function getReusedParentSystem(system)
  %if ISFIELD(system,"RTWSystemCodeOptIntf") || LibIsServer(system)
    %% Consider only public servers, because utility functions are inlined.
    %assign reusedParentSys = System[system.HStructDeclSystemIdx]
  %else
    %assign reusedParentSys = System[system.ReusedParentSystemIdx]
  %endif
  %if LibIsServer(reusedParentSys)
    %assert reusedParentSys.SystemIdx != system.SystemIdx
    %return getReusedParentSystem(reusedParentSys)
  %else
    %return reusedParentSys
  %endif
%endfunction

%% Function: FcnUpdateRTModelInterfaceArg =====================================
%% Abstract:
%%   Update the interface for a system to include the rtModel.
%% 
%function FcnUpdateRTModelInterfaceArg(system, rtmName) void
  %% We now put the rtModel as an argument in all reusable functions
  %% if it is used.  Previously we only did this for MultiInstanceERTCode.
  %% Guard this with (MultiInstanceERTCode || GenerateSFunction) to get the
  %% old behavior
  %<SLibCG_AccessRTM()>
  %assign outRTMName = rtmName
  %if ::BlockFcn != "Unknown"
    %% We may pass in the HStructDeclSystem when calling this
    %% function, but we want to know the actual system that the
    %% caller lives in.  We can get this information if SystemIdx
    %% is in scope.
    %if EXISTS(SystemIdx)
      %assign ownersys = System[SystemIdx]
    %else
      %assign ownersys = system
    %endif
    %assign accessTid = ownersys.CurrentTID
    %assign reusedParentSys = getReusedParentSystem(ownersys)

    %% Single-instance and non-inlined Simulink Functions in referenced models,
    %% access the rtModel directly from the global DWork variable.    
    %assign modIdx = system.CGIRModuleIdx
    %assign module = ::CompiledModel.RTWCGModules.RTWCGModule[modIdx]

    %if module.SimplifiedInterface && !GenerateClassInterface
      %assign outRTMName = LibGetSimStruct()
    %elseif ownersys.CrossNoArgFcnBound
      %<SLibAccessArgHelper(reusedParentSys.Interface.RTMArgDef, "Global",accessTid)>
      
      %% For Simulink Functions, we need to initialize the rtmodel in the start function
      %if LibIsServer(ownersys)
        %assign interf = System[GetBaseSystemIdx()].Interface
        
        %<SLibAccessThisSysFcnArgHelper(interf.RTMArgDef, "Start", "Global", "", TLC_TRUE)>
        %<SLibAccessArg(interf.RTMArgDef, "Start", 0, 0)>
        
        %% Mark this system as accessing canonical parmeters so it is always generated
        %assign interf.CacheCanonicalPrmInStart = TLC_TRUE
      %endif
      %if (UsingMalloc || (MultiInstanceERTCode && !GenerateClassInterface)) && !ISFIELD(reusedParentSys.Interface, "tsysRTM")
        %addtorecord reusedParentSys.Interface tsysRTM ::tSimStruct
      %endif
      %if !(IsModelReferenceSimTarget() && LibIsServer(ownersys) && SLibIsModelScopedServer(ownersys))
        %assign outRTMName = reusedParentSys.Interface.tsysRTM
      %else
        %assign outRTMName = "(&" + FcnGetSFcnDWorkIdentifier(System[GetBaseSystemIdx()]) + ".rtm)"
      %endif
    %endif
    %<SLibAccessArgHelper(reusedParentSys.Interface.RTMArgDef,"",accessTid)>
  %endif
  
  %if SLibGetDoesSelfHasCoderDataGroup() && SLibIsSelfStructured() && !SLibCanInlineRTMIntoSelf()
    %assign selfCoderGroupArgumentName = SLibGetSelfCoderGroupArgumentName()
    %if !ISEMPTY(selfCoderGroupArgumentName) && (selfCoderGroupArgumentName == outRTMName)
      %assign fieldname = SLibGetRTMPointerVariableNameInsideSelfStructure()
        %if !ISEMPTY(fieldname)
          %assign outRTMName = outRTMName + "->" + SLibGetRTMPointerVariableNameInsideSelfStructure()
        %endif
    %endif
  %endif
 
  %%
  %% Added for ert_main.cpp generation when GenerateClassInterface is selected
  %%
  %if GenerateClassInterface && ERTMainAccess == TLC_TRUE
    %assign outRTMName = "%<CPPObjectName>." + outRTMName
  %endif
  %return outRTMName
%endfunction %% FcnUpdateRTModelInterfaceArg

%% Function: FcnGenPlainAccess =================================================
%% Abstract:
%%   Generate a plain access to an data field in the rtModel.
%%
%function FcnGenPlainAccess(system, recordName, fcnGetOrSet, optIdx, ...
  optSetVal, rtmName) void
  
  %assign rtRecs = RTMGetRTModelRecShell()
  %assign retStr = "ACCESS_ERROR" %% assume
  %assign theRec = rtRecs.%<recordName>

  %% Update the rtModel interface argument
  %assign rtmName = FcnUpdateRTModelInterfaceArg(system, rtmName)
  
  %%
  %% Error check to make sure the function is called for the appropriate
  %% record
  %%
  %if (theRec.RecType != "Variable")
    %<FcnRTMGenErr("WRONGTYPE", theRec)>
  %endif
  
  %%
  %% Increment access numbers
  %%
  %<FcnUpdateRecUsage(theRec, fcnGetOrSet)>
  
  %%
  %% Generate the actual access
  %%
  %assign retStr = FcnGenFieldAccessString(theRec,fcnGetOrSet,...
    optIdx, optSetVal, rtmName)
    
  %return retStr
%endfunction %% FcnGenPlainAccess


%% Function: FcnGenIndexedAccess ===============================================
%% Abstract:
%%   Generate an indexed access to an data field in the rtModel.
%%
%function FcnGenIndexedAccess(system, recordName, fcnGetOrSet, optIdx, ...
  optSetVal, rtmName) void
  %assign rtRecs = RTMGetRTModelRecShell()
  %assign theRec = rtRecs.%<recordName>

  %% Update the rtModel interface argument
  %assign rtmName = FcnUpdateRTModelInterfaceArg(system, rtmName)

  %%
  %% Error check to make sure the function is called for the appropriate
  %% record
  %%
  %if (theRec.RecType != "IndexedAccess")
    %<FcnRTMGenErr("WRONGTYPE", theRec)>
  %endif
  
  %%
  %% Increment access numbers
  %%
  %<FcnUpdateRecUsage(theRec, fcnGetOrSet)>
  
  %%
  %% Generate the actual access
  %%
  %assign refRec = rtRecs.%<theRec.AccessedRec>
  %assign retStr =  FcnGenFieldAccessString(refRec,fcnGetOrSet,...
    optIdx, optSetVal, rtmName)
  
  %return retStr
%endfunction %% FcnGenIndexedAccess


%% Function: FcnGenSpecialAccess ===============================================
%% Abstract:
%%   Generate a special access
%% 
%function FcnGenSpecialAccess(system, recordName, accessType, nArgs, args, ...
  optSetVal, rtmName) void
  
  %assign rtRecs = RTMGetRTModelRecShell()
  %assign theRec = rtRecs.%<recordName>
  %if SuppressErrorStatus && recordName == "ErrorStatus"
    %assign rtmName = "0"
  %endif
  %% Update the rtModel interface argument if it is being used in the macro
  %% This is not required for a deployment diagram, since there are not reusable
  %% functions generated for a deployment diagram, and the rtmName is given.
  %if !ISEQUAL(rtmName,"0") && FcnNeedRTMInMacroArg(theRec) && ...
    (!LibIsDeploymentDiagram()) && rtmName != "getRTM()"
    %assign rtmName = FcnUpdateRTModelInterfaceArg(system, rtmName)
  %endif

  %if GenerateClassInterface && EXISTS(::GeneratingMainFunction) &&...
    ::GeneratingMainFunction
    %%%if ::CPPObjectName == "this"
    %%    %assign rtmName = "this->getRTM()"
    %%%else
    
    %assign rtmName = "%<CPPObjectName>.getRTM()"
    
    %%%endif
    
    %%%assign rtmName = "getRTM()"
  %endif
    
  %%
  %% Error check to make sure the function is called for the appropriate
  %% record
  %%
  %if (theRec.RecType != "SpecialAccess")
    %<FcnRTMGenErr("WRONGTYPE", theRec)>
  %endif
  
  %%
  %% Increment access numbers
  %%
  %<FcnUpdateRecUsage(theRec, accessType)>  

  %%
  %% Update the global timing bridge accessed flag
  %if IsModelReferenceTarget()
    %assign accFlag = theRec.UseTimingBridge
    %assign needTimingBridge = TLC_FALSE
    %assign needGlobalTID = TLC_FALSE
    %switch accessType
      %case "get"
        %assign needTimingBridge = (accFlag[0] > 0)
        %assign needGlobalTID = (accFlag[0] > 1)
        %break
      %case "set"
        %assign needTimingBridge = (accFlag[1] > 0)
        %assign needGlobalTID = (accFlag[1] > 1)
        %break
      %case "is"
        %assign needTimingBridge = (accFlag[2] > 0)
        %assign needGlobalTID = (accFlag[2] > 1)
        %break
    %endswitch
    %if needTimingBridge
      %assign ::tMdlRefTimingBridgeAccessed = TLC_TRUE
    %endif
    %if needGlobalTID
      %assign ::tMdlRefGlobalTIDMapAccessed = TLC_TRUE
      %assign ::tMdlRefNeedTIDArgs = TLC_TRUE
    %endif
  %endif
  
  %%
  %% Get the name of the macro
  %%
  %assign accFcn = ""
  %switch accessType
    %case "is"
      %assign accFcn = "Is"
      %break
    %case "get"
      %assign accFcn = "Get"
      %break
    %case "set"
      %assign accFcn = "Set"
      %break
    %case "other"
      %assign accFcn = ""
      %break
  %endswitch
  
  %assign comma = ""
  %if FcnNeedRTMInMacroArg(theRec)
    %assign retStr = "rtm%<accFcn>%<recordName>(%<rtmName>"
    %assign comma = ", "
  %else
    %assign retStr = "rtm%<accFcn>%<recordName>("
  %endif

  %%
  %% Check that we have the correct number of other args
  %%
  %if theRec.NumArgs != nArgs
    %<FcnRTMGenErr("BADSPECIALACCS", theRec)>
  %endif
  
  %foreach argIdx = theRec.NumArgs
    %assign retStr  = retStr + comma
    %assign thisarg = args[argIdx]
    %assign retStr  = retStr + thisarg
    %assign comma = ", "
  %endforeach
  
  %if accessType == "set"
    %assign retStr = retStr + comma + optSetVal
  %endif
  
  %assign retStr = retStr + ")"

  %return retStr
%endfunction %% FcnGenSpecialAccess


%<LibAddToCompiledModel("RealTimeModelAccessed", 0)>

%% Function: RTMDispatchToAccessFcn ============================================
%% Abstract: 
%%   Dispatch to the appropriate access function 
%%
%function RTMsDispatchToAccessFcn(system, recordName, fcnGetOrSet, optIdx, ...
  optSetVal, rtmName) void
  
  %assign rtRecs = RTMGetRTModelRecShell()

  %if !ISFIELD(rtRecs, recordName)
    %<FcnRTMGenErr("FIELD_NOT_FOUND", recordName)>
  %endif
  
  %assign theRec = rtRecs.%<recordName>
  
  %switch (theRec.RecType)
    %case "Variable"
      %assign retStr = FcnGenPlainAccess(system, recordName, fcnGetOrSet, ...
        optIdx, optSetVal, rtmName)
      %break
    %case "IndexedAccess"
      %assign retStr = FcnGenIndexedAccess(system, recordName, fcnGetOrSet, ...
	optIdx, optSetVal, rtmName)
      %break
    %case "SpecialAccess"
      %if TYPE(optIdx) == "Vector"
        %assign nArgs = SIZE(optIdx,1)
      %else
        %assign nArgs = (optIdx == "") ? 0 : 1
      %endif
      %assign retStr = FcnGenSpecialAccess(system, recordName, fcnGetOrSet, ...
	nArgs, ["%<optIdx>"], optSetVal, rtmName)
      %break
    %case "Dummy"
    %default
      %% Do nothing
      %assign retStr = ""
      %break
  %endswitch
  
  %% Check if we are using a macro that does not need
  %% the RTMODEL in the argument list.  This is true for
  %%   - clockTick%<idx>
  %%   - clockTickH%<idx>
  %%   - taskTime
  %%   - T
  %%   - TPtr
  %%   - firstInitCond
  %%   - special sample hit
  %% This is specified in the field useRTModelForMR in the special
  %% access macro definition in rtmdldefs.tlc
  %if SuppressErrorStatus && recordName == "ErrorStatus"
    %% do nothing becuase Macro is NoOp
  %elseif !WHITE_SPACE(retStr) && ...
    (theRec.RecType != "SpecialAccess" || FcnNeedRTMInMacroArg(theRec))
    %assign ::CompiledModel.RealTimeModelAccessed = TLC_TRUE 
  %endif
  %return retStr
%endfunction


%% Function: RTMSet ============================================================
%% Abstract:
%%   Return code for doing a "set" on a field in the rtModel
%% 
%function RTMsSet(system, recordName, initVal) void
  
  %if GenRTModel
    %%
    %% Take care of the case where people may have given a TLC numeric index
    %%
    %if TYPE(initVal) != "String"
      %assign initVal = "%<initVal>"
    %endif
    
    %% %if !GenerateClassInterface
      %assign setStr = RTMsDispatchToAccessFcn(system, recordName, "set", "", ...
        initVal, GetSimStructExpr(system,GenerateClassInterface ? "getRTM()" : ::tSimStruct))
    %% %else
      %%%if ::CPPObjectName == "this"
      %%  %assign rtmAccessMethod = "this->getRTM()"
      %%%else
      %%  %assign rtmAccessMethod = "%<CPPObjectName>.getRTM()"
      %%%endif
    %%  %assign rtmAccessMethod = "getRTM()"
    %%  %assign setStr = RTMsDispatchToAccessFcn(system, recordName, "set", "", ...
    %%    initVal, rtmAccessMethod)
    %% %endif
  %else
    %assign setStr = "ssSet" + recordName + "(%<SLibGetSimStruct()>, %<initVal>)"
  %endif
  
  %return setStr
%endfunction %% RTMSet


%% Function: RTMuSet ===========================================================
%% Abstract:
%%   Return code for doing a "set" on a field in the rtModel. This function
%%   is different from RTMSet in that it appends an underscore in front
%%   of the SimStruct access. When we move to the actual rtModel, this 
%%   function can be obsoleted.
%% 
%function RTMsuSet(system, recordName, initVal) void
  %assign setStr = RTMsSet(system, recordName, initVal)
  %if !GenRTModel
    %assign setStr = "_%<setStr>"
  %endif
  %return setStr
%endfunction %% RTMuSet


%% Function: RTMSetIdxed =======================================================
%% Abstract:
%%   Return code for doing a "set" on a field in the rtModel. This function
%%   is used when an indexing variable is also specified.
%% 
%function RTMsSetIdxed(system, recordName, fldIdx, initVal) void
  %if GenRTModel
    %%
    %% Take care of the case where people may have given a TLC numeric index
    %%
    %if TYPE(fldIdx) != "String"
      %assign fldIdx = "%<fldIdx>"
    %endif
    %%
    %% Take care of the case where people may have given a TLC numeric index
    %%
    %if TYPE(initVal) != "String"
      %assign initVal = "%<initVal>"
    %endif
    
    %assign setStr = RTMsDispatchToAccessFcn(system, recordName, "set", fldIdx, ...
      initVal, GetSimStructExpr(system, ::tSimStruct))
  %else
    %assign setStr = "ssSet" + recordName + "(%<SLibGetSimStruct()>, " ...
      "%<fldIdx>, %<initVal>)"
  %endif
  %return setStr
%endfunction %% RTMSetIdxed


%% Function: RTMuSetIdxed =======================================================
%% Abstract:
%%   Return code for doing a "set" on a field in the rtModel. This function
%%   is different from RTMSet in that it appends an underscore in front
%%   of the SimStruct access. When we move to the actual rtModel, this 
%%   function can be obsoleted.
%% 
%function RTMsuSetIdxed(system, recordName, fldIdx, initVal) void
  %assign setStr = RTMsSetIdxed(system, recordName, fldIdx, initVal)
  %if !GenRTModel
    %assign setStr = "_%<setStr>"
  %endif
  %return setStr
%endfunction %% RTMuSetIdxed


%% Function: RTMGet ============================================================
%% Abstract:
%%   Return code for doing a "get" on a field in the rtModel
%% 
%function RTMsGet(system, recordName) void
  %if GenRTModel
    %assign fldStr = RTMsDispatchToAccessFcn(system, recordName,"get","","",GetSimStructExpr(system, ::tSimStruct))
    %assign getStr = "%<fldStr>"
  %else
    %assign getStr = "ssGet" + recordName + "(%<SLibGetSimStruct()>)"
  %endif
  %return getStr
%endfunction %% RTMGet


%% Function: RTMuGet ===========================================================
%% Abstract:
%%   Return code for doing a "get" on a field in the rtModel. This function
%%   is different from RTMGet in that it appends an underscore in front
%%   of the SimStruct access. When we move to the actual rtModel, this 
%%   function can be obsoleted.
%% 
%function RTMsuGet(system, recordName) void
  %assign getStr = RTMsGet(system, recordName)
  %if !GenRTModel
    %assign getStr = "_%<getStr>"
  %endif
  %return getStr
%endfunction %% RTMuGet


%% Function: RTMGetIdxed =======================================================
%% Abstract:
%%   Return code for doing a "get" on a field in the rtModel. This function
%%   is used when an indexing variable is also specified.
%% 
%function RTMsGetIdxed(system, recordName, fldIdx) void
  %if GenRTModel
    %%
    %% Take care of the case where people may have given a TLC numeric index
    %%
    %if TYPE(fldIdx) != "String"
      %assign fldIdx = "%<fldIdx>"
    %endif
    
    %assign fldStr = RTMsDispatchToAccessFcn(system, recordName, "get", fldIdx, ...
      "", GetSimStructExpr(system, ::tSimStruct))
    %assign getStr = "%<fldStr>"
  %else
    %assign getStr = "ssGet" + recordName + "(%<SLibGetSimStruct()>, %<fldIdx>)"
  %endif
  
  %return getStr
%endfunction %% RTMGetIdxed


%% Function: RTMIs =============================================================
%% Abstract:
%%   Return code for doing a "is" on a field in the rtModel
%% 
%function RTMsIs(system, recordName) void
  %if GenRTModel
    %assign isStr = FcnGenSpecialAccess(system, recordName, "is", 0, ...
      [], "", GetSimStructExpr(system, ::tSimStruct))
  %else
    %assign isStr = "ssIs" + recordName + "(%<SLibGetSimStruct()>)"
  %endif
  %return isStr
%endfunction %% RTMIs

%% Function: RTMsGetTaskTimeCounterForTID ==============================================
%% Abstract:
%%   Return call to get task time counter for given TID
%% 
%function RTMsGetTaskTimeCounterForTID(system, tid) void
  %assign retVal = RTMsGetTaskTimeCounterForTIDGivenRTM(system, ::tSimStruct, tid)
  %return retVal
%endfunction %% RTMsGetTaskTimeCounterForTID


%% Function: RTMsGetTaskTimeCounterForTIDGivenRTM ======================================
%% Abstract:
%%   Return call to get task time counter
%%   for given TID given the rtModel
%% 
%function RTMsGetTaskTimeCounterForTIDGivenRTM(system, rtm, tid) void
  %assert GenRTModel && ...
    SLibIsERTCodeFormat() 
  %assign getStr = RTMDispatchToAccessFcn("ClockTick%<tid>", "get", "",...
      "", rtm) 
    
  %if SLibClockTickIsUnit32Pair(tid) 
    %assert !PurelyIntegerCode
    %assign getStr2 = RTMDispatchToAccessFcn("ClockTickH%<tid>", "get", "",...
      "", rtm) + "* 4294967296.0"
    %assign getStr = "(" + getStr + "+" + getStr2 + ")"
  %endif
  
  %return getStr
%endfunction %% RTMsGetTaskTimeCounterForTIDGivenRTM


%% Function: RTMsGetTaskTimeForTID ==============================================
%% Abstract:
%%   Return call to get task time for given TID
%% 
%function RTMsGetTaskTimeForTID(system, tid) void
  %assign retVal = RTMsGetTaskTimeForTIDGivenRTM(system, GetSimStructExpr(system, ::tSimStruct), tid)
  %return retVal
%endfunction %% RTMsGetTaskTimeForTID

%%Function: FcnSampleTimeOffsetString ======================
%% Abstract:
%%   Return string to adjust task time when sample time
%% offset is not zero
%function FcnSampleTimeOffsetString(tid) void
  %assign offset = 0
  
  %% Async sample time doesn't support sample time offset
  %if (SampleTime[tid].Asynchronous == "no")
    %assign offset = PurelyIntegerCode ? ...
      FcnComputeTaskTickOffset(tid) : SampleTime[tid].PeriodAndOffset[1]
  %endif
  
  %if (offset > 0)
    %return " + %<offset>"
  %else
    %return ""
  %endif
  
  %return offsetString
%endfunction %%FcnSampleTimeOffsetString

%%Function: FcnSampleTimeResolution =========================
%% Abstract:
%%  Resturn string to multiply sample time resolution
%%
%function FcnSampleTimeResolution(tid)

  %% If accessing the sample time directly, disallow sample time inheritance
  %if ISFIELD(::CompiledModel,"ModelRefTsInheritance")
    %assign ::CompiledModel.ModelRefTsInheritance = "DISALLOW_SAMPLE_TIME_INHERITANCE"
  %endif

  %assign retStr = ""
  %if SampleTime[tid].ClockTickDataTypeId != tSS_DOUBLE
    %% only integer clock tick has resolution
    %assign res = SampleTime[tid].ClockTickStepSize
   
    %if PurelyIntegerCode
      %assign res = FcnComputeTaskTickLimit(tid)
      %if !ISFIELD(::CompiledModel,"WarnnedAbsTimeOnIntegerCode")
        %assign warnTxt = "Support of floating-point numbers is not selected. "...
          "Absolute time is being set up as an integer that increments "...
          "once per model step. Therefore, the absolute time value does not "...
          "represent the absolute time in seconds. Consider checking "...
          "the option 'Support floating-point "...
          "numbers' on 'Interface' pane, or avoiding use of absolute time "...
          "in the model"
        %<LibReportWarning(warnTxt)>
        %addtorecord ::CompiledModel WarnnedAbsTimeOnIntegerCode TLC_TRUE
      %endif
    %endif
    %% Even res == 1.0, we still emit * 1.0 so that the result is implicitly
    %% casted to a double type.
    %assert res > 0
    %assign retStr = " * %<res>"
  %endif
  %return retStr 
%endfunction

%% Function: RTMGetTaskTimeForTIDGivenRTM ======================================
%% Abstract:
%%   Return call to get task time for given TID given the rtModel
%% 
%function RTMsGetTaskTimeForTIDGivenRTM(system, rtm, tid) void
  %if GenRTModel
    %<SLibSetNeedAbsoluteTime(tid)>
    %%
    %% Take care of the case where people may have given a TLC numeric index
    %%
    %assign tidStr = (TYPE(tid) != "String") ? "%<tid>" : tid
 
    %if !SLibIsERTCodeFormat() 
      %assign getStr = RTMsDispatchToAccessFcn(system,"TaskTime","get",tidStr,"",rtm)
    %else
      %if IsModelReferenceTarget()
        %if IsModelReferenceForASimstructBasedTarget()
          %assign getStr = RTMsDispatchToAccessFcn(system,"TaskTime","get",tidStr,"",rtm)
        %else
          %% We should only access the tPtr from the timing bridge if we know
          %% the pointer will be filled in by the parent, so we need to
          %% specify that the taskTime has been accessed.
          %if SampleTime[tid].NeedFloatTime == "yes"
            %assign base = "%<SLibGetGlobalTimingBridge()>->taskTime"
            %assign indx = "%<FcnGetMdlRefGlobalTIDMap("")>[%<tid>]"
            %return "(*(%<base>[%<indx>]))"      
          %else
            %assign tic = RTMGet("ClockTick%<tid>")
            %if SLibClockTickIsUnit32Pair(tid) && !PurelyIntegerCode
              %% PurelyIntegerCode does not support timer data type tSS_TIMER_UINT32_PAIR
              %assign highTic = RTMGet("ClockTickH%<tid>")
              %assign tic = "( %<tic> + %<highTic>*4294967296.0 )"
            %endif
            %assign getStr = "(%<tic>%<FcnSampleTimeResolution(tid)>%<FcnSampleTimeOffsetString(tid)>)"
          %endif
        %endif
      %elseif SampleTime[tid].NeedFloatTime == "yes"
	%if RTMTaskTimeIsReqFcnForTID(tid)
	  %assign getStr = RTMDispatchToAccessFcn("TaskTime%<tid>", "get", "", ...
	    "", rtm)
	%else
	  %assert RTMTimePtrIsReqFcn()
	  %assign getStr = RTMDispatchToAccessFcn("TimePtr", "get", "","", rtm)
	  %assign getStr = getStr + "[%<tid>]"
	%endif
      %else
	%% Integer base time. Calculate tasktime from 
	%% integer counter and resulution. 
	%assign getStr = "((" + ...
	  RTMsGetTaskTimeCounterForTIDGivenRTM(system, rtm, tid) + ...
          ") %<FcnSampleTimeResolution(tid)>" + ...
          "%<FcnSampleTimeOffsetString(tid)>)"
      %endif
    %endif
  %else
    %assign getStr = "ssGetTaskTime(%<LibGetSimStruct()>,%<tid>)"
  %endif
  %return getStr
%endfunction %% RTMGetTaskTimeForTIDGivenRTM


%% Function: RTMGetTaskTime ====================================================
%% Abstract:
%%   Return call to get task time
%% 
%function RTMsGetTaskTime(system) void
  %return RTMsGetTaskTimeForTID(system, LibTID())
%endfunction %% RTMGetTaskTime


%% Function: RTMIsContinuousTask ===============================================
%% Abstract:
%%   Return call to check if continous task
%% 
%function RTMsIsContinuousTask(system) void
  %if ((::BlockFcn == "Derivative") || (::BlockFcn == "ForcingFunction") || (::BlockFcn == "MassMatrix"))
    %assign activeTid = 0
  %else
    %assign activeTid = LibTID()  
  %endif
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign isStr ="ssIsContinuousTask(%<simS>, %<activeTid>)"
  %else 
    %if SLibSingleTasking() 
      %return "1"
    %elseif GenRTModel
      %assign isStr = FcnGenSpecialAccess(system, "ContinuousTask", "is", 1, ...
        ["%<activeTid>"], "", ::tSimStruct)
    %else
      %assign isStr = "ssIsContinuousTask(%<SLibGetSimStruct()>, %<activeTid>)"
    %endif
  %endif
  %return isStr
%endfunction %% RTMIsContinuousTask


%% Function: RTMIsSampleHit ====================================================
%% Abstract:
%%   Return call to check if sample hit
%% 
%function RTMsIsSampleHit(system, tid) void
  %if ((::BlockFcn == "Derivative") || (::BlockFcn == "ForcingFunction") || (::BlockFcn == "MassMatrix"))
    %assign activeTid = 0
  %else
    %assign activeTid = LibTID()
  %endif
  %if GenRTModel
    %assign useCppAccessMethod = GenerateClassInterface && (system.SystemIdx == GetBaseSystemIdx() || system.RTWSystemCode != 2)
    %assign isStr = FcnGenSpecialAccess(system, "SampleHit", "is", 2, ...
      ["%<tid>", "%<activeTid>"], "", useCppAccessMethod ? "getRTM()" : ::tSimStruct)
  %else
    %assign isStr = "ssIsSampleHit(%<SLibGetSimStruct()>, %<tid>, %<activeTid>)"
  %endif
  %return isStr
%endfunction %% RTMIsSampleHit


%% Function: RTMIsSpecialSampleHit =============================================
%% Abstract:
%%   Return call to check if special sample hit
%% 
%function RTMsIsSpecialSampleHit(system, sti, tid) void
  %if GenRTModel
     %assign useCppAccessMethod = GenerateClassInterface && (system.SystemIdx == GetBaseSystemIdx() || system.RTWSystemCode != 2)
    %assign isStr = FcnGenSpecialAccess(system, "SpecialSampleHit", "is", 3, ...
      ["%<sti>", "%<tid>", "%<LibTID()>"], "", useCppAccessMethod ? "getRTM()" : ::tSimStruct)
  %else
    %assign isStr = ...
      "ssIsSpecialSampleHit(%<SLibGetSimStruct()>,%<sti>,%<tid>,%<LibTID()>)"
  %endif
  %return isStr
%endfunction %% RTMIsSpecialSampleHit


%% Function: RTMChkMemAndReturnIfErr ===========================================
%% Abstract:
%%   Return a call for validating memory in the rtModel
%% 
%function RTMsChkMemAndReturnIfErr(system, ptr) void
  %if CodeFormat != "S-Function"
    %assign validateStr = "rt_VALIDATE_MEMORY"
  %else
    %assign validateStr = "ss_VALIDATE_MEMORY"
  %endif
  %assign vStr = "%<validateStr>(%<SLibGetSimStruct()>," + ptr + ")"
  %return vStr
%endfunction %% RTMChkMemAndReturnIfErr


%% Function: RTMsSetBlkStateChange ============================================
%% Abstract:
%%   Sets BlkStateChange flag.
%%
%function RTMsSetBlkStateChange(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr =  "ssSetBlkStateChange(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"      
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")       
      %endif
      %assign setStr = "rtsiSetBlkStateChange(%<rts>, %<GET_TYPE_ID_REPLACEMENT("true")>)"
    %else
      %assign setStr = "ssSetBlkStateChange(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %if !ISFIELD(::CompiledModel, "HasContTimeOutputInconsistentWithStateAtMajorStep")
    %addtorecord ::CompiledModel HasContTimeOutputInconsistentWithStateAtMajorStep TLC_TRUE 
  %endif
  %return setStr
%endfunction %% RTMsSetBlkStateChange


%% Function: RTMsGetBlkStateChange ============================================
%% Abstract:
%%   Gets BlkStateChange flag.
%%
%function RTMsGetBlkStateChange(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %<SLibCG_AccessRTM()>
    %assign simS = RTMsGet(system, "MdlRefSfcnS")    
    %assign getStr =  "ssGetBlkStateChange(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")      
      %endif
      %assign getStr = "rtsiGetBlkStateChange(%<rts>)"
    %else
      %assign getStr = "ssGetBlkStateChange(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return getStr
%endfunction %% RTMsGetBlkStateChange

%% Function: RTMsClearBlkStateChange ==============================================
%% Abstract:
%%   Clear BlkStateChange flag.
%%
%% Function: RTMsClearBlkStateChange ============================================
%% Abstract:
%%   clear BlkStateChange flag.
%%
%function RTMsClearBlkStateChange(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr =  "ssClearBlkStateChange(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")       
      %endif
      %assign setStr = "rtsiSetBlkStateChange(%<rts>, %<GET_TYPE_ID_REPLACEMENT("false")>)"
    %else
      %assign setStr = "ssClearBlkStateChange(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return setStr
%endfunction %% RTMsClearBlkStateChange


%% Function: RTMsSetContTimeOutputInconsistentWithStateAtMajorStep =============
%% Abstract:
%%   Signal that the block output at major time is consistent with its state
%%
%function RTMsSetContTimeOutputInconsistentWithStateAtMajorStep(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr =  "ssSetContTimeOutputInconsistentWithStateAtMajorStep(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"      
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")       
      %endif
      %assign setStr = "rtsiSetContTimeOutputInconsistentWithStateAtMajorStep(%<rts>, %<GET_TYPE_ID_REPLACEMENT("true")>)"
    %else
      %assign setStr = "ssSetContTimeOutputInconsistentWithStateAtMajorStep(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %if !ISFIELD(::CompiledModel, "HasContTimeOutputInconsistentWithStateAtMajorStep")
    %addtorecord ::CompiledModel HasContTimeOutputInconsistentWithStateAtMajorStep TLC_TRUE 
  %endif
  %return setStr
%endfunction %%  RTMsSetContTimeOutputInconsistentWithStateAtMajorStep


%% Function: RTMsGetContTimeOutputInconsistentWithStateAtMajorStep ============
%% Abstract:
%% get flag that signals that the block output at major time is consistent with
%% its state
%%
%function RTMsGetContTimeOutputInconsistentWithStateAtMajorStep(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %<SLibCG_AccessRTM()>
    %assign simS = RTMsGet(system, "MdlRefSfcnS")    
    %assign getStr =  "ssGetContTimeOutputInconsistentWithStateAtMajorStep(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")      
      %endif
      %assign getStr = "rtsiGetContTimeOutputInconsistentWithStateAtMajorStep(%<rts>)"
    %else
      %assign getStr = "ssGetContTimeOutputInconsistentWithStateAtMajorStep(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return getStr
%endfunction %% RTMsGetContTimeOutputInconsistentWithStateAtMajorStep

%% Function: RTMsClearContTimeOutputInconsistentWithStateAtMajorStep ==============================================
%% Abstract:
%%   Clear ContTimeOutputInconsistentWithStateAtMajorStep flag.
%%
%function RTMsClearContTimeOutputInconsistentWithStateAtMajorStep(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr =  "ssClearContTimeOutputInconsistentWithStateAtMajorStep(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")       
      %endif
      %assign setStr = "rtsiSetContTimeOutputInconsistentWithStateAtMajorStep(%<rts>, %<GET_TYPE_ID_REPLACEMENT("false")>)"
    %else
      %assign setStr = "ssClearContTimeOutputInconsistentWithStateAtMajorStep(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return setStr
%endfunction %% RTMsClearContTimeOutputInconsistentWithStateAtMajorStep

%% Function: RTMsSetBlockStateForSolverChangedAtMajorStep =============
%% Abstract:
%%   Signal that the block output at major time is consistent with its state
%%
%function RTMsSetBlockStateForSolverChangedAtMajorStep(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr =  "ssSetBlockStateForSolverChangedAtMajorStep(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"      
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")       
      %endif
      %assign setStr = "rtsiSetBlockStateForSolverChangedAtMajorStep(%<rts>, %<GET_TYPE_ID_REPLACEMENT("true")>)"
    %else
      %assign setStr = "ssSetBlockStateForSolverChangedAtMajorStep(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return setStr
%endfunction %%  RTMsSetBlockStateForSolverChangedAtMajorStep

%% Function: RTMGetErrStat =====================================================
%% Abstract:
%%   Return code for doing a "get" on ErrorStatus field in the rtModel
%% 
%function RTMsGetErrStat(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %return "ssGetErrorStatus(%<simS>)"
  %endif
  %return RTMsGet(system, "ErrorStatus")
%endfunction %% RTMGetErrStat


%% Function: RTMSetErrStat =====================================================
%% Abstract:
%%   Return code for setting the error status
%% 
%function RTMsSetErrStat(system, errStat) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %return "ssSetErrorStatus(%<simS>, %<errStat>)"
  %endif
  %return RTMsSet(system, "ErrorStatus", errStat)
%endfunction %% RTMSetErrStat

%% Function: RTMsGetAbsTolVector ============================================
%% Abstract:
%%   Get the absolute tolerance vector.
%%
%function RTMsGetAbsTolVector(system)
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr = "ssGetAbsTolVector(%<simS>)"
  %else
    %assign setStr = "ssGetAbsTolVector(%<SLibGetSimStruct()>)"
  %endif
  %return setStr
%endfunction %% RTMGetAbsTolVector

%% Function: RTMsGetAbsTolControlVector ========================================
%% Abstract:
%%   Get the absolute tolerance control vector.
%%
%function RTMsGetAbsTolControlVector(system)
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr = "ssGetAbsTolControlVector(%<simS>)"
  %else
    %assign setStr = "ssGetAbsTolControlVector(%<SLibGetSimStruct()>)"
  %endif
  %return setStr
%endfunction %% RTMGetAbsTolControlVector

%% Function: RTMSetSolverNeedsReset ============================================
%% Abstract:
%%   Sets solver needs reset flag.
%%
%function RTMsSetSolverNeedsReset(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr =  "ssSetSolverNeedsReset(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"
        %assign setStr = "rtsiSetSolverNeedsReset(%<rts>, %<GET_TYPE_ID_REPLACEMENT("true")>)"
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")
        %assign setStr = "rtsiSetSolverNeedsReset(%<rts>, %<GET_TYPE_ID_REPLACEMENT("true")>)"
      %endif
    %else
      %assign setStr = "ssSetSolverNeedsReset(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return setStr
%endfunction %% RTMSetSolverNeedsReset

%% Function: RTMsGetBlockStateForSolverChangedAtMajorStep ============================================
%% Abstract:
%% Gets the flag to indicate that block state has changed at major step
%% (output/update). This flag is used by continuous blocks. 
%%
%function RTMsGetBlockStateForSolverChangedAtMajorStep(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign setStr =  "ssGetBlockStateForSolverChangedAtMajorStep(%<simS>)"
  %else
    %if GenRTModel      
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts    = "%<RTMGetSolverInfo()>"
        %assign setStr = "rtsiGetBlockStateForSolverChangedAtMajorStep(%<rts>, %<GET_TYPE_ID_REPLACEMENT("true")>)"
      %else
        %assign rts    = RTMsGet(system, "RTWSolverInfo")
        %assign setStr = "rtsiGetBlockStateForSolverChangedAtMajorStep(%<rts>, %<GET_TYPE_ID_REPLACEMENT("true")>)"
      %endif
    %else
      %assign setStr = "ssGetBlockStateForSolverChangedAtMajorStep(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return setStr
%endfunction %% RTMsGetBlockStateForSolverChangedAtMajorStep


%% Function: RTMModelMthsSet ======================================================
%% Abstract:
%%   Set a model-methods field
%%
%function RTMsModelMthsSet(system, fldName,sVal) void
  %if GenRTModel
    %assign rts          = RTMsGet(system, "RTWRTModelMethodsInfo")
    %assign transFldName = "UNHANDLED_FIELD"
    %switch fldName
      %case "mdlInitializeSizes"
	%assign transFldName = "InitSizesFcn"
	%break
      %case "mdlInitializeSampleTimes"
	%assign transFldName = "InitSampTimesFcn"
	%break
      %case "mdlStart"
	%assign transFldName = "StartFcn"
	%break
      %case "mdlOutputs"
	%assign transFldName = "OutputsFcn"
	%break
      %case "mdlUpdate"
	%assign transFldName = "UpdateFcn"
	%break
      %case "mdlDerivatives"
	%assign transFldName = "DervisFcn"
	%break
      %case "mdlProjection"
	%assign transFldName = "ProjectionFcn"
	%break
      %case "mdlForcingFunction"
	%assign transFldName = "ForcingFunctionFcn"
	%break
      %case "mdlMassMatrix"
	%assign transFldName = "MassMatrixFcn"
	%break
      %case "mdlTerminate"
	%assign transFldName = "TerminateFcn"
	%break
      %case "mdlDiscreteEvents"
	%assign transFldName = "DiscreteEventsFcn"
	%break
      %case "RTModelPtr"
	%assign transFldName = "RTModelPtr"
	%break
      %default
	%% BEGIN_ASSERT
	%break
	%% END_ASSERT
    %endswitch
    %assign setStr = "rtmiSet%<transFldName>((%<rts>), %<sVal>)"
  %else
    %assert fldName != "RTModelPtr"
    %assign setStr = "ssSet%<fldName>(%<SLibGetSimStruct()>, %<sVal>)"
  %endif
  %return setStr
%endfunction %% RTMModelMthsSet


%% Function: RTMsSolverSet =====================================================
%% Abstract:
%%   Set a solver-specific field
%%
%function RTMsSolverSet(system, fldName,sVal) void
  %if GenRTModel
    %if SLibIsERTCodeFormat()
      %assign rts    = "%<RTMGetSolverInfo()>"
    %else
      %assign rts    = RTMsGet(system, "RTWSolverInfo")
    %endif
    %assign setStr = "rtsiSet%<fldName>(%<rts>, %<sVal>)"
  %else
    %assign setStr = "ssSet%<fldName>(%<SLibGetSimStruct()>, %<sVal>)"
  %endif
  %return setStr
%endfunction %% RTMsSolverSet


%% Function: RTMSolverGet ======================================================
%% Abstract:
%%   Get a solver-specific field
%%
%function RTMsSolverGet(system, fldName) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign getStr =  "ssGet%<fldName>(%<simS>)"
  %else
    %if GenRTModel
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts = RTMGetSolverInfo()        
      %else                
        %assign rts = RTMsGet(system, "RTWSolverInfo")
      %endif
      %assign getStr = "rtsiGet%<fldName>(%<rts>)"
    %else
      %assign getStr = "ssGet%<fldName>(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return getStr
%endfunction %% RTMSolverGet


%% Function: RTMSolverIs ======================================================
%% Abstract:
%%   Query a solver-specific field
%%
%function RTMsSolverIs(system, fldName) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %assign isStr = "ssIsSolver%<fldName>(%<simS>)"
  %else
    %if GenRTModel
      %if SLibIsERTCodeFormat() && !IsModelReferenceTarget()
        %assign rts = RTMGetSolverInfo()        
      %else        
        %assign rts = RTMsGet(system, "RTWSolverInfo")
      %endif      
      %assign isStr = "rtsiIsSolver%<fldName>(%<rts>)"
    %else
      %assign isStr = "ssIsSolver%<fldName>(%<SLibGetSimStruct()>)"
    %endif
  %endif
  %return isStr
%endfunction %% RTMSolverIs


%% Function: RTMSolverAssertCheck ==============================================
%% Abstract:
%%   Used with accelerator to generate conditionals for the
%%   Simulink consistency checker.
%%
%function RTMsSolverAssertCheck(system) void
  %if IsModelReferenceSimTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
  %else
    %assert !GenRTModel
    %assign simS = SLibGetSimStruct()
  %endif
  %assign setStr = "_ssGetSolverAssertCheck(%<simS>)"
  %return setStr
%endfunction %% RTMSolverAssertCheck


%% Function: RTMLoggingSet =====================================================
%% Abstract:
%%   Return code for setting a logging related field in the SimStruct. 
%% 
%function RTMsLoggingSet(system, recordName, initVal) void
  %if recordName == "RTWLogInfo"
    %openfile setFile
    %if SLibIsERTCodeFormat()
      %<RTMGetLoggingObject()> = %<initVal>;
    %else
      %<RTMsSet(system, "RTWLogInfo", "%<initVal>")>;
    %endif
    %closefile setFile
  %else
    %openfile setFile
    %assign setStr = "rtliSet" + recordName + ...
      "(%<RTMGetLoggingObject()>, %<initVal>)"
    %<setStr>;
    %closefile setFile
  %endif
  
  %return setFile
%endfunction %% RTMLoggingSet
  

%% Function: RTMLoggingGet =====================================================
%% Abstract:
%%   Return code for getting a logging related field in the SimStruct. 
%% 
%function RTMsLoggingGet(system, recordName) void
  %assign setStr = "rtliGet" + recordName + ...
    "(%<RTMGetLoggingObject()>)"
  
  %return setStr
%endfunction %% RTMLoggingGet
  

%% Function: RTMGetModelSS =====================================================
%% Abstract:
%%   Returns model SimStruct when explicitly needed. This is a temporary 
%%   function to help migrate away from the root SimStruct
%% 
%function RTMsGetModelSS(system,getAddressTakenCareOf) void
  %if getAddressTakenCareOf
    %if GenerateClassInterface && system.SystemIdx != GetBaseSystemIdx()
      %assign symbolName = "getRTM()"
    %else
      %assign symbolName = ::tSimStruct
    %endif
  %else
    %assign symbolName = GetSimStructExpr(system, ::tSimStruct)
  %endif
  %assign rtmName = FcnUpdateRTModelInterfaceArg(system, symbolName)
  %return rtmName
%endfunction %% RTMGetRootSS

%endif %% _RTMDLLIB_


%% Function: RTMUpdateIntegerAbsoluteTime ======================================
%% Abstract:
%%   Used currently by ERT to update time. It is not a real SimStruc macro.
%% 
%function RTMsUpdateIntegerAbsoluteTime(system) void
  %if GenRTModel
    %assign updStr = FcnGenSpecialAccess(system, "UpdateIntegerAbsoluteTime", ...
      "other", 0, [], "", ::tSimStruct)
  %else
    %assign updStr = "ssUpdateIntegerAbsoluteTime(%<SLibGetSimStruct()>)"
  %endif
  %return updStr
%endfunction %% RTMUpdateIntegerAbsoluteTime


%% Function: RTMUpdateRealAbsoluteTime ======================================
%% Abstract:
%%   Used currently by ERT to update time. It is not a real SimStruc macro.
%% 
%function RTMsUpdateRealAbsoluteTime(system) void
  %if GenRTModel
    %assign updStr = FcnGenSpecialAccess(system, "UpdateRealAbsoluteTime", ...
      "other", 0, [], "", ::tSimStruct)
  %else
    %assign updStr = "ssUpdateRealAbsoluteTime(%<SLibGetSimStruct()>)"
  %endif
  %return updStr
%endfunction %% RTMUpdateRealAbsoluteTime

%% Function: RTMUpdateRealAbsoluteTimeForTID ===================================
%% Abstract:
%%   Used currently by ERT to update time for TID. It is not a real SimStruc macro.
%% 
%function RTMsUpdateRealAbsoluteTimeForTID(system, tid) void
  %assign updateRealTimeFromSolverInfo = ...
    (ISEQUAL(tid,0) || ISEQUAL(tid, "")) && ((NumContStates > 0) || ...
    (GenerateGRTWrapper && UsingMalloc))
  %if GenRTModel
    %assign offsetStr = FcnSampleTimeOffsetString(tid)
    %if SLibClockTickIsUnit32Pair(tid)
      %assign ct  = RTMDispatchToAccessFcn("ClockTick%<tid>", "get", ...
	"", "", GetSimStructExpr(system, ::tSimStruct))
      %assign cth  = RTMDispatchToAccessFcn("ClockTickH%<tid>", "get", ...
	"", "", GetSimStructExpr(system, ::tSimStruct))
      %assign ss = RTMDispatchToAccessFcn("StepSize%<tid>", "get", ...
	"", "", GetSimStructExpr(system, ::tSimStruct))
      %assign tt = "%<LibGetTaskTime(tid)>"
      %assign updStr = "if(!(++%<ct>)) {\n ++%<cth>; \n}"
	
      %% No need to update the task time if it's a modelref coder target
      %% and the tid is continuous
      %if !IsModelReferenceRTWTarget() || !LibIsContinuous(tid)
        %if PurelyIntegerCode
	  %% Extmode mode require floating point absolute time, in this 
	  %% case, PurelyIntegerCode need provide floating point time. 
	  %%
          /* Integer time limited to single word timer. */
	  %assign updStr = "%<updStr> %<tt> = %<ct>;"
	%elseif updateRealTimeFromSolverInfo
          %assign updStr = "%<updStr>  %<tt> = rtsiGetSolverStopTime(%<RTMGetSolverInfo()>);"
        %else
          %assign updStr = "%<updStr> %<tt> = %<ct> * %<ss> + %<cth> * %<ss> * 4294967296.0"
	  %assign updStr = updStr + offsetStr+";"
	%endif
      %endif
    %else
      %assign ct  = RTMDispatchToAccessFcn("ClockTick%<tid>", "get", ...
	"", "", GetSimStructExpr(system, ::tSimStruct))
      %assign ss = RTMDispatchToAccessFcn("StepSize%<tid>", "get", ...
	"", "", GetSimStructExpr(system, ::tSimStruct))
      %assign tt = "%<LibGetTaskTime(tid)>"
	
      %% No need to update the task time if it's a model ref target
      %% and the tid is continuous
      %if IsModelReferenceRTWTarget() && LibIsContinuous(tid)
        %assign updStr = "%<ct>++;"
      %else
        %if PurelyIntegerCode
          %assign updStr = "%<tt> = \n (++%<ct>);"
        %elseif updateRealTimeFromSolverInfo
          %assign updStr = "++%<ct>; \n  %<tt> = rtsiGetSolverStopTime(%<RTMGetSolverInfo()>);"
        %else
          %assign updStr = "%<tt> = \n (++%<ct>) * %<ss>"
	  %assign updStr = updStr + offsetStr + ";"
        %endif
      %endif
    %endif
  %else
    %assign updStr = "ssUpdateRealAbsoluteTimeForTID(%<SLibGetSimStruct()>, %<tid>);"
  %endif
  %return updStr
%endfunction %% RTMUpdateRealAbsoluteTimeForTID

%% Function: RTMUpdateIntegerAbsoluteTimeForTID ===================================
%% Abstract:
%%   Used currently by ERT to update time for TID. It is not a real SimStruc macro.
%% 
%function RTMsUpdateIntegerAbsoluteTimeForTID(system, tid) void
  %if GenRTModel
      %if SLibClockTickIsUnit32Pair(tid)
	%assign ct  = RTMDispatchToAccessFcn("ClockTick%<tid>", "get", ...
	  "", "", GetSimStructExpr(system, ::tSimStruct))
        %assign cth  = RTMDispatchToAccessFcn("ClockTickH%<tid>", "get", ...
	  "", "", GetSimStructExpr(system, ::tSimStruct))
	%assign updStr = "%<ct>++;"
	%assign updStr = "%<updStr>\n if (!%<ct>) {\n %<cth>++; \n}"
      %else
	%assign ct  = RTMDispatchToAccessFcn("ClockTick%<tid>", "get", ...
	  "", "", GetSimStructExpr(system, ::tSimStruct))
	%assign updStr = "%<ct>++;"
      %endif
  %else
    %assign updStr = "ssUpdateIntegerAbsoluteTimeForTID(%<SLibGetSimStruct()>, %<tid>);"
  %endif
  %return updStr
%endfunction %% RTMUpdateIntegerAbsoluteTimeForTID

%% Function: RTMUpdateSubrateTaskTime ==========================================
%% Abstract:
%%   Used currently by ERT to update time. It is not a real SimStruc macro.
%% 
%function RTMsUpdateSubrateTaskTime(system, subRateIdx) void
  %if GenRTModel
    %assign updStr = FcnGenSpecialAccess(system, "UpdateSubrateTaskTime", ...
      "other", 1, ["%<subRateIdx>"], "", ::tSimStruct)
  %else
    %assign updStr = "ssUpdateSubrateTaskTime(%<SLibGetSimStruct()>, %<subRateIdx>)"
  %endif
  %return updStr
%endfunction %% RTMUpdateSubrateTaskTime


%% Function: RTMTaskRunsThisBaseStep ============================================
%% Abstract:
%%   Used currently by ERT to determine if there is a subrate hit.
%% 
%function RTMsTaskRunsThisBaseStep(system, subRateIdx) void
  %if GenRTModel
    %assign updStr = FcnGenSpecialAccess(system, "StepTask", ...
      "other", 1, ["%<subRateIdx>"], "", ::tSimStruct)
  %else
    %assign updStr = "ssStepTask(%<SLibGetSimStruct()>, %<subRateIdx>)"
  %endif
  %return updStr
%endfunction %% RTMTaskRunsThisBaseStep

%function RTMsUpdateTaskCounter(system, subRateIdx) void
  %assert GenRTModel
  %assign getStr = FcnGenSpecialAccess(system, "TaskCounter", ...
    "other", 1, ["%<subRateIdx>"], "", ::tSimStruct)
  %assign retStr = "if (++%<getStr> == %<FcnComputeTaskTickLimit(subRateIdx)>) %<getStr> = 0;"
  
  %return retStr
%endfunction %%  RTMsUpdateTaskCounter

%% Function: RTMGetStopRequested ===============================================
%% Abstract:
%%   Return code for doing a "get" on StopRequested field in the rtModel
%% 
%function RTMsGetStopRequested(system) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %return "ssGetStopRequested(%<simS>)"
  %endif
  %return RTMsGet(system, "StopRequested")
%endfunction %% RTMGetStopRequested


%% Function: RTMSetStopRequested ===============================================
%% Abstract:
%%   Return code for setting the stop requested flag
%% 
%function RTMsSetStopRequested(system, srq) void
  %if IsModelReferenceForASimstructBasedTarget()
    %assign simS = RTMsGet(system, "MdlRefSfcnS")
    %return "ssSetStopRequested(%<simS>, %<srq>)"
  %endif
  %return RTMsSet(system, "StopRequested", srq)
%endfunction %% RTMSetStopRequested


%% Function: RTMStopReqAccessed ================================================
%% Abstract:
%%   Was stop requested flag accessed?
%% 
%function RTMsStopReqAccessed(system) void
  %assign srq      = "StopRequested"
  %assign srqp     = "StopRequestedPtr"
  %assign rtRecs   = RTMGetRTModelRecShell()
  %assign theRec   = rtRecs.%<srq>
  %assign theRecp  = rtRecs.%<srqp>
  %assign accessed = (theRec.NumSet > 0) || (theRec.NumGet > 0) || ...
    (theRecp.NumGet > 0) || (theRecp.NumSet > 0)
  %%
  %% The StopRequestedFlag is required for the SolverInfo record, so we also
  %% need to check for continuous states and non-inlined s-functions
  %%
  %return (accessed || NumContStates || NumChildSFunctions)
%endfunction %% RTMStopReqAccessed

%% Function: RTMRegisterDataType ===============================================
%% Abstract:
%%   Return code for doing a data type registration
%% 
%function RTMsRegisterDataType(system, dtypeName) void
  %% Used only for simstruc.h
  %assert !GenRTModel

  %assign regStr = "ssRegisterDataType(%<SLibGetSimStruct()>, %<dtypeName>)"
  
  %return regStr
%endfunction %% RTMRegisterDataType

%%------------------------------------------------------------------------------
%% rtModel creation SECTION:
%%------------------------------------------------------------------------------
%% This section is devoted to methods that are called to create a type 
%% defintion for the rtModel structure. There are also methods for generating
%% access macros for some of the fields when necessary.
%%------------------------------------------------------------------------------


%% Function: FcnGetQualifier ===================================================
%% Abstract:
%%   Generate the qualifier
%%
%function FcnGetQualifier(qual) void
  %assign retStr = ""
  %switch qual
    %case "CONST"
      %assign retStr = "const "
      %break
    %default
      %assign retStr = qual
      %break
  %endswitch
  %return retStr
%endfunction %% FcnGetQualifier


%% Function: FcnGetDtypeName ===================================================
%% Abstract:
%%   Generate the datatype name.
%%
%function FcnGetDtypeName(dTypeId)
  %switch dTypeId
    %case "CHAR"
      %assign retStr = "char_T"
      %break
    %case "UINT32"
    %case "uint32"
      %assign retStr = "uint32_T"
      %break
    %case "UINT16"
    %case "uint16"
      %assign retStr = "uint16_T"
      %break  
    %case "UINT8"
    %case "uint8"
      %assign retStr = "uint8_T"
      %break
    %case "INT"
      %assign retStr = "int_T"
      %break
    %case "REAL"
    %case "real_T"
    %case "DOUBLE"
    %case "double"
      %assign retStr = "real_T"
      %break
    %case "VOID"
      %assign retStr = "void"
      %break
    %case "VOID_PTR"
      %assign retStr = "void *"
      %break
    %case "SIMSTRUCT"
      %assign retStr = "struct SimStruct_tag"
      %break
    %case "SIMSTRUCT_PTR"
      %assign retStr = "struct SimStruct_tag *"
      %break
    %case "SS_SIMMODE"
      %assign retStr = "SS_SimMode"
      %break
    %case "TIME"
      %if SLibIsERTCodeFormat() && PurelyIntegerCode
	%assign retStr = "uint32_T"
      %else
	%assign retStr = "time_T"
      %endif
      %break
    %case "SOLVER_MODE"
      %assign retStr = "SolverMode"
      %break
    %case "ZC_SIG_STATE"
      %assign retStr = FcnGetPrevZCSigStateType()
      %break
    %case "ZC_SIG_STATE_CLASSIC"
      %assign retStr = "ZCSigState"
      %break
    %case "BOOLEAN"
      %assign retStr = "boolean_T"
      %break
    %case "DWORK"
      %assign retStr = ::tDWorkType
      %break
    %case "BLOCKIO"
      %assign retStr = ::tBlockIOType
      %break
    %case "INPUTS"
      %assign retStr = ::tInputType
      %break
    %case "OUTPUTS"
      %assign retStr = tOutputType
      %break
    %case "PARAMETER"
      %assign retStr = ::tParametersType
      %break
    %case "CONT_STATES"
      %assign retStr = ::tContStateType
      %break
    %case "RTW_LOG_INFO"
      %assign retStr = "RTWLogInfo"
      %break
    %case "EXT_MODE_INFO"
      %assign retStr = "RTWExtModeInfo"
      %break
    %case "SOLVER_INFO"
      %assign retStr = "RTWSolverInfo"
      %break
    %case "NONINLINED_SFCS"
      %assign retStr = SLibIsERTCodeFormat() ? ...
        SLibGenERTNonInlinedSFcnsSubStruct() : ""
      %break
    %case "MODEL_METHODS_INFO"
      %assign retStr = "RTWRTModelMethodsInfo"
      %break
    %case "SIM_TIME_STEP"
      %assign retStr = "SimTimeStep"
      %break
    %case "INTG"
      %assign retStr = "%<upperSolver>_IntgData"
      %break
    %case "LOG_SIG_PTR"
      %assign retStr = "LogSignalPtrsType"
      %break
    %case "DATA_MAP_INFO"
      %assign retStr = RTWCAPI ? SLibGenDataMapInfoSubstruct() : ""
      %break
    %case "RATE_INTERACTION"
      %assign retStr = SLibIsERTCodeFormat() ? ...
	SLibGenERTRateInteractionSubStruct() : ""
      %break
    %case "TASK_COUNTERS"
      %assign retStr = SLibIsERTCodeFormat() ? ...
	SLibGenERTTaskCountersSubStruct() : ""
      %break
    %case "VDR_TIMING"
      %assign retStr = "rtVDRMdlRefTiming"
      %break
    %case "NONCONT_SIGS"
      %assign retStr = "ssNonContDerivSigInfo"
      %break
    %case "NONCONT_DERIV_SIGS_MEMORY"
      %assign retStr = RTMNeedsNonContDerivSigs() ? SLibGenNoncontDerivSigStruct() : ""
      %break
    %case "TIMING_BRIDGE"
      %assign retStr = "rtTimingBridge"
      %break
    %case "Rte_Instance"
      %assign retStr = "Rte_Instance"
      %break
    %default
      %% Can get here for Coder Data Groups
      %assign retStr = dTypeId
  %endswitch
  %return retStr
%endfunction %% FcnGetDtypeName


%% Function: FcnGetStorageKeys =================================================
%% Abstract:
%%   Generate the prefix and postfix keys for the given storage class
%%
%function FcnGetStorageKeys(storage, arrayDims) void
  %switch storage
    %case "SCALAR"
      %assign prefix  = ""
      %assign postfix = ""
      %break
    %case "POINTER"
      %assign prefix  = "*"
      %assign postfix = ""
      %break
    %case "VOLATILEPOINTER"
      %assign prefix  = "* volatile "
      %assign postfix = ""
      %break
    %case "POINTERPOINTER"
      %assign prefix  = "**"
      %assign postfix = ""
      %break
    %case "ARRAY"
      %assign prefix  = ""
      %assign nDims = SIZE(arrayDims)[1]
      
      %assign postfix = ""
      %foreach dimIdx = nDims
	%assign postfix = postfix + "[%<arrayDims[dimIdx]>]"
      %endforeach
      %break
    %default
      %assign prefix  = "BOGUS_PREFIX"
      %assign postfix = "BOGUS_POSTFIX"
      %break
  %endswitch
  %assign retVal = ["%<prefix>", "%<postfix>"]
  %return retVal
%endfunction %% FcnGetStorageKeys


%% Function: FcnGenFieldTypeDef ================================================
%% Abstract:
%%   Generates the type definition for one of the fields in the rtModel
%%
%function FcnGenFieldTypeDef(theField) void
  %assign qual  =FcnGetQualifier(theField.Qualifier)
  
  %assign dType =FcnGetDtypeName(theField.DataType)
  %assign stKeys=FcnGetStorageKeys(theField.StorageType,theField.ArrayDims)
  %assign retStr="%<qual>%<dType> %<stKeys[0]>%<theField.VarName>%<stKeys[1]>;"
  %return retStr
%endfunction %% FcnGenFieldTypeDef


%% Function: FcnGenTypeStrForRTMFields =========================================
%% Abstract:
%%   Generates the typedef for the rtModel based on the usage of various 
%%   fields in the rtModel record.
%% 
%function FcnGenTypeStrForRTMFields(rtRecs) void
  %assign rootFields = FIELDNAMES(rtRecs)
  %assign numFields  = SIZE(rootFields)[1]

  %foreach fldIdx = numFields
    %assign thisfld = rtRecs.%<rootFields[fldIdx]>
    %if thisfld.RecType != "Variable"
      %continue
    %endif
    
    %assign thisfld.TypeStr = FcnGenFieldTypeDef(thisfld)
  %endforeach
  
%endfunction %% FcnGenTypeStrForRTMFields


%% FcnRTMFieldIsRequired =======================================================
%% Abstract:
%%   Is a field in the rtModel required?
%%
%function FcnRTMFieldIsRequired(fld) void
  %%
  %% Currently we also make fields which have at least one Get required.
  %% This is because the field could be potentially updated in a location
  %% within rtw/c/src/
  %%
  %assign reqFcn = "%<fld.IsRequiredFcn>"
  %assign req = %<reqFcn>
  %return req
%endfunction %% FcnRTMFieldIsRequired


%% Function: FcnGenHStructFromRTMRecs ==========================================
%% Abstract:
%%   Generate a hierarchical structure from the rtModel records.
%%
%function FcnGenHStructFromRTMRecs(rtRecs) void
  %assign rootFields = FIELDNAMES(rtRecs)
  %assign numFields  = SIZE(rootFields)[1]
  %assign empArray = []
  
  %createrecord Root {}
  %addtorecord  Root FieldNames %<empArray>
  %addtorecord  Root FieldNums %<empArray>
  %addtorecord  Root TotalNumFields 0
  
  %foreach fldIdx = numFields
    %assign thisfld = GETFIELD(rtRecs, rootFields[fldIdx])
    %if thisfld.RecType != "Variable"
      %continue
    %endif
    
    %%
    %% We only deal here with parents that are 1-level deep.
    %% More work needs to be done here if we need deeper
    %% Root structures.
    %%
    
    %if FcnRTMFieldIsRequired(thisfld)
      %assign fldParent = thisfld.Parent
      %assign rootField = (fldParent == "")
      %if !rootField
	%if !ISFIELD(Root, fldParent)
	  %addtorecord Root %<fldParent> ...
	  { ...
	    FieldNames %<empArray>; ...
	    FieldNums  %<empArray>  ...
	  }
	%endif
	%assign parentRec = GETFIELD(Root, fldParent)
      %else
	%assign parentRec = Root
      %endif

      %assign Root.TotalNumFields = Root.TotalNumFields + 1
      %assign parentRec.FieldNames = parentRec.FieldNames + rootFields[fldIdx]
      %assign parentRec.FieldNums  = parentRec.FieldNums  + thisfld.VarRecNumber
    %endif
  %endforeach
  %return Root
%endfunction %% FcnGenHStructFromRTMRecs


%% Function: FcnGenSubstructFlatFields =========================================
%% Abstract:
%%   Generate flat substructure for RTModel rec fields
%%
%function FcnGenSubstructFlatFields(name, fldNums, fields) void
  %assign rtRecs    = RTMGetRTModelRecShell()
  %assign numFields = SIZE(fldNums)[1]
  %openfile tmpBuff
  %foreach fldIdx = numFields
    %if numFields > 1
      %assign thisfld = rtRecs.%<fields[fldIdx]>
    %else
      %assign thisfld = rtRecs.%<fields>
    %endif
    %<thisfld.TypeStr>
  %endforeach
  %closefile tmpBuff
  %return tmpBuff
%endfunction %% FcnGenSubstructFlatFields

%% Function: FcnGenTypeDefFromHStruct_Fields
%% Abstract:
%%  Generate a typedef from the hierarchical struct but only
%%  returns the fields inside the type, not the struct head and tail.
%%  e.g. struct { int a; int b; } myStructType;
%%                ^^^^^^^^^^^^
%%                return this
%function FcnGenTypeDefFromHStruct_Fields(structName, hstruct) void
  %assign fldNames = hstruct.FieldNames
  %assign fldNums  = hstruct.FieldNums
  %assign flatFields = ""
  
  %if SIZE(fldNums)[0] > 0 && SIZE(fldNums)[1] > 0
    %assign sortNames  = FEVAL("rtmdlsortflds", fldNames, fldNums)
    %assign flatFields = FcnGenSubstructFlatFields(structName, fldNums, ...
      sortNames)
  %endif
  
  %assign childFlds    = FIELDNAMES(hstruct)
  %assign numChildFlds = SIZE(childFlds)[1]
  
  %openfile fieldsBuffer
    %<flatFields>
    %foreach fldIdx = numChildFlds
      %if childFlds[fldIdx] == "FieldNames" || ...
        childFlds[fldIdx] == "FieldNums" || ...
        childFlds[fldIdx] == "TotalNumFields"
        %continue
      %endif
      %%
      %assign hss = hstruct.%<childFlds[fldIdx]>
      %<FcnGenTypeDefFromHStruct(childFlds[fldIdx],hss,"")>
    %endforeach

  %closefile fieldsBuffer
  %return fieldsBuffer
%endfunction

%% Function: FcnGenTypeDefFromHStruct ==========================================
%% Abstract:
%%   Generate a typedef from the hierarchical struct
%%
%function FcnGenTypeDefFromHStruct(structName, hstruct, tag) void
  %assign structFields = FcnGenTypeDefFromHStruct_Fields(structName, hstruct)
  %assign structTail = " %<structName>"
  %if (structName == ::tSimStructType)
    %assign structTail = ""
  %endif

  %assign commentStr = SLibGetRTMSubStructCommentStr(structName)
  
  %openfile structTypeDef
  %if !WHITE_SPACE(commentStr)
    %<commentStr> \
  %endif      

  struct %<tag> {
    %<structFields>
  }%<structTail>;
  %closefile structTypeDef
  
  %return structTypeDef
%endfunction %% FcnGenTypeDefFromHStruct


%% Function: RTMGenOpaqueTypedef ===============================================
%% Abstract:
%%   Generate an opaque typedef of the rtModel
%%
%function RTMsGenOpaqueTypedef(system) void  
  %if SLibCanInlineRTMIntoSelf() && !SLibSynthesizedRTM()
    %return
  %endif
  
  %if !EmptyRealTimeObject
    %openfile rtmTypedef
      /* Forward declaration for rtModel */
      %if SLibIsSelfUserDefinedAndStructured()
        %assign legacyRTMTypeName = ::CompiledModel.GlobalScope.tSimStructType
        typedef struct %<::tSimStructTypeTag> %<legacyRTMTypeName>;
      %else
        typedef struct %<::tSimStructTypeTag> %<::tSimStructType>;
      %endif
    %closefile rtmTypedef
  %else
    %assign rtmTypedef = ""
  %endif
  %return rtmTypedef
%endfunction %% RTMGenOpaqueTypedef



%% Function: RTMGenRtMdlTypedef ================================================
%% Abstract:
%%   Generates the typedef for the rtModel based on the usage of various 
%%   fields in the rtModel record.
%% 
%function RTMsGenRtMdlTypedef(system) void
  %assign rtRecs = RTMGetRTModelRecShell()
  
  %if RTMModelPtrsToInstanceDataIsReqFcn()
    %if !SLibGetUseRTMcgType()
      %assign rtRecs.BlockIO.DataType = "VOID"
      %assign rtRecs.DefaultParam.DataType = "VOID"
      %assign rtRecs.U.DataType = "VOID"
      %assign rtRecs.Y.DataType = "VOID"
      %assign rtRecs.RootDWork.DataType = "VOID"
      %assign rtRecs.PrevZCSigState.DataType = "ZC_SIG_STATE_CLASSIC"
    %endif
    %assign rtRecs.ContStates.DataType = "REAL"
  %endif

  %if !::CompiledModel.SuppressSelf && !SLibSynthesizedRTM()
    %assign baseIdx = GetBaseSystemIdx()
    %foreach idx = ::CompiledModel.NumCoderDataGroups
      %if idx == SLibGetSelfCoderDataGroupIndex()
        %continue
      %endif
      %assign group = ::CompiledModel.CoderDataGroup[idx]
      %if group.AsStructure == "Standalone"
        %continue
      %elseif !SLibAllocatesCoderDataGroup(group) || LibCoderDataGroupStructIsEmpty(group) || !SLibHaveRootDataGroupVarGroup(group)
        %continue
      %endif
      %assign typeToken = "CoderDataGroup" + group.Name
      %assign type = FcnSysVarGroupType(::CompiledModel.System[baseIdx], typeToken)
      %assign fieldName = SLibCoderDataGroupRTMFieldName(group)
      %assign rtRecs.%<fieldName>.DataType = type
    %endforeach
  %endif
  
  %%
  %% Generate the type strings for each field
  %%
  %<FcnGenTypeStrForRTMFields(rtRecs)>\
  %%
  %% Generate a hierarhical TLC structure from the rtModel records
  %%
  %assign hStruct = FcnGenHStructFromRTMRecs(rtRecs)
  %%
  %% Generate typedef from HStruct
  %% 
  %% For simplified interface, we populate the default self (RTM) to have pointers to other groups (including default groups)
  %assign defaultSelfMaybeNeeded = ::CompiledModel.ModelRefSimpInterface == "1" && !SLibIsSelfUserDefinedAndStructured()

  %% For reusable top model, we always generate RTM. If there are no fields, we add an unused char to avoid compiler warnings.
  %% This is to maintain stable interface for top model entry point functions.
  %% There are some exceptions to this though, one of which is if the user has mapped Self, then we don't need to force
  %% the creation of this legacy RTM since we then use Self coder group to maintain the stable interface.
  %assign forceRTMCreation = MultiInstanceERTCode && !GenerateClassInterface && !SLibUseBackwardCompatibleReusableInterface() && !SLibIsSelfUserDefinedAndStructured()
  
  %if (hStruct.TotalNumFields > 0) || defaultSelfMaybeNeeded || forceRTMCreation
    %assign tag = "%<::tSimStructTypeTag>"
    %openfile typeBuf

    %assign cgTypeHasElements = TLC_FALSE
    %if SLibSynthesizedRTM() && (IsModelReferenceTarget() || SLibGetUseRTMcgType())
      %assign vargroup = ::CompiledModel.VarGroups.VarGroup[SLibGetSelfVarGroupIndex()]
      %if vargroup.CGTypeIdx > -1
        %assign cgType = ::CompiledModel.CGTypes.CGType[vargroup.CGTypeIdx]
        %% Check to see if Context structure contains parameter vargroup. If so, map the cgType
        %% to the type generated by the Parameter table
        %assign varGroupIdx = ...
          FcnSysVarGroupIndex(System[GetBaseSystemIdx()], "Parameter", 0)
        %foreach mIdx = cgType.Members.NumMembers
          %assign member = cgType.Members.Member[mIdx]
          %assign cgTypeHasElements = TLC_TRUE
          %if varGroupIdx >= 0 && ...
            vargroup.VarGroupElements[mIdx] == "RVG" + STRING(varGroupIdx)
            %assign paramType = tParametersType + "_"
            %assign cgPtrType = ::CompiledModel.CGTypes.CGType[member.CGTypeIdx]
            %if LibCGTypeIsPointer(member.CGTypeIdx)
              %assign cgBaseType = ::CompiledModel.CGTypes.CGType[LibCGTypeBaseIndex(member.CGTypeIdx)]
            %else
              %assign cgBaseType = cgPtrType
            %endif
            %if tParametersType != cgBaseType.Name
              typedef struct %<paramType> %<cgBaseType.Name>;\
            %endif
          %endif
        %endforeach
      %endif
    %endif

    %% Add a dummy field to RTM if empty
    %if hStruct.TotalNumFields==0 && !SLibIsSelfUserDefinedAndStructured() && !cgTypeHasElements
      %assign NO_PARENT        = ""
      %assign NO_QUALIFIER     = ""
      %assign FORCE_NO_MACRO            = [-1, -1, -1, -1]  
      %<RTMAddRecSclr(...
        "UNUSED", ...
        "rt_unused", ...
        NO_PARENT, ...
        "CHAR", ...
        NO_QUALIFIER, ...
        FORCE_NO_MACRO, ...
        "RTMAlwaysReqIsReqFcn()")>
      %% Re-generate the type strings for each field
      %<FcnGenTypeStrForRTMFields(rtRecs)>\
      %assign hStruct = FcnGenHStructFromRTMRecs(rtRecs)
    %endif

    %if !SLibCanInlineRTMIntoSelf()
      /* Real-time Model Data Structure */
      %<FcnGenTypeDefFromHStruct(::tSimStructType, hStruct, ...
        "%<tag>")>\
    %else
      %assign rtmTypeFields = FcnGenTypeDefFromHStruct_Fields(::tSimStructType, hStruct)
      %<LibAddToCompiledModel("RTMTypeFields", rtmTypeFields)>
    %endif
    %closefile typeBuf
  %else
    %assign ::CompiledModel.EmptyRealTimeObject = 1
    %assign typeBuf = ""
  %endif
  %return typeBuf
%endfunction %% RTMGenRtMdlTypedef


%% FcnRTMFieldNeedsMacro =======================================================
%% Abstract:
%%   Is a macro needed RTM field?
%%
%function FcnRTMFieldNeedsMacro(fld) void
  %assign retVal = TLC_FALSE %% assume 
  
  %if SLibIsERTCodeFormat() && !GenerateGRTWrapper
    %if ISFIELD(fld,"ERTMacro") && ...
      (fld.RecType != "Variable" || FcnRTMFieldIsRequired(fld))
      %assign numAccesses = SIZE(fld.ERTMacro)[1]
      %foreach aIdx = numAccesses
	%if fld.ERTMacro[aIdx] > 0
	  %assign retVal = TLC_TRUE
	  %break
	%endif
      %endforeach
    %endif
  %else
    %assign retVal = TLC_TRUE
  %endif
      
  %return retVal
%endfunction %% FcnRTMFieldNeedsMacro


%function FcnRTMAccessNeedsMacro(fld, accessType, macroLoc)
  %assign retVal     = TLC_FALSE
  %assign accessCode = 0
  
  %if ISFIELD(fld,"ERTMacro")
    %switch accessType
      %case "Set"
	%assign accessCode = fld.ERTMacro[0]
	%break
      %case "Get"
	%assign accessCode = fld.ERTMacro[1]
	%break
      %case "Is"
	%assign accessCode = fld.ERTMacro[2]
	%break
      %case "Other"
	%assign accessCode = fld.ERTMacro[3]
	%break
    %endswitch
  %endif
  
  %if SLibIsERTCodeFormat() 
    %assign macLocCode = 0
    %switch macroLoc
      %case "PUBLIC"
	%assign macLocCode = 1
	%break
      %case "PRIVATE"
	%assign macLocCode = 2
	%break
    %endswitch
    %if !GenerateGRTWrapper 
      %if ISFIELD(fld,"ERTMacro")
	%assign retVal = (macLocCode == accessCode)
      %endif
    %else
      %% If grtInterface is required, 
      %% Always generate macro in public
      %%
      %if accessCode == -1 %% FORCE_NO_MACRO 
	%assign retVal = TLC_FALSE
      %else
	%assign retVal = (macLocCode == 1)
      %endif
    %endif
  %else
    %assign retVal = TLC_TRUE
  %endif
  %return retVal
%endfunction %% FcnRTMAccessNeedsMacro


%% Function: FcnGenVariableMacro ===============================================
%% Abstract:
%%   Generate macros for a simple variable field
%%
%function FcnGenVariableMacro(fldName, fld, macroLoc) void
  %assign macros = ""

  %if FcnRTMAccessNeedsMacro(fld, "Get", macroLoc)
    %assign macName = "rtmGet" + fldName
    %assign macros  = macros + "#ifndef %<macName>\n"
    %assign macros  = macros + "# define %<macName>(rtm) "
    %assign accStr  = FcnGenFieldAccessString(fld, "get", "", "", "(rtm)")
    %assign macros  = macros + "(%<accStr>)\n"
    %assign macros  = macros + "#endif\n\n"
  %endif
  
  %if FcnRTMAccessNeedsMacro(fld, "Set", macroLoc)
    %assign macName = "rtmSet" + fldName
    %assign macros  = macros + "#ifndef %<macName>\n"
    %assign macros  = macros + "# define %<macName>(rtm, val) "
    %assign accStr  = FcnGenFieldAccessString(fld, "set", "", "val", "(rtm)")
    %assign macros  = macros + "(%<accStr>)\n"
    %assign macros  = macros + "#endif\n\n"
  %endif
  
  %return macros
  
%endfunction %% FcnGenVariableMacro


%% Function: FcnGenIndexedAccessMacro ==========================================
%% Abstract:
%%   Generate macros for a simple variable field
%%
%function FcnGenIndexedAccessMacro(fldName, fld, idxFld, macroLoc) void
  %assign macros = ""

  %if FcnRTMAccessNeedsMacro(fld, "Get", macroLoc)
    %assign macName = "rtmGet" + fldName
    %assign macros  = macros + "#ifndef %<macName>\n"
    %assign macros  = macros + "# define %<macName>(rtm, idx) "
    %assign accStr  = FcnGenFieldAccessString(idxFld, "get", "idx", "", "(rtm)")
    %assign macros  = macros + "(%<accStr>)\n"
    %assign macros  = macros + "#endif\n\n"
  %endif

  %if FcnRTMAccessNeedsMacro(fld, "Set", macroLoc)
    %assign macName = "rtmSet" + fldName
    %assign macros  = macros + "#ifndef %<macName>\n"
    %assign macros  = macros + "# define %<macName>(rtm, idx, val) "
    %assign accStr  = FcnGenFieldAccessString(idxFld, "set", "idx", "val", "(rtm)")
    %assign macros  = macros + "(%<accStr>)\n"
    %assign macros  = macros + "#endif\n\n"
  %endif
  
  %return macros
  
%endfunction %% FcnGenIndexedAccessMacro


%% Function: FcnGenSpecialAccessMacro ==========================================
%% Abstract:
%%   Generate macros for a simple variable field
%%
%function FcnGenSpecialAccessMacro(fldName, fld, rtRecs, macroLoc) void
  %assign macros = ""
  
  %% Generate the list of args
  %assign comma = ""
  %if FcnNeedRTMInMacroArg(fld)
    %assign argStr = "rtm"
    %assign comma = ", "
  %else
    %assign argStr = ""
  %endif
  %assign args   = fld.Args
  %foreach argIdx = fld.NumArgs
    %assign argStr = argStr + comma 
    %assign argStr = argStr + args[argIdx]
    %assign comma = ", "
  %endforeach
  
  %if fld.GetFcn != "" && FcnRTMAccessNeedsMacro(fld, "Get", macroLoc)
    %assign accStr = %<fld.GetFcn>(fld, "(rtm)")
    %if !WHITE_SPACE(accStr)
      %assign macName = "rtmGet" + fldName
      %assign macros  = macros + "#ifndef %<macName>\n"
      %assign macros  = macros + "# define %<macName>(%<argStr>) "
      %assign macros  = macros + "%<accStr>\n"
      %assign macros  = macros + "#endif\n\n"
    %endif
  %endif
  
  %if fld.SetFcn != "" && FcnRTMAccessNeedsMacro(fld, "Set", macroLoc)
    %if fld.SetHasValArg
      %assign accStr = %<fld.SetFcn>(fld, "(rtm)", "val")
    %else
      %assign accStr = %<fld.SetFcn>(fld, "(rtm)")
    %endif
    %if !WHITE_SPACE(accStr)
      %assign macName = "rtmSet" + fldName
      %assign valArg  = fld.SetHasValArg ? comma + "val" : ""
      %assign macros  = macros + "#ifndef %<macName>\n"
      %assign macros  = macros + "# define %<macName>(%<argStr>%<valArg>) "
      %assign macros  = macros + "%<accStr>\n"
      %assign macros  = macros + "#endif\n\n"
    %endif
  %endif
    
  %if fld.IsFcn != "" && FcnRTMAccessNeedsMacro(fld, "Is", macroLoc)
    %assign accStr = %<fld.IsFcn>(fld, "(rtm)")
    %if !WHITE_SPACE(accStr)
      %assign macName = "rtmIs" + fldName
      %assign macros  = macros + "#ifndef %<macName>\n"
      %assign macros  = macros + "# define %<macName>(%<argStr>) "
      %assign macros  = macros + "%<accStr>\n"
      %assign macros  = macros + "#endif\n\n"
    %endif
  %endif
    
  %if fld.OtherFcn != "" && FcnRTMAccessNeedsMacro(fld, "Other", macroLoc)
    %assign accStr = %<fld.OtherFcn>(fld, "(rtm)")
    %if !WHITE_SPACE(accStr)
      %assign macName = "rtm" + fldName
      %assign macros  = macros + "#ifndef %<macName>\n"
      %assign macros  = macros + "# define %<macName>(%<argStr>) "
      %assign macros  = macros + "%<accStr>\n"
      %assign macros  = macros + "#endif\n\n"
    %endif
  %endif
    
  %return macros
  
%endfunction %% FcnGenSpecialAccessMacro


%% Function: RTMGenMacroDefines ================================================
%% Abstract:
%%   Generates macros for the fields of the rtModel that are under use.
%% 
%function RTMsGenMacroDefines(system, macroLoc) void
  %assign rtRecs     = RTMGetRTModelRecShell()
  %assign rootFields = FIELDNAMES(rtRecs)
  %assign numFields  = SIZE(rootFields)[1]
  
  %assign vMacs = ""
  %assign iMacs = ""
  %assign sMacs = ""
  
  %foreach fldIdx = numFields
    %assign thisfld = rtRecs.%<rootFields[fldIdx]>
    %if FcnRTMFieldNeedsMacro(thisfld)
      %switch(thisfld.RecType)
	%case "Variable"
	  %assign vMacs = vMacs + ...
	    FcnGenVariableMacro(rootFields[fldIdx], thisfld, macroLoc)
	  %break
	%case "IndexedAccess"
	  %assign iMacs = iMacs + ...
	    FcnGenIndexedAccessMacro(rootFields[fldIdx], thisfld, ...
	    rtRecs.%<thisfld.AccessedRec>, macroLoc)
	  %break
	%case "SpecialAccess"
	  %assign sMacs = sMacs + ...
	    FcnGenSpecialAccessMacro(rootFields[fldIdx], thisfld, ...
	    rtRecs, macroLoc)
	  %break
      %endswitch
    %endif
  %endforeach
  
  %openfile macBuf
  %if !WHITE_SPACE(vMacs)
    %<vMacs>
  %endif

  %if !WHITE_SPACE(iMacs)
    %<iMacs>
  %endif

  %if !WHITE_SPACE(sMacs)
    %<sMacs>
  %endif
  %<RTMGenMacroDefinesForGRTWrapper(rtRecs, macroLoc)>
  %closefile macBuf
  %return macBuf
%endfunction %% RTMGenMacroDefines

%% Function: RTMGenMacroDefinesForGRTWrapper
%% Abstract:
%%   This function will generat macros that are used in grt_main.c
%% but not needed for ert code format. To compile grt_main.c, 
%% when GenerateGRTWrapper is true, need generate these macros. 
%% These macros will access a GRTTimingEngineTmp if field does not exist. 
%% Please note that the return values of these macros is not really
%% used in grt_main.c when GenerateGRTWrapper is true.
%%
%function RTMGenMacroDefinesForGRTWrapper(rtRecs, macroLoc)
  %assign macros = ""
  %if GenerateGRTWrapper && macroLoc == "PUBLIC"

    %if !UsingMalloc
      %% rtwsolverinfo is special
      %assign fld = rtRecs.RTWSolverInfo
      %assign macName = "rtmGetRTWSolverInfo"
      %assign macros  = macros + "#ifdef %<macName>\n"
      %assign macros  = macros + "#undef %<macName>\n"
      %assign macros  = macros + "#endif\n"
      %assign macros  = macros + "#define %<macName>(rtm) "
      %assign accStr  = FcnGenFieldAccessString(fld, "get", "", "", "(rtm)")
      %assign macros  = macros + "&(%<accStr>)\n"
    %endif %% !isGRTMallocOnERT()
  %endif
  
  %return macros
%endfunction

%% Function: RTMAddExternRTModelDecl ===========================================
%% Abstract:
%%   Create an extern declaration of rtModel. Used in the DSP blockset.
%%
%function RTMsAddExternRTModelDecl(system) Output
  %if GenRTModel
    #include "%<::CompiledModel.Name>.h"
    
    extern %<SLibGetQualifiedRTMType()> *const %<::tSimStruct>;
  %else
    #include "simstruc.h"
    
    extern SimStruct *const %<::tSimStruct>;
  %endif
%endfunction

%% Function: FcnGetContStateType ==============================================
%% Abstract:
%%   Get type of contStates in Real-time model data structure
%%
%function FcnGetContStateType() void
  %if GRTInterface || isGRTMalloc || !GenRTModel
    %return "real_T"
  %else
    %return ::tContStateType
  %endif
%endfunction

%% Function: FcnGetPrevZCSigStateType ==========================================
%% Abstract:
%%   Get type of prevZCSigState in Real-time model data structure
%%
%function FcnGetPrevZCSigStateType() void
  %if GRTInterface || isGRTMalloc || !GenRTModel
    %return "ZCSigState"
  %else
    %return ::tPrevZCStateType
  %endif
%endfunction

%% Function: GetSimStructExpr =================================================
%% Abstrct:
%%    RTM pointer is removed from cpp class declaration, places that use this 
%%    pointer now need to use RTM object's address instead. We need to add "&"
%%    to rtmName whenever it is needed.
%function GetSimStructExpr(system, rtmName)
  %if SLibGetDoesSelfHasCoderDataGroup() && SLibIsSelfStructured() && !SLibCanInlineRTMIntoSelf() && !GenerateClassInterface
    %assign rtmName = rtmName + "->" + SLibGetRTMPointerVariableNameInsideSelfStructure()
  %endif
  
  %if GenerateClassInterface && IsBaseSystem(System[system.ReusedParentSystemIdx]) && ...
    ::BlockFcn != "Rate_Scheduler" && ::BlockFcn != "InitializeDataMapInfo" && rtmName != "getRTM()"
    %assign rtmName = "(&" + rtmName + ")"
  %elseif SLibIsSelfStructured() && IsModelRefScalableBuild() && !GenerateClassInterface
    %if IsModelReferenceSimTarget()
      %assign rtmName = "(&" + FcnGetSFcnDWorkRTM() + ")"
    %else
      %assign rtmName = "(&" + ::CompiledModel.GlobalScope.tRTM + ")"
    %endif
  %endif
  %return rtmName
%endfunction

%function LibSetNumTicksToNextHitForVariableDiscrete(stIdx, numTicks) void
  %if IsModelReferenceTarget()
    %return "%<RTMSetIdxed("NumTicksToNextHitForVDRInMdlRef", "%<stIdx>", "%<numTicks>")>"
    
  %elseif GenRTModel && SLibIsERTCodeFormat()
    %return "%<RTMSetIdxed("VDRNumTicksToNextHit", "%<stIdx>", "%<numTicks>")>"  
    
  %else      
    %assign comma = ", "
    %return "ssSetNumTicksToNextHitForVariableDiscrete(" + ...
      "%<SLibGetSimStruct()>" + comma + ...
      "%<stIdx>" + comma + ...
      "%<numTicks>" + ");"
  %endif
%endfunction %% RTMSetNumTicksToNextHit

%% Function: RTMSetNumTicksToNextHitForVariableDiscrete ===================
%% Abstract:
%%   Generates code to set the number of ticks to the next variable discrete hit
%% time. Blocks with variable discrete sample time must call this function in their 
%% output functions.
%%
%function RTMSetNumTicksToNextHitForVariableDiscrete(block, st_index, numTicks) void
  %assert GenRTModel && SLibIsERTCodeFormat()
  %return LibSetNumTicksToNextHitForVariableDiscrete(%<SLibGetBlockDiscVarIndex(block, 0)>, numTicks)  
%endfunction %% RTMSetNumTicksToNextHitForVariableDiscrete
%% [EOF] rtmdllib.tlc
